<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[归并排序求逆序数]]></title>
    <url>%2FAngelNI.github.io%2FInverse-number%2F</url>
    <content type="text"><![CDATA[君子终日乾乾，夕惕若厉，无咎。 归并排序求逆序数练习题 poj1804 poj2299 HDU4911 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/*归并排序求逆序数*//*我们知道mergesort是稳定排序，所以就可以根据这个特点来求序列的逆序数在Merge()中，合并两个已经有序的数组A,B.因为A.B有序,所以,A,B各自的逆序数是0,所以AB的逆序数等于A,B之间的逆序数.*/#include&lt;iostream&gt;using namespace std;typedef long long ll;const ll N = 1e7+10;ll a[N];ll sum;void merge(ll *A,ll start,ll mid, ll end)&#123; ll p = start,q = mid+1; ll arr[end-start+1],k=0; while(p&lt;=mid&amp;&amp;q&lt;=end) &#123; if(a[p]&lt;a[q]) &#123; arr[k++] = a[p++]; &#125; else &#123; sum+=(mid-p+1);//求逆序数 arr[k++] = a[q++]; &#125; &#125; while(p&lt;=mid) arr[k++] = a[p++]; while(q&lt;=end) arr[k++] = a[q++]; for(ll i =start;i&lt;=end;++i) a[i] = arr[i-start];&#125;void mergesort(ll *A,ll start,ll end)&#123; if(start&lt;end) &#123; //二分；分治 ll mid = (start+end)&gt;&gt;1; mergesort(A,start,mid); mergesort(A,mid+1,end); merge(A,start,mid,end); &#125;&#125;int main()&#123; ll n; cout&lt;&lt;"please input the number of data"&lt;&lt;endl; while(cin&gt;&gt;n&amp;&amp;n) &#123; sum = 0; cout&lt;&lt;"please input the sequence"&lt;&lt;endl; for(int i =0;i&lt;n;++i) cin&gt;&gt;a[i]; mergesort(a,0,n-1); cout&lt;&lt;"After sorting:"&lt;&lt;endl; for(int i =0;i&lt;n;++i) &#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; cout&lt;&lt;"The number is"&lt;&lt;endl; cout&lt;&lt;sum&lt;&lt;endl; cout&lt;&lt;"please input the number of data"&lt;&lt;endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Inverse_number</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则——常用匹配公式]]></title>
    <url>%2FAngelNI.github.io%2Fre-expression%2F</url>
    <content type="text"><![CDATA[正则！正则！正则！正则！正则！正则！正则！正则！ 正则——常用匹配公式转载 一、数字校验123456789101112131415161718192021222324252627282930313233343536371 数字：^[0-9]*$2 n位的数字：^\d&#123;n&#125;$3 至少n位的数字：^\d&#123;n,&#125;$4 m-n位的数字：^\d&#123;m,n&#125;$5 零和非零开头的数字：^(0|[1-9][0-9]*)$6 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$7 带1-2位小数的正数或负数：^(-)?\d+(.\d&#123;1,2&#125;)?$8 正数、负数、和小数：^(-|+)?\d+(.\d+)?$9 有两位小数的正实数：^[0-9]+(.[0-9]&#123;2&#125;)?$10 有1~3位小数的正实数：^[0-9]+(.[0-9]&#123;1,3&#125;)?$11 非零的正整数：^[1-9]\d*![或 ^([1-9][0-9]\*)&#123;1,3&#125;](https://math.jianshu.com/math?formula=%E6%88%96%20%5E(%5B1-9%5D%5B0-9%5D\*)%7B1%2C3%7D) 或 ^+?[1-9][0-9]*$12 非零的负整数：^-[1-9][]0-9&quot;*![或 ^-[1-9]\d*](https://math.jianshu.com/math?formula=%E6%88%96%20%5E-%5B1-9%5D%5Cd*)13 非负整数：^\d+![或 ^[1-9]\d*|0](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5B1-9%5D%5Cd*%7C0)14 非正整数：^-[1-9]\d*|0![或 ^((-\d+)|(0+))](https://math.jianshu.com/math?formula=%E6%88%96%20%5E((-%5Cd%2B)%7C(0%2B)))15 非负浮点数：^\d+(.\d+)?![或 ^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5B1-9%5D%5Cd*%5C.%5Cd*%7C0%5C.%5Cd*%5B1-9%5D%5Cd*%7C0%3F%5C.0%2B%7C0)16 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))![或 ^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0](https://math.jianshu.com/math?formula=%E6%88%96%20%5E(-(%5B1-9%5D%5Cd*%5C.%5Cd*%7C0%5C.%5Cd*%5B1-9%5D%5Cd*))%7C0%3F%5C.0%2B%7C0)17 正浮点数：^[1-9]\d*.\d*|0.\d*[1-9]\d*![或 ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))](https://math.jianshu.com/math?formula=%E6%88%96%20%5E((%5B0-9%5D%2B%5C.%5B0-9%5D*%5B1-9%5D%5B0-9%5D*)%7C(%5B0-9%5D*%5B1-9%5D%5B0-9%5D*%5C.%5B0-9%5D%2B)%7C(%5B0-9%5D*%5B1-9%5D%5B0-9%5D*)))18 负浮点数：^-([1-9]\d*.\d*|0.\d*[1-9]\d*)![或 ^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))](https://math.jianshu.com/math?formula=%E6%88%96%20%5E(-((%5B0-9%5D%2B%5C.%5B0-9%5D*%5B1-9%5D%5B0-9%5D*)%7C(%5B0-9%5D*%5B1-9%5D%5B0-9%5D*%5C.%5B0-9%5D%2B)%7C(%5B0-9%5D*%5B1-9%5D%5B0-9%5D*))))19 浮点数：^(-?\d+)(.\d+)?![或 ^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)](https://math.jianshu.com/math?formula=%E6%88%96%20%5E-%3F(%5B1-9%5D%5Cd*%5C.%5Cd*%7C0%5C.%5Cd*%5B1-9%5D%5Cd*%7C0%3F%5C.0%2B%7C0)) 二、校验字符的表达式12345678910111213141516171819202122231 汉字：^[\u4e00-\u9fa5]&#123;0,&#125;$2 英文和数字：^[A-Za-z0-9]+![或 ^[A-Za-z0-9]&#123;4,40&#125;](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5BA-Za-z0-9%5D%7B4%2C40%7D)3 长度为3-20的所有字符：^.&#123;3,20&#125;$4 由26个英文字母组成的字符串：^[A-Za-z]+$5 由26个大写英文字母组成的字符串：^[A-Z]+$6 由26个小写英文字母组成的字符串：^[a-z]+$7 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$8 由数字、26个英文字母或者下划线组成的字符串：^\w+![或 ^\w&#123;3,20&#125;](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5Cw%7B3%2C20%7D)9 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$10 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+![或 ^[\u4E00-\u9FA5A-Za-z0-9]&#123;2,20&#125;](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5B%5Cu4E00-%5Cu9FA5A-Za-z0-9%5D%7B2%2C20%7D)11 可以输入含有^%&amp;&apos;,;=?![\&quot;等字符：[^%&amp;&apos;,;=?](https://math.jianshu.com/math?formula=%5C%22%E7%AD%89%E5%AD%97%E7%AC%A6%EF%BC%9A%5B%5E%25%26&apos;%2C%3B%3D%3F)\x22]+12 禁止输入含有的字符：[^\x22]+ 三、特殊需求表达式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162631 Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*.\w+([-.]\w+)*$2 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?3 InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+.)+[\w-]+(/[\w-./?%&amp;=]*)?$4 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d&#123;8&#125;$5 电话号码(&quot;XXX-XXXXXXX&quot;、&quot;XXXX-XXXXXXXX&quot;、&quot;XXX-XXXXXXX&quot;、&quot;XXX-XXXXXXXX&quot;、&quot;XXXXXXX&quot;和&quot;XXXXXXXX)：^((\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$6 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;7 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$8 短身份证号码(数字、字母x结尾)：^([0-9])&#123;7,18&#125;(x|X)?![或 ^\d&#123;8,18&#125;|[0-9x]&#123;8,18&#125;|[0-9X]&#123;8,18&#125;?](https://math.jianshu.com/math?formula=%E6%88%96%20%5E%5Cd%7B8%2C18%7D%7C%5B0-9x%5D%7B8%2C18%7D%7C%5B0-9X%5D%7B8%2C18%7D%3F)9 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$10 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w&#123;5,17&#125;$11 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$12 日期格式：^\d&#123;4&#125;-\d&#123;1,2&#125;-\d&#123;1,2&#125;13 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$15 钱的输入格式：16 1.有四种钱的表示形式我们可以接受:&quot;10000.00&quot; 和 &quot;10,000.00&quot;, 和没有 &quot;分&quot; 的 &quot;10000&quot; 和 &quot;10,000&quot;：^[1-9][0-9]*$17 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符&quot;0&quot;不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$18 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$19 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$20 5.必须说明的是,小数点后面至少应该有1位数,所以&quot;10.&quot;是不通过的,但是 &quot;10&quot; 和 &quot;10.2&quot; 是通过的：^[0-9]+(.[0-9]&#123;2&#125;)?$21 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]&#123;1,2&#125;)?$22 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*(.[0-9]&#123;1,2&#125;)?$23 8.1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]&#123;1,3&#125;(,[0-9]&#123;3&#125;)*)(.[0-9]&#123;1,2&#125;)?$24 备注：这就是最终结果了,别忘了&quot;+&quot;可以用&quot;*&quot;替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里25 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$26 中文字符的正则表达式：[\u4e00-\u9fa5]27 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1))28 空白行的正则表达式：\n\s*\r (可以用来删除空白行)29 HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)30 首尾空白字符的正则表达式：^\s*|\s*![或(^\s*)|(\s*](https://math.jianshu.com/math?formula=%E6%88%96(%5E%5Cs*)%7C(%5Cs*)) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式)31 腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)32 中国邮政编码：[1-9]\d&#123;5&#125;(?!\d) (中国邮政编码为6位数字) 33 IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用) 34 IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.)&#123;3&#125;(?:25[0-5]|2[0-4]\d|[01]?\d?\d))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分图最大匹配]]></title>
    <url>%2FAngelNI.github.io%2Fbinary-picture%2F</url>
    <content type="text"><![CDATA[匈牙利算法。 二分图二分图也叫二部图，设G=(V,E)是一个无向图，如果顶点V可分割为两个互不相交的子集(A,B)，并且图中的每条边（i，j）所关联的两个顶点i和j分别属于这两个不同的顶点集(i in A,j in B)，则称图G为一个二分图。如下图所有的顶点可以分成A，B两个集合，而A集合与B集合中的点与自己的阵营的点是没有连线的（A集合的点只与B集合的点有边相连），则称这个为一个二分图.(离散数学中的内容) 点覆盖：对于图G=(V,E)中的一个点覆盖是一个集合S⊆V使得每一条边至少有一个端点在S中。最小点覆盖：点个数最少的S集合。 二分图的最大匹配的含义，就是说在这A，B两个集合中不断选择两个存在连线（只有存在连线才能连起来，而且每个点只能匹配一次）的两个点相连，求最多可以有多少条连线即这个二分图的最大匹配数 可以参考 二分图匹配，生动有趣的文章。 性质123456789定义和定理： 最大匹配数：最大匹配的匹配边的数目 最小点覆盖数：选取最少的点，使任意一条边至少有一个端点被选择 最大独立数：选取最多的点，使任意所选两点均不相连 最小路径覆盖数：对于一个 DAG（有向无环图），选取最少条路径，使得每个顶点属于且仅属于一条路径。路径长可以为 0（即单个点）。 定理1：最大匹配数 = 最小点覆盖数（这是 Konig 定理） 定理2： 最大独立数与最小点覆盖数互补 定理3：最小路径覆盖数 = 顶点数 - 最大匹配数 匈牙利算法匈牙利算法是由匈牙利数学家Edmonds于1965年提出，因而得名。匈牙利算法是基于Hall定理中充分性证明的思想，它是部图匹配最常见的算法，该算法的核心就是寻找增广路径，它是一种用增广路径求二分图最大匹配的算法。 增广路径若图G中一条连通两个未匹配顶点的路径，并且属于M的边和不属于M的边(即已匹配和待匹配的边)在P上交替出现，则称P为相对于M的一条增广路径（举例来说，有A、B集合，增广路由A中一个点通向B中一个点，再由B中这个点通向A中一个点……交替进行）。 12345678910匈牙利算法: 算法轮廓： 1. 置M为空 2. 找出一条增广路径P，通过取反操作获得更大的匹配M’代替M 3. 重复2操作直到找不出增广路径为止增广路径: 我们采用DFS的办法找一条增广路径： 从A部一个未匹配的顶点u开始，找一个未访问的邻接点v（v一定是B部顶点）。对于v，分两种情况： 1.如果v未匹配，则已经找到一条增广路 2.如果v已经匹配，则取出v的匹配顶点w(w一定是A部顶点)，边(w,v)目前是匹配的，根据“取反”的想法，要将(w,v)改为未匹配，(u,v)设为匹配，能实现这一点的条件是看从w为起点能否新找到一条增广路径P’。如果行，则u-v-P’就是一条以u为起点的增广路径。 练习HDU2306模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 510;int map[N],vis[N];int pp[N][N];int n,m,k;int dfs(int x)&#123; //对另一个集合进行查找 for(int i =1;i&lt;=m;++i) &#123; if(!vis[i]&amp;&amp;pp[x][i]) &#123; vis[i] = 1; if(!map[i]||dfs(map[i])) &#123; map[i] =x; return 1; &#125; &#125; else &#123; continue; &#125; &#125; return 0;&#125;int main()&#123; while(cin&gt;&gt;k&amp;&amp;k) &#123; int ans = 0; memset(map,0,sizeof(map)); memset(pp,0,sizeof(pp)); cin&gt;&gt;n&gt;&gt;m; for(int i =1;i&lt;=k;++i) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; pp[a][b] = 1; &#125; for(int i =1;i&lt;=n;++i) &#123; memset(vis,0,sizeof(vis)); if(dfs(i)) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; system("pause"); return 0;&#125; LuoguP3386模板题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 1010;int map[N],vis[N],pp[N][N];int k,n,m;int dfs(int x)&#123; for(int i =1;i&lt;=m;++i) &#123; if(!vis[i]&amp;&amp;pp[x][i]) &#123; vis[i] = 1; if(!map[i]||dfs(map[i])) &#123; map[i] = x; return 1; &#125; &#125; else &#123; continue; &#125; &#125; return 0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; memset(map,0,sizeof(map)); memset(pp,0,sizeof(pp)); for(int i =1;i&lt;=k;++i) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; pp[a][b] = 1; &#125; int ans=0; for(int i=1;i&lt;=n;++i) &#123; memset(vis,0,sizeof(vis)); if(dfs(i)) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0;&#125; HDU1083123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;const int N = 310;int mp[N],vis[N],pp[N][N];int n,m,k,t;int dfs(int x)&#123; for(int i =1;i&lt;=m;++i) &#123; if(!vis[i]&amp;&amp;pp[x][i]) &#123; vis[i] =1; if(!mp[i] || dfs(mp[i])) &#123; mp[i] = x; return 1; &#125; &#125; else &#123; continue; &#125; &#125; return 0;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; memset(mp,0,sizeof(mp)); memset(pp,0,sizeof(pp)); for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;k; while(k--) &#123; int a; cin&gt;&gt;a; pp[i][a] =1; &#125; &#125; int ans = 0; for(int i =1;i&lt;=n;++i) &#123; memset(vis,0,sizeof(vis)); if(dfs(i)) ans++; &#125; if(ans == n) puts("YES"); else &#123; puts("NO"); &#125; &#125; system("pause"); return 0;&#125; poj3041在这里用到性质里的内容，最小覆盖数 == 最大匹配数 点覆盖 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 600;const int NN = 1e5+10;int mp[NN],vis[NN],pp[N][N];int n,k;int dfs(int x)&#123; for(int i =1;i&lt;=n;++i) &#123; if(!vis[i]&amp;&amp;pp[x][i]) &#123; vis[i] = 1; if(!mp[i]||dfs(mp[i])) &#123; mp[i] = x; return 1; &#125; &#125; else &#123; continue; &#125; &#125; return 0;&#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; memset(mp,0,sizeof(mp)); memset(pp,0,sizeof(pp)); for(int i =1;i&lt;=k;++i) &#123; int a,b; cin&gt;&gt;a&gt;&gt;b; pp[a][b] = 1; &#125; int ans = 0; for(int i =1;i&lt;=n;++i) &#123; memset(vis,0,sizeof(vis)); if(dfs(i)) ans++; &#125; cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0;&#125; poj3020感觉这道有点复杂，用到了 最小路径覆盖数 = 顶点数 - 最大匹配数，如何构造二分图，如何拆点。 引用一句话 “ 匈牙利算法解题是极为简单的，但是图论的难并不是难在解答，而是建图的过程，也难怪会有牛曰：用匈牙利算法，建图是痛苦的，最后是快乐的。” 贴上一个讲的比较好的文章传送门 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 410;int pp[N][N],lk[N],vis[N];int mapp[42][42];int h,w;int d[4][2] = &#123;-1,0,1,0,0,-1,0,1&#125;;int con;int dfs(int x)&#123; for(int i =1;i&lt;=con;++i) &#123; if(!vis[i]&amp;&amp;pp[x][i]) &#123; vis[i] = 1; if(!lk[i]||dfs(lk[i])) &#123; lk[i] = x; return 1; &#125; &#125; // else // &#123; // continue; // &#125; &#125; return 0;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;h&gt;&gt;w; con = 0; memset(lk,0,sizeof(lk)); memset(mapp,0,sizeof(mapp)); memset(pp,0,sizeof(pp)); char ch; for(int i =1;i&lt;=h;++i) &#123; for(int j =1;j&lt;=w;++j) &#123; cin&gt;&gt;ch; if(ch == '*') mapp[i][j] = ++con; &#125; &#125; for(int i =1;i&lt;=h;++i) &#123; for(int j =1;j&lt;=w;++j) &#123; if(mapp[i][j]) &#123; for(int k =0;k&lt;4;++k) &#123; int x = i + d[k][0]; int y = j + d[k][1]; if(mapp[x][y]) &#123; pp[mapp[i][j]][mapp[x][y]] = 1; &#125; &#125; &#125; &#125; &#125; int ans=0; for(int i =1;i&lt;=con;++i) &#123; memset(vis,0,sizeof(vis)); if(dfs(i)) ans++; &#125; //最小路径覆盖数 = 顶点数 - 最大匹配数 cout&lt;&lt;con-ans/2&lt;&lt;endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>binary_picture</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵快速幂]]></title>
    <url>%2FAngelNI.github.io%2Fmatrix-ksm%2F</url>
    <content type="text"><![CDATA[tql，ORZ，catch me off ground。 矩阵快速幂1.分解来看，是由矩阵乘法，和快速幂组成 矩阵乘法1234for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c[i][j]+=a[i][k]*b[k][j]; 快速幂1234567891011ll pow_ksm(ll a,ll n)&#123; ll res = 1; while(n) &#123; if(n&amp;1) res = res*a%mod; a = a*a%mod; n&gt;&gt;=1; &#125; return res;&#125; 模板1234567891011121314151617181920212223242526272829303132333435363738394041struct matrix&#123; ll m[101][101];&#125;matrix a, b;matrix mul(matrix x,matrix y)&#123; matrix c; for(int i =1;i&lt;=n;++i) &#123; for(int j =1;j&lt;=n;++j) &#123; c.m[i][j] = 0; &#125; &#125; for(int i =1;i&lt;=n;++i) &#123; for(int j =1;j&lt;=n;++j) &#123; for(int k =1;k&lt;=n;++k) &#123; c.m[i][j] += x.m[i][k]*y.m[k][j]%mod; &#125; &#125; &#125; return c;&#125;matrix pow_ksm(matrix x,ll y)&#123; matrix ans; memset(ans.m,0,sizeof ans.m); for(int i=1;i&lt;=n;i++) ans.m[i][i]=1; while(y) &#123; if(y&amp;1) ans = mul(ans,x); x = mul(x,x); y&gt;&gt;=1; &#125; return ans;&#125; 2.poj3070 Change many times ，finally pass。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;typedef long long ll;const int mod = 10000;struct node&#123; ll m[5][5];&#125;;node mul(node a,node b)&#123; node c; memset(c.m,0,sizeof c.m); // for(int i =1;i&lt;=5;++i) // &#123; // for(int j =1;j&lt;=5;++j) // &#123; // c.m[i][j] = 0; // &#125; // &#125; for(int i=1;i&lt;=2;++i) &#123; for(int j =1;j&lt;=2;++j) &#123; for(int k =1;k&lt;=2;++k) &#123; c.m[i][j] =(c.m[i][j] + a.m[i][k]*b.m[k][j])%mod; &#125; &#125; &#125; return c;&#125;node ksm(node x,ll y)&#123; node ans; memset(ans.m,0,sizeof(ans.m)); for(int i =1;i&lt;=2;++i) &#123; //for(int j =1;j&lt;=2;++j) ans.m[i][i] = 1; &#125; while(y) &#123; if(y&amp;1) ans = mul(ans,x); y&gt;&gt;=1; x = mul(x,x); &#125; return ans;&#125;int main()&#123; ll n; while(cin&gt;&gt;n&amp;&amp;n!=-1) &#123; if(n==0) printf("0\n"); else if(n==1||n==2) printf("1\n"); else &#123; node a,b; a.m[1][1] = 1; a.m[1][2] = 1; a.m[2][1] = 1; a.m[2][2] = 0; b.m[1][1] = 1; b.m[1][2] = 1; b.m[2][1] = 1; b.m[2][1] = 0; node ans = ksm(a,n-1); ans = mul(ans,b); printf("%d\n",ans.m[1][1] ) ; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>matirx_ksm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fibonacci]]></title>
    <url>%2FAngelNI.github.io%2FFibonacci%2F</url>
    <content type="text"><![CDATA[关于斐波那契的一些事 Fibonacci斐波那契数列（Fibonacci sequence），又称黄金分割数列、因[数学家]列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为兔子数列. 123定义如下： F(0) = 0 ,F(1) = 1; f(n) = F(n-1)+F(n-2) 性质123456789101112131415161718192021222324252627282930313233343536373839401性质一：模除周期性数列的数模除某个数的结果会呈现一定周期性，因为数列中的某个数取决与前两个数，一旦有连着的两个数的模除结果分别等于第0 第一项的模除结果，那麽代表着一个新的周期的的开始，如果模除n，则每个周期中的元素不会超过n×n;性质二：黄金分割随着i的增大F(n) / F(n-1) 接近于0.618性质三：平方与前后项从第二项开始，每个奇数项的平方都比前后两项之积多一，每个偶数项的平方比前后两项之积少一.性质四：斐波那契数列的第n+2项代表了集合&#123;1，2，...n&#125;中所有不包含相邻正整数的子集的个数.性质五：求和F1 + F3 +F5 +F7 ....+F(2*n-1) = F(2n) - F(2) + F(1)F2 + F4 + F6 + F8 +...+F(2n) = F(2n+1) - F(1)F1^2 + F2^2 + F3^2 + F4^2 + ... +Fn^2 = F(n)*F(n-1)性质六：两倍项关系F(2n) / F(n) = F(n-1) + F(n+1)性质七：尾数循环个位数：周期60最后两位：300最后三位：1500其他：F(n-1) * F(n+1) - F(n)^2 = (-1)^nF(1) + 2F(2) + 3F(3) + ... + nF(n) = nF(n+2) - F(n+3) +2 Calculate1,数学公式计算 12345678910double po(double a,int n)&#123; for(int i =1;i&lt;=n;++i) a*=a; return a;&#125;double solve1(int n)&#123; return 1/sqrt(5)*(po(((1+sqrt(5))/2),n)-po(((1-sqrt(5))/2),n));&#125; 2,递归123456789101112ll solve3(ll n)&#123; if(n==0) return 0; else if(n==1||n==2) return 1; else &#123; return solve3(n-1)+solve3(n-2); &#125; &#125; 3,递推12345678910111213141516ll solve2(ll n)&#123; F[0] = 0; F[1] = 1; F[2] = 1; if(n==1||n==0||n==2) return F[n]; else &#123; for(ll i =3;i&lt;=n;++i) &#123; F[i] = F[i-1]+ F[i-2]; &#125; return F[n]; &#125;&#125; 4,分治123456789101112131415161718ll solve4(ll n)&#123; //分治 if(n == 0) return 0; if(n==1||n==2) return 1; ll first = 0; ll second = 1; while(0 &lt; n--) &#123; second += first; first = second - first; &#125; return first + second;&#125; 4，矩阵快速幂12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;typedef long long ll;const int mod=10000;int f=2;struct node&#123; ll materix[5][5];&#125;;node mul(node a,node b) //矩阵乘法 &#123; node res; memset(res.materix,0,sizeof res.materix); for(int i=1;i&lt;=f;i++) for(int j=1;j&lt;=f;j++) for(int k=1;k&lt;=f;k++) res.materix[i][j]=(res.materix[i][j]+a.materix[i][k]*b.materix[k][j])%mod; return res; &#125;node ksm(node a,ll b)&#123; node ans; memset(ans.materix,0,sizeof ans.materix); for(int i=1;i&lt;=f;i++) ans.materix[i][i]=1; while(b) &#123; if(b&amp;1) ans=mul(ans,a); b&gt;&gt;=1; a=mul(a,a); &#125; return ans;&#125;int main()&#123; ll N; while(cin&gt;&gt;N&amp;&amp;N!=-1) &#123; if(N==1||N==2) printf("1\n"); if(N==0) printf("0\n"); else &#123; node a,b; a.materix[1][1]=1; a.materix[1][2]=1; a.materix[2][1]=1; a.materix[2][2]=0; //a是那个幂矩阵， b.materix[1][1]=1; b.materix[1][2]=0; b.materix[2][1]=1; b.materix[2][2]=0; //b是最初始的矩阵 node ans = ksm(a ,N-2); ans = mul(ans ,b) ; printf("%d\n",ans.materix[1][1] ) ; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Fibonacci</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高精度运算]]></title>
    <url>%2FAngelNI.github.io%2FHigh-precision%2F</url>
    <content type="text"><![CDATA[Just go ahead，never look back. 加法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;using namespace std;vector&lt;int&gt; A;vector&lt;int&gt; B;vector&lt;int&gt; add(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)&#123; if(A.size()&lt;B.size()) return add(B,A); vector&lt;int&gt; ans; int t = 0,i; for(i =0;i&lt;A.size();++i) &#123; t+=A[i]; if(i&lt;B.size()) t+=B[i]; ans.push_back(t%10); t/=10; &#125; while(i&lt;A.size()) &#123; t += A[i]; ans.push_back(t%10); t /=10; &#125; if(t) ans.push_back(t); return ans;&#125;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; for(int i = a.size()-1;i&gt;=0;--i) A.push_back(a[i]-'0'); for(int i = b.size()-1;i&gt;=0;--i) B.push_back(b[i]-'0'); auto ans = add(A,B); for(int i = ans.size()-1;i&gt;=0;--i) cout&lt;&lt;ans[i]; cout&lt;&lt;endl; A.clear(); B.clear(); system("pause"); return 0;&#125; 减法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;using namespace std;vector&lt;int&gt; A;vector&lt;int&gt; B;bool cmp(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)&#123;//判断二者数字的大小 if(A.size() !=B.size()) return A.size()&gt;B.size(); for(int i=A.size()-1;i&gt;=0;i--)&#123; if(A[i]!=B[i]) return A[i]&gt;B[i]; &#125; return true;&#125;vector&lt;int&gt; Minus(vector&lt;int&gt; &amp;A,vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; ans; int t = 0,i; for(i =0;i&lt;A.size();++i) &#123; t = A[i]-t; if(i&lt;B.size()) t-=B[i]; ans.push_back((t+10)%10); if(t&lt;0) t=1; else t = 0; &#125; // while(i&lt;A.size()) // &#123; // t += A[i]; // ans.push_back(t%10); // t /=10; // &#125; while(ans.size()&gt;1&amp;&amp;ans.back()==0) ans.pop_back(); return ans;&#125;int main()&#123; string a,b; cin&gt;&gt;a&gt;&gt;b; for(int i = a.size()-1;i&gt;=0;--i) A.push_back(a[i]-'0'); for(int i = b.size()-1;i&gt;=0;--i) B.push_back(b[i]-'0'); vector&lt;int&gt; ans; if(cmp(A,B)) ans = Minus(A,B); else &#123; cout&lt;&lt;'-'; ans = Minus(B,A); &#125; for(int i = ans.size()-1;i&gt;=0;--i) cout&lt;&lt;ans[i]; cout&lt;&lt;endl; A.clear(); B.clear(); system("pause"); return 0;&#125; 乘法123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;int A[300],B[300];int ans[300];int main()&#123; memset(A,0,sizeof(A)); memset(B,0,sizeof(B)); memset(ans,0,sizeof(ans)); string a,b; cin&gt;&gt;a&gt;&gt;b; int len1 = a.length(),len2 = b.length(); for(int i =0;i&lt;len1;++i) A[len1-i] = a[i]-'0'; for(int i = 0;i&lt;len2;++i) B[len2-i] = b[i]-'0'; for(int i =1;i&lt;=len2;++i) &#123; int x = 0; for(int j =1;j&lt;=len1;++j) &#123; ans[i+j-1] = ans[i+j-1]+A[j]*B[i]+x; x = ans[i+j-1]/10; ans[i+j-1]%=10; &#125; ans[i+len1] = x; &#125; int len = len1+len2; while((ans[len]==0)&amp;&amp;(len&gt;1)) &#123; len--; &#125; for(int i = len;i&gt;0;--i) cout&lt;&lt;ans[i]; cout&lt;&lt;endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>High_precision</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DSU_Exercise]]></title>
    <url>%2FAngelNI.github.io%2FDSU-Problem%2F</url>
    <content type="text"><![CDATA[dbq。 Template1234567891011121314151617181920212223242526//非路径压缩int find_1(int x)&#123; int r = x; while(pre[r]!=r) &#123; r = pre[r]; &#125; return r;&#125;//路径压缩int find(int x)&#123; if(pre[x]==x) return x; else &#123; return pre[x] = find(pre[x]); &#125;&#125;void join(int x,int y)&#123; int fx = find(x),fy = find(y); if(x!=fy) pre[fx] = fy;&#125; ExerciseHDU1213裸题 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long ll;const int N = 1010;int pre[N];int n,m;//非路径压缩int find_1(int x)&#123; int r = x; while(pre[r]!=r) &#123; r = pre[r]; &#125; return r;&#125;//路径压缩int find(int x)&#123; if(pre[x]==x) return x; else &#123; return pre[x] = find(pre[x]); &#125;&#125;void join(int x,int y)&#123; int fx = find(x),fy = find(y); if(x!=fy) pre[fx] = fy;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; for(int i =1;i&lt;=n;++i) pre[i] = i; for(int i=1;i&lt;=m;++i) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; join(x,y); &#125; int ans = 0; for(int i =1;i&lt;=n;++i) if(pre[i]==i) ans++; cout&lt;&lt;ans&lt;&lt;endl; &#125; system("pause"); return 0;&#125; HDU1232裸题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll N = 1010;ll pre[N];ll n,m;ll find(ll x)&#123; if(pre[x]==x) return x; else &#123; return pre[x] = find(pre[x]); &#125; &#125;void join(ll x,ll y)&#123; ll fx = find(x),fy = find(y); if(x!=fy) pre[fx] = fy;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n!=0) &#123; for(int i =1;i&lt;=n;++i) pre[i]=i; for(int i =1;i&lt;=m;++i) &#123; ll x,y; cin&gt;&gt;x&gt;&gt;y; join(x,y); &#125; ll ans = 0; for(int i =1;i&lt;=n;++i) &#123; if(pre[i]==i) ans++; &#125; cout&lt;&lt;(ans-1)&lt;&lt;endl; &#125; system("pause"); return 0;&#125; HDU1272并查集的应用，用并查集判断是否存在环,判断连通图。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long ll;const int N = 100010;int vis[N];//判断结点是否都被访问int pre[N];int n,m;int t;//判断是否是连通图//非路径压缩int find_1(int x)&#123; int r = x; while(pre[r]!=r) &#123; r = pre[r]; &#125; return r;&#125;//路径压缩int find(int x)&#123; if(pre[x]!=x) &#123; pre[x] = find(pre[x]); &#125; return pre[x];&#125;void join(int x,int y)&#123; x = find(x),y = find(y); if(x==y) t = 1; else pre[x] = y;&#125;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m) &#123; int num = 0; t = 0; for(int i =1;i&lt;N;++i) pre[i] = i,vis[i] = 0; if(n==-1&amp;&amp;m==-1) break; if(n==0&amp;&amp;m==0) &#123; puts("Yes"); continue; &#125; while(n) &#123; if(t==0) join(n,m),vis[n] = vis[m] = 1; cin&gt;&gt;n&gt;&gt;m; &#125; for(int i =1;i&lt;N;++i) &#123; if(vis[i]&amp;&amp;pre[i]==i) num++; &#125; if(num==1&amp;&amp;t==0) puts("Yes"); else &#123; puts("No"); &#125; &#125; system("pause"); return 0;&#125; HDU1325判断一棵树，不能有回路，每个顶点入度为零。 我真是服了，一直TE，贴上大佬的代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;cstring&gt;#define N 100001int father[N],mark[N],flag,edges;int find(int x)&#123; if(x==father[x]) return x; else return father[x] = find(father[x]);&#125; void Union(int x,int y)&#123; int a=find(x); int b=find(y); if(a==b) &#123; flag=1; return; &#125; mark[a]=1; mark[b]=1; edges++; father[b]=a;&#125;int main()&#123; int a,b,c,d,i,m,cas=1; while(1) &#123; scanf("%d%d",&amp;a,&amp;b); if(a&lt;0&amp;&amp;b&lt;0)break; if(a==0&amp;&amp;b==0) &#123; printf("Case %d is a tree.\n",cas++); continue; &#125; flag=edges=m=0; memset(mark,0,sizeof(mark)); for(i=1;i&lt;=N;i++) father[i]=i; Union(a,b); while(scanf("%d%d",&amp;c,&amp;d)!=EOF) &#123; if(c==0&amp;&amp;d==0) break; if(c==d||father[d]!=d) flag=1; //注意这里，不能指向自身，只能有一个父亲。 Union(c,d); &#125; if(flag) &#123;printf("Case %d is not a tree.\n",cas++);continue;&#125; for(i=1;i&lt;=N;i++) &#123; if(mark[i]) m++; &#125; if(m==edges+1) &#123; printf("Case %d is a tree.\n",cas++); &#125; else printf("Case %d is not a tree.\n",cas++); &#125; return 0;&#125;]]></content>
      <tags>
        <tag>DSU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[尺取法]]></title>
    <url>%2FAngelNI.github.io%2Fruler-method%2F</url>
    <content type="text"><![CDATA[换换思路。休息一下。 尺取法尺取法：顾名思义，像尺子一样取一段，借用挑战书上面的话说，尺取法通常是对数组保存一对下标，即所选取的区间的左右端点，然后根据实际情况不断地推进区间左右端点以得出答案。尺取法比直接暴力枚举区间效率高很多，尤其是数据量大的时候，所以说尺取法是一种高效的枚举区间的方法，是一种技巧，一般用于求取有一定限制的区间个数或最短的区间等等。当然任何技巧都存在其不足的地方，有些情况下尺取法不可行，无法得出正确答案，所以要先判断是否可以使用尺取法再进行计算。 Nowcode第一次写尺取法的代码，也是第一次接触。 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3fll n,k; int main()&#123; cin&gt;&gt;n&gt;&gt;k; string s; cin&gt;&gt;s; int l,r,ans; ans = INF; int a[100]=&#123;0&#125;; l = r = 0; while(r&lt;s.size()) &#123; a[s[r]-'a']++; while(a[s[r]-'a']&gt;=k) &#123; ans = min(ans,r-l+1); a[s[l]-'a']-=1; l++; &#125; r++; &#125; if(ans==INF) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0; &#125; Poj3061题意：给定一个序列，使得其和大于或等于S，求最短的子序列长度。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;const ll INF = 0x3f3f3f3f;ll n,m;ll a[100010];int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m; memset(a,0,sizeof(a)); for(int i =1;i&lt;=n;++i) cin&gt;&gt;a[i]; ll l,r; l = 1; r = 0; ll sum = 0; ll ans = INF; while(1) &#123; while(r&lt;=n&amp;&amp;sum&lt;m) sum+=a[++r]; if(sum&lt;m) break; ans = min(ans,r-l+1); sum-=a[l++]; &#125; if(ans==INF) ans = 0; cout&lt;&lt;ans&lt;&lt;endl; &#125; system("pause"); return 0;&#125; Poj3320题意：一本书有p页，每一页有一个知识点，知识点可能会重复，求最少连续页数覆盖所有知识点。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;algorithm&gt;#include &lt;map&gt;using namespace std;typedef long long LL;const int N = 1000005;int a[N];map&lt;int,int&gt; mp;int main()&#123; int n; while(scanf("%d",&amp;n)!=EOF)&#123; mp.clear(); int m=0; for(int i=1;i&lt;=n;i++)&#123; scanf("%d",&amp;a[i]); if(mp[a[i]]==0) m++; mp[a[i]]=1; &#125; mp.clear(); int l=1,r=1,cnt=0,ans=n+1; while(l&lt;=n)&#123; while(r&lt;=n&amp;&amp;cnt&lt;m)&#123; if(mp[a[r]]==0) cnt++; mp[a[r]]++; r++; &#125; if(cnt&lt;m) break; if(cnt==m) ans = min(ans,r-l); mp[a[l]]--; if(mp[a[l]]==0) cnt--; l++; &#125; printf("%d\n",ans); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>ruler_method</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数位DP]]></title>
    <url>%2FAngelNI.github.io%2FDigit-DP%2F</url>
    <content type="text"><![CDATA[感觉我快不行了,DP有点消化不良 数位DP数位，就是我们所说的个位，十位，百位等等这些，数位DP，在给定区间内，给你一堆限制，求解的个数。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849typedef long long ll;int a[20];ll dp[20][state];//不同题目状态不同ll dfs(int pos,/*state变量*/,bool lead/*前导零*/,bool limit/*数位上界变量*/)//不是每个题都要判断前导零&#123; //递归边界，既然是按位枚举，最低位是0，那么pos==-1说明这个数我枚举完了 if(pos==-1) return 1;/*这里一般返回1，表示你枚举的这个数是合法的，那么这里就需要你在枚举时必须每一位都要满足题目条件，也就是说当前枚举到pos位，一定要保证前面已经枚举的数位是合法的。不过具体题目不同或者写法不同的话不一定要返回1 */ //第二个就是记忆化(在此前可能不同题目还能有一些剪枝) if(!limit &amp;&amp; !lead &amp;&amp; dp[pos][state]!=-1) return dp[pos][state]; /*常规写法都是在没有限制的条件记忆化，这里与下面记录状态是对应，具体为什么是有条件的记忆化后面会讲*/ int up=limit?a[pos]:9;//根据limit判断枚举的上界up; ll ans=0; //开始计数 for(int i=0;i&lt;=up;i++)//枚举，然后把不同情况的个数加到ans就可以了 &#123; if() ... else if()... ans+=dfs(pos-1,/*状态转移*/,lead &amp;&amp; i==0,limit &amp;&amp; i==a[pos]) //最后两个变量传参都是这样写的 /*这里还算比较灵活，不过做几个题就觉得这里也是套路了 大概就是说，我当前数位枚举的数是i，然后根据题目的约束条件分类讨论 去计算不同情况下的个数，还有要根据state变量来保证i的合法性，比如题目 要求数位上不能有62连续出现,那么就是state就是要保存前一位pre,然后分类， 前一位如果是6那么这意味就不能是2，这里一定要保存枚举的这个数是合法*/ &#125; //计算完，记录状态 if(!limit &amp;&amp; !lead) dp[pos][state]=ans; /*这里对应上面的记忆化，在一定条件下时记录，保证一致性，当然如果约束条件不需要考虑lead，这里就是lead就完全不用考虑了*/ return ans;&#125;ll solve(ll x)&#123; int pos=0; while(x)//把数位都分解出来 &#123; a[pos++]=x%10;//个人老是喜欢编号为[0,pos),看不惯的就按自己习惯来，反正注意数位边界就行 x/=10; &#125; return dfs(pos-1/*从最高位开始枚举*/,/*一系列状态 */,true,true);//刚开始最高位都是有限制并且有前导零的，显然比最高位还要高的一位视为0嘛&#125;int main()&#123; ll le,ri; while(~scanf("%lld%lld",&amp;le,&amp;ri)) &#123; //初始化dp数组为-1,这里还有更加优美的优化,后面讲 printf("%lld\n",solve(ri)-solve(le-1)); &#125;&#125; 先来一道据说的模板题理解一下。 HDU2089题意：在给定区间内求不含62和4的数的个数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int dp[20][2];ll a[20];ll dfs(ll pos,ll pre,ll sta,bool limit)&#123; if(pos==0) return 1; if(!limit&amp;&amp;dp[pos][sta]!=-1) return dp[pos][sta]; int up = limit ? a[pos]:9; ll res = 0; for(int i =0;i&lt;=up;++i) &#123; if(pre==6&amp;&amp;i==2) continue; if(i==4) continue; res+=dfs(pos-1,i,i==6, limit&amp;&amp;i == a[pos]); &#125; if(!limit) dp[pos][sta] = res; return res;&#125;ll solve(ll num)&#123; int pos = 0; while(num) &#123; a[++pos] = num%10; //a[pos++] = num%10; num/=10; &#125; //return dfs(pos-1,-1,0,true); return dfs(pos,-1,0,true);&#125;int main()&#123; int n,m; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n+m) &#123; memset(dp,-1,sizeof(dp)); ll ans = solve(m) - solve(n-1); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 51nod1009都说这是入门题。 题意：求1到n中，用多少个1。 数据范围很大，暴力枚举肯定TE。 在这里就用到了数位DP。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;int dp[20];int a[20];int b[20];ll n;void init()&#123; b[1] = 1; for(int i=2 ;i&lt;=11;++i) b[i] = b[i-1]*10; &#125;ll dfs(int pos,int num,bool limit)&#123; if(pos == 0) return num;//访问结束,返回num计数。 //记忆化搜索。 if(!limit&amp;&amp;dp[pos]!=-1) return num*b[pos+1] + dp[pos]; //只搜索比当前数小的数字。 int up = limit ? a[pos] : 9; ll res = 0;//记录数量 for(int i =0;i&lt;=up;++i) &#123; if(i==1) res+=dfs(pos-1,num+1,limit&amp;&amp;i==a[pos]); else &#123; res+=dfs(pos-1,num,limit&amp;&amp;i==a[pos]); &#125; &#125; if(!limit) dp[pos] = res; return res;&#125;ll solve(ll x)&#123; int pos = 0; while(n) &#123; a[++pos] = n%10; n/=10; &#125; return dfs(pos,0,true);&#125;int main()&#123; init(); cin&gt;&gt;n; memset(dp,-1,sizeof(dp)); cout&lt;&lt;solve(n)&lt;&lt;endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Digit DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Section DP]]></title>
    <url>%2FAngelNI.github.io%2FSectionDP%2F</url>
    <content type="text"><![CDATA[世界上的人都变成废柴，这个世界就没有废柴了 区间DP区间dp就是在区间上进行动态规划，求解一段区间上的最优解。主要是通过合并小区间的 最优解进而得出整个大区间上最优解的dp算法。 既然求解在一个区间上的最优解，那么把这个区间分割成一个个小区间，求解每个小区间的最优解，再合并小区间得到大区间即可。所以在代码实现上，我可以枚举区间长度len为每次分割成的小区间长度（由短到长不断合并），内层枚举该长度下可以的起点，自然终点也就明了了。然后在这个起点终点之间枚举分割点，求解这段小区间在某个分割点下的最优解。 123456789memset(dp,0,sizeof(dp))//初始dp数组for(int len=2;len&lt;=n;len++)&#123;//枚举区间长度 for(int i=1;i&lt;n;++i)&#123;//枚举区间的起点 int j=i+len-1;//根据起点和长度得出终点 if(j&gt;n) break;//符合条件的终点 for(int k=i;k&lt;=j;++k)//枚举最优分割点 dp[i][j]=min(dp[i][j],dp[i][k]+dp[k+1][j]+w[i][j]);//状态转移方程 &#125;&#125; 优化 12345678910111213141516for(int len=2;len&lt;=n;len++)&#123; for(int i = 1;i&lt;=n;i++) &#123; int j = i+len-1; if(j&gt;n) break; for(int k = s[i][j-1];k&lt;=s[i+1][j];k++) &#123; if(dp[i][j]&gt;dp[i][k]+dp[k+1][j]+w[i][j]) &#123; dp[i][j]=dp[i][k]+dp[k+1][j]+w[i][j]; s[i][j]=k; &#125; &#125; &#125;&#125; Practice石子合并1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include &lt;numeric&gt;using namespace std;#define INF 0x3f3f3f3fint a[400],b[400];int dp[400][400];int main()&#123; int n ; cin&gt;&gt;n; memset(b,0,sizeof(b)); for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; //前缀和 //b[i] = b[i-1] +a[i]; &#125; //前缀和 partial_sum(a+1,a+1+n,b+1); for(int len = 2 ;len&lt;=n;++len)//枚举长度 &#123; for(int i=1;i+len-1&lt;=n;++i)//枚举起点 &#123; int l = i,r = len+i-1; dp[l][r] = INF; for(int k = l;k&lt;r;++k) &#123; dp[l][r] = min(dp[l][r],dp[l][k]+dp[k+1][r]+b[r]-b[l-1]); //区间[l,r]的代价 = min(当前状态,区间[l,k]的代价 + 区间[k+1,r]的代价 + [l,r]的代价和) &#125; &#125; &#125; cout&lt;&lt;dp[1][n]&lt;&lt;endl; system("pause"); return 0;&#125; HDU42831234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int a[110],b[110];int dp[110][110];int main()&#123; int t; cin&gt;&gt;t; for(int num=1;num&lt;=t;++num ) &#123; int n; cin&gt;&gt;n; b[0] = 0; memset(dp,0,sizeof(dp)); for(int i= 1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; b[i] = a[i]+b[i-1]; &#125; for(int len=2;len&lt;=n;++len) &#123; for(int i =1;i+len-1&lt;=n;++i) &#123; int l = i, r = len+i-1; dp[l][r] = 1e9; for(int k=l;k&lt;=r;++k) dp[l][r] = min(dp[l][r],dp[l+1][k]+dp[k+1][r]+(k-l+1)*(b[r]-b[k])+a[i]*(k-i)); &#125; &#125; //cout&lt;&lt;dp[1][n]&lt;&lt;endl; printf("Case #%d: %d\n",num,dp[1][n]); &#125; return 0;&#125; POJ2955括号最长匹配长度。 1234567891011121314151617181920212223242526272829303132333435363738394041/*用dp[l][r]表示区间[l,r]里最大完全匹配数。只要得到了dp[l][r]，那么就可以得到dp[i-1][j+1] dp[i-1][j+1]=dp[i][j]+(s[i-1]==s[j+1]？2:0).*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;ll dp[110][110];char s[110];int main()&#123; while(cin&gt;&gt;s+1) &#123; if(s[1] == 'e') break; memset(dp,0,sizeof(dp)); ll len = strlen(s+1); for(int lenn = 1;lenn&lt;=len;++lenn)//枚举长度 &#123; for(int i =1;i+lenn-1&lt;=len;++i)//枚举端点 &#123; int l = i,r = i+lenn-1; //如果知道了区间[l,r]的个数，那么很容易求出dp[l+1][r-1]的个数 if((s[l]=='('&amp;&amp;s[r]==')') || (s[l]=='['&amp;&amp;s[r]==']')) dp[l][r] = dp[l+1][r-1] + 2; //枚举分界点 for(int k = l;k&lt;r;++k) dp[l][r] = max(dp[l][r],dp[l][k]+dp[k+1][r]); &#125; &#125; cout&lt;&lt;dp[1][len]&lt;&lt;endl; &#125; return 0;&#125; 整数划分1234567题意：给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积思路：这里给的乘号是有限个，所以状态方程里必须包含使用乘号的个数，此外还要包含区间长度。所以怎么用二维dp实现包含m和n，我们可以用dp[i][j]表示在第1~i个字符里插入j个乘号的最大值。状态转移方程 dp[i][j]表示在第1~i个字符里插入j个乘号的最大值；用num[i][j]表示第i~j个字符表示的数字；dp[i][j] = max(dp[i][j],dp[k][j-1]*num[k+1][i]) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/*题意：给出两个整数 n , m ,要求在 n 中加入m - 1 个乘号，将n分成m段，求出这m段的最大乘积思路：这里给的乘号是有限个，所以状态方程里必须包含使用乘号的个数，此外还要包含区间长度。所以怎么用二维dp实现包含m和n，我们可以用dp[i][j]表示在第1~i个字符里插入j个乘号的最大值。状态转移方程 dp[i][j]表示在第1~i个字符里插入j个乘号的最大值；用num[i][j]表示第i~j个字符表示的数字；dp[i][j] = max(dp[i][j],dp[k][j-1]*num[k+1][i])*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;ll m;char s[110];ll dp[110][110];ll num[110][110];int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0,sizeof(dp)); memset(num,0,sizeof(num)); cin&gt;&gt;s+1; cin&gt;&gt;m; int len = strlen(s+1); for(int i =1;i&lt;=len;++i) &#123; for(int j =i;j&lt;=len;++j) &#123; num[i][j] = num[i][j-1]*10+(s[j]-'0'); &#125; &#125; for(int i=1;i&lt;=len;++i) dp[i][0] = num[1][i]; for(int j =1;j&lt;m;++j)//插入第j个* &#123; for(int i = 1;i&lt;=len;++i) &#123; for(int k =1;k&lt;i;++k) &#123; dp[i][j] = max(dp[i][j],dp[k][j-1]*num[k+1][i]); &#125; &#125; &#125; cout&lt;&lt;dp[len][m-1]&lt;&lt;endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Section DP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCS + Problem]]></title>
    <url>%2FAngelNI.github.io%2FLCS-Problem%2F</url>
    <content type="text"><![CDATA[longest comment subsequence 最长公共子序列（LCM）参考博客 最长公共子序列，。其定义是，一个序列 S ，如果分别是两个或多个已知序列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。 （1）字符子串：指的是字符串中连续的n个字符，如abcdefg中，ab，cde，fg等都属于它的字串。 （2）字符子序列：指的是字符串中不一定连续但先后顺序一致的n个字符，即可以去掉字符串中的部分字符，但不可改变其前后顺序。如abcdefg中，acdg，bdf属于它的子序列，而bac，dbfg则不是，因为它们与字符串的字符顺序不一致。 (3) 公共子序列：如果序列C既是序列A的子序列，同时也是序列B的子序列，则称它为序列A和序列B的公共子序列。如对序列 1,3,5,4,2,6,8,7和序列 1,4,8,6,7,5 来说，序列1,8,7是它们的一个公共子序列。 那么现在，我们再通俗的总结一下最长公共子序列（LCS）：就是A和B的公共子序列中长度最长的（包含元素最多的） 我们用Ax表示序列A的连续前x项构成的子序列，即Ax= a1,a2,……ax, By= b1,b2,……by, 我们用LCS(x, y)表示它们的最长公共子序列长度，那原问题等价于求LCS(m,n)。为了方便我们用L(x, y)表示Ax和By的一个最长公共子序列。让我们来看看如何求LCS(x, y)。我们令x表示子序列考虑最后一项 （1） Ax ＝ By 那么它们L(Ax, By)的最后一项一定是这个元素！ 为什么呢？为了方便，我们令t = Ax = By, 我们用反证法：假设L(x,y)最后一项不是t，则要么L(x,y)为空序列（别忘了这个），要么L(x,y)的最后一项是Aa＝Bb ≠ t, 且显然有a &lt; x, b &lt; y。无论是哪种情况我们都可以把t接到这个L(x,y)后面,从而得到一个更长的公共子序列。矛盾！ 如果我们从序列Ax中删掉最后一项ax得到Ax-1,从序列By中也删掉最后一项by得到By-1，(多说一句角标为0时，认为子序列是空序列)，则我们从L(x,y)也删掉最后一项t得到的序列是L(x – 1, y - 1)。为什么呢？和上面的道理相同，如果得到的序列不是L(x - 1, y - 1)，则它一定比L(x - 1, y - 1)短（注意L（，）是个集合！），那么它后面接上元素t得到的子序列L(x,y)也比L(x - 1, y - 1)接上元素t得到的子序列短，这与L(x, y)是最长公共子序列矛盾。因此L(x, y) = L(x - 1, y - 1) 最后接上元素t，LCS(Ax, By) = LCS(x - 1, y - 1) + 1。 （2） Ax ≠ By ​ 仍然设t = L(Ax, By), 或者L(Ax, By)是空序列（这时t是未定义值不等于任何值）。则t ≠ Ax和t ≠ By至少有一个成立，因为t不能同时等于两个不同的值嘛！ （2.1）如果t ≠ Ax，则有L(x, y)= L(x - 1, y)，因为根本没Ax的事嘛。 ​ LCS(x,y) = LCS(x – 1, y) （2.2）如果t ≠ By,l类似L(x, y)= L(x , y - 1) ​ LCS(x,y) = LCS(x, y – 1) 可是，我们事先并不知道t，由定义，我们取最大的一个，因此这种情况下,有LCS(x,y) = max(LCS(x – 1, y) , LCS(x, y – 1))。看看目前我们已经得到了什么结论： 123LCS(x,y) = (1) LCS(x - 1,y - 1) + 1 （Ax ＝ By）(2) max(LCS(x – 1, y) , LCS(x, y – 1)) （Ax ≠ By） 这时一个显然的递推式，光有递推可不行，初值是什么呢？显然，一个空序列和任何序列的最长公共子序列都是空序列！所以我们有: 1234LCS(x,y) = (1) LCS(x - 1,y - 1) + 1 如果Ax ＝ By(2) max(LCS(x – 1, y) , LCS(x, y – 1)) 如果Ax ≠ By(3) 0 如果x = 0或者y = 0 练习1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;int m,n;char a[1010];char b[1010];int dp[1010][1010];int main()&#123; cin&gt;&gt;n&gt;&gt;m; scanf("%s",a+1); scanf("%s",b+1); for(int i =1;i&lt;=n;++i) &#123; for(int j=1 ;j&lt;=m;++j) &#123; if(a[i]==b[j]) dp[i][j] = dp[i-1][j-1] + 1; else if(dp[i-1][j]&gt;dp[i][j-1]) dp[i][j] = dp[i-1][j]; else &#123; dp[i][j] = dp[i][j-1]; &#125; &#125; &#125; cout&lt;&lt;dp[n][m]&lt;&lt;endl; system("pause"); return 0;&#125; HDU1159板子题 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;char a[1010],b[1010];int dp[1001][1001];int main()&#123; while(~scanf("%s",a)) &#123; scanf("%s",b); memset(dp,0,sizeof(dp)); int len1 = strlen(a); int len2 = strlen(b); for(int i =0;i&lt;len1;++i) &#123; for(int j =0;j&lt;len2;++j) &#123; if(a[i]==b[j]) dp[i+1][j+1] = dp[i][j] + 1; // else if(dp[i][j+1]&gt;dp[i+1][j]) // dp[i+1][j+1] = dp[i][j+1]; else &#123; dp[i+1][j+1] = max(dp[i+1][j],dp[i][j+1]); //dp[i+1][j+1] = dp[i+1][j]; &#125; &#125; &#125; cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; //cout&lt;&lt;len1&lt;&lt;endl; //cout&lt;&lt;len2&lt;&lt;endl; &#125; return 0;&#125; 51Nod1006求的是最长公共子串是什么。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;char a[1010],b[1010];int dp[1010][1010];int main()&#123; while(~scanf("%s",a+1)) &#123; scanf("%s",b+1); int len1 = strlen(a+1); int len2 = strlen(b+1); string s; for(int i =1;i&lt;=len1;++i) &#123; for(int j =1;j&lt;=len2;++j) &#123; if(a[i]==b[j]) dp[i][j] = dp[i-1][j-1] +1; else &#123; dp[i][j] = max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; int i = len1,j= len2; while(i&gt;=1&amp;&amp;j&gt;=1) &#123; if(a[i] == b[j]) &#123; s+=a[i]; i--;j--; &#125; else if(dp[i-1][j]&gt;dp[i][j-1]) i--; else &#123; j--; &#125; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl; s.clear(); // cout&lt;&lt;len1&lt;&lt;endl; &#125; return 0;&#125; HDU1503将两个字符串结合起来，他们的公共子串只输出一次 在LCS的基础之上加上路径记录，生成dp数组的时候做上标记，之后按顺序输出结果字符串。注意还要考虑一下没有公共子序列的情况。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring &gt;#include&lt;string&gt;using namespace std;int dp[110][110];char a[110],b[110];int main()&#123; while(~scanf("%s",a+1)) &#123; scanf("%s",b+1); int len1 = strlen(a+1); int len2 = strlen(b+1); memset(dp,0,sizeof(dp)); for(int i =1;i&lt;=len1;++i) &#123; for(int j=1;j&lt;=len2;++j) &#123; if(a[i]==b[j]) &#123; dp[i][j] = dp[i-1][j-1] +1; &#125; else if(dp[i-1][j]&gt;dp[i][j-1]) &#123; dp[i][j] = dp[i-1][j]; &#125; else &#123; dp[i][j] = dp[i][j-1]; &#125; &#125; &#125; //cout&lt;&lt;dp[len1][len2]&lt;&lt;endl; string s; int i =len1,j=len2; while(i&gt;=1&amp;&amp;j&gt;=1) &#123; if(a[i] == b[j]) &#123; s+=a[i]; i--,j--; &#125; else if(dp[i-1][j]&gt;dp[i][j-1]) &#123; s+=a[i]; i--; &#125; else &#123; s+=b[j]; j--; &#125; &#125; while(i!=0) &#123; s+=a[i]; i--; &#125; while(j!=0) &#123; s+=b[j]; j--; &#125; reverse(s.begin(),s.end()); cout&lt;&lt;s&lt;&lt;endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LCS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LIS + Problem]]></title>
    <url>%2FAngelNI.github.io%2FLIS-Problem%2F</url>
    <content type="text"><![CDATA[淡泊明志，宁静致远 最长上升子序列（LIS）让我们举个例子：求 2 7 1 5 6 4 3 8 9 的最长上升子序列。我们定义d(i) (i∈[1,n])来表示前i个数以A[i]结尾的最长上升子序列长度。 参考的博客 12345678910111213141516171819前1个数 d[1]=1 子序列为2； 前2个数 7前面有2小于7 d[2]=d[1]+1=2 子序列为2 7 前3个数 在1前面没有比1更小的，1自身组成长度为1的子序列 d[3]=1 子序列为1 前4个数 5前面有2小于5 d[4]=d[1]+1=2 子序列为2 5 前5个数 6前面有2 5小于6 d[5]=d[4]+1=3 子序列为2 5 6 前6个数 4前面有2小于4 d[6]=d[1]+1=2 子序列为2 4 前7个数 3前面有2小于3 d[3]=d[1]+1=2 子序列为2 3 前8个数 8前面有2 5 6小于8 d[8]=d[5]+1=4 子序列为2 5 6 8 前9个数 9前面有2 5 6 8小于9 d[9]=d[8]+1=5 子序列为2 5 6 8 9 d[i]=max&#123;d[1],d[2],……,d[i]&#125; 我们可以看出这9个数的LIS为d(9)=5 把上面的运算过程手算一遍，加深对状态转移的理解，代码就好写多了。 练习题1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 1010;int a[N],dp[N];int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],dp[i] = 1; dp[0] = 1; for(int i=1;i&lt;=n;++i) &#123; for(int j =1;j&lt;i;++j) &#123; if(a[j]&lt;a[i]) &#123; //当前状态与把a[j]加入序列的状态的长度比较，取最大值。 dp[i] = max(dp[i],dp[j]+1); &#125; &#125; &#125; int ans = -0x3f3f3f3f ; for(int i =1;i&lt;=n;++i) ans = max(ans,dp[i]); cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0;&#125;//时间复杂度O(n^),可以优化到o(nlogn) 贪心+二分优化123456789101112131415161718192021我们再举一个例子：有以下序列A[ ] = 3 1 2 6 4 5 10 7，求LIS长度。 我们定义一个B[ i ]来储存可能的排序序列，len 为LIS长度。我们依次把A[ i ]有序地放进B[ i ]里。 （为了方便，i的范围就从1~n表示第i个数） A[1] = 3，把3放进B[1]，此时B[1] = 3，此时len = 1，最小末尾是3 A[2] = 1，因为1比3小，所以可以把B[1]中的3替换为1，此时B[1] = 1，此时len = 1，最小末尾是1 A[3] = 2，2大于1，就把2放进B[2] = 2，此时B[ ]=&#123;1,2&#125;，len = 2 同理，A[4]=6，把6放进B[3] = 6，B[ ]=&#123;1,2,6&#125;，len = 3 A[5]=4，4在2和6之间，比6小，可以把B[3]替换为4，B[ ] = &#123;1,2,4&#125;，len = 3 A[6] = 5，B[4] = 5，B[ ] = &#123;1,2,4,5&#125;，len = 4 A[7] = 10，B[5] = 10，B[ ] = &#123;1,2,4,5,10&#125;，len = 5 A[8] = 7，7在5和10之间，比10小，可以把B[5]替换为7，B[ ] = &#123;1,2,4,5,7&#125;，len = 5 但在这种情况下，所得到的的序列不一定是最长上升子序列，所以最后得到的B[ ] 序列不一定是正确的结果，但是最可能性，在这里判断插入的位置，用二分搜索。 优化代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int INF = 0x3f3f3f3f;const int N = 1010;int a[N],low[N];int bin_search(int R,int x)&#123; int l = 1,r=R; while(l&lt;=r) &#123; int mid = (l+r)&gt;&gt;1; if(low[mid]&lt;x) l = mid+1; else &#123; r = mid-1; &#125; &#125; return l;&#125;int main()&#123; int n; cin&gt;&gt;n; for(int i=1;i&lt;=n;++i) cin&gt;&gt;a[i],low[i] = INF; low[1] = a[1]; int ans = 1; for(int i=2;i&lt;=n;++i) &#123; if(a[i]&gt;low[ans]) low[++ans] = a[i]; else &#123; low[bin_search(ans,a[i])] = a[i]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0;&#125; PracticeHDU1087LIS的裸题，不过求得是最长上升子序列的和。 123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int n;int a[N],dp[N];int main()&#123; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; memset(dp,0,sizeof(0)); for(int i =1;i&lt;=n;++i) cin&gt;&gt;a[i],dp[i] = a[i]; for(int i =2;i&lt;=n;++i)//从第2开始 &#123; for(int j =1;j&lt;i;++j) &#123; if(a[j]&lt;a[i]) dp[i] = max(dp[i],dp[j]+a[i]); &#125; &#125; int ans = dp[1]; for(int i =1;i&lt;=n;++i) &#123; ans = max(ans,dp[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; system("pause"); return 0;&#125; HDU1257真正的裸题 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;const int N = 3030;int a[N];int dp[N];int main()&#123; int n; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; dp[i] = 1; &#125; for(int i =1;i&lt;=n;++i) &#123; for(int j=1;j&lt;i;++j) &#123; if(a[j]&lt;a[i]) dp[i] = max(dp[i],dp[j]+1); &#125; &#125; int ans = -1; for(int i =1;i&lt;=n;++i) ans = max(ans,dp[i]); cout&lt;&lt;ans&lt;&lt;endl; &#125; system("pause"); return 0;&#125; HDU1950题意简单，求最长上升子序列的长度，但用原来的板子会超时。贪心+二分的策略。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std ;const int N = 40010;int a[N],dp[N],low[N];int n;int bin_search(int R,int x)&#123; int l =1,r = R; while(l&lt;=r) &#123; int mid = (l+r)&gt;&gt;1; if(low[mid]&lt;x) l = mid+1; else &#123; r = mid-1; &#125; &#125; return l;&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n; for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; //low[i] = 0x3f3f3f3f; &#125; int ans = 1; low[1] = a[1]; for(int i =2;i&lt;=n;++i) &#123; if(a[i]&gt;low[ans]) low[++ans] = a[i]; else &#123; low[bin_search(ans,a[i])] = a[i]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>LIS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python简单爬取视频]]></title>
    <url>%2FAngelNI.github.io%2Fcrawler-viode%2F</url>
    <content type="text"><![CDATA[傻瓜式操作？？ 网站上的电影视频是由若干个子视频组成，无缝隙播放每个子视频，也就是我们看的电影。 我们可以看一下 视频是由若干个这样的.ts 文件组成，右边是对应的每个ts文件的链接地址。 可以先下一个ts文件，试一下。 123456789101112131415import requestsdef download(): url = "https://youku.cdn7-okzy.com/20200210/17096_f384ee94/1000k/hls/bd1e64cee30000000.ts" path = r'F:\C-and-Python-Algorithn\python\interest\video\ ' title = url[-20:] header = &#123;'User-Agent':'Mozilla/5.0'&#125; response = requests.get(url,headers= header) with open(path+title,'wb') as f: f.write(response.content)if __name__ == "__main__": download(); print("Sussessfully") 但是有一个问题，如何下载整个视频呢？ 这个也很容易。 12345678https://youku.cdn7-okzy.com/20200210/17096_f384ee94/1000k/hls/bd1e64cee30000001.tshttps://youku.cdn7-okzy.com/20200210/17096_f384ee94/1000k/hls/bd1e64cee30000002.tshttps://youku.cdn7-okzy.com/20200210/17096_f384ee94/1000k/hls/bd1e64cee30000003.tshttps://youku.cdn7-okzy.com/20200210/17096_f384ee94/1000k/hls/bd1e64cee30000004.ts 。。。。 。。。 。https://youku.cdn7-okzy.com/20200210/17096_f384ee94/1000k/hls/bd1e64cee30001330.ts 我们可以发现每个ts文件的链接前部分都是一样的，只有末尾不同，并且都是数字。很明显，加个循环就可以了。 从 0 ~ 1330的循环。 1234567891011121314151617181920import requestsdef download(i): ##在这里 url = "https://youku.cdn7-okzy.com/20200210/17096_f384ee94/1000k/hls/bd1e64cee3000%04d.ts"%i ## path = r'F:\C-and-Python-Algorithn\python\interest\video\ ' title = url[-20:] header = &#123;'User-Agent':'Mozilla/5.0'&#125; response = requests.get(url,headers= header) #读写文件 with open(path+title,'wb') as f: f.write(response.content)if __name__ == "__main__": for i in range(1331): download(i) print("Sussessfully") 下载了一系类的子视频。 最后再将子视频合并就可以了。 在下载视屏的文件加下打开终端，输入下面的命令，就会生成合并后的文件。 1copy /b *.ts &#123;name&#125;.mp4]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01Backpack Practice]]></title>
    <url>%2FAngelNI.github.io%2F01Backpack-Practice%2F</url>
    <content type="text"><![CDATA[01010101010101，难受啊。 HDU260201背包裸题 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int dp[N];int weight[N],value[N];int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; //裸题 memset(dp,0,sizeof(dp)); int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;value[i]; &#125; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;weight[i]; &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j =m;j&gt;=weight[i];--j) &#123; dp[j] = max(dp[j],dp[j-weight[i]]+value[i]); &#125; &#125; cout&lt;&lt;dp[m]&lt;&lt;endl; &#125; return 0;&#125; HDU254601背包，涉及贪心，先买最贵的菜，然后就转化为容量为m-5，物品数量n-1的，进行01背包； 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int dp[N],value[N];int n,m;int ans ;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; memset(dp,0,sizeof(dp)); for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;value[i]; &#125; cin&gt;&gt;m; if(m&lt;5) ans = m; else &#123; //贪心，先买最贵的菜。 m-=5; sort(value+1,value+1+n); //背包容量为m-5，物品数量为n-1的01背包问题 for(int i=1;i&lt;=n-1;++i) &#123; for(int j =m;j&gt;=value[i];j--) &#123; dp[j] =max(dp[j],dp[j-value[i]]+value[i]); &#125; &#125; ans = m+5 - dp[m]-value[n]; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; //system("pause"); return 0;&#125; HDU2955题意：抢匪抢劫银行j的金额是Mj，被抓的概率是Pj。当被抓概率小于P时，认为抢匪是可以逃脱的。那么问题来了，在可逃脱的情况下，抢匪最多能抢多少钱。 读完题，题意就是01背包。但这个是01背包的变形。 需要转化，将银行的总价值当做背包的容量，不被抓的概率为当做价值， 1状态方程为：dp[ j ] = max(dp[j], dp[j-w[i]]*(1-p[i])) 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 10010;double dp[N];double p[N];int w[N];int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; memset(dp,0,sizeof(dp)); int n,sum=0; double m;//概率大于m会被抓 cin&gt;&gt;m&gt;&gt;n; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;w[i]&gt;&gt;p[i];//输入每个银行钱数和抢劫他的概率 sum+=w[i];//所有银行的钱数当做背包的容量，不被抓的概率当做价值 &#125; dp[0] = 1.0; for(int i=1;i&lt;=n;++i) &#123; for(int j =sum;j&gt;=w[i];--j) &#123; dp[j] = max(dp[j],dp[j-w[i]]*(1-p[i])); //不抢劫第i个银行，钱数减少w[i],并且逃走的概率增大。 &#125; &#125; for(int i = sum;i&gt;=0;i--) &#123; if(dp[i]&gt;=1-m)//逃走的概率大于1-m &#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; &#125; system("pause"); return 0;&#125; HDU1203这道题与上一道题类似。 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 10010;double dp[N];int n,m;int v[N];double p[N];int main()&#123; while(cin&gt;&gt;m&gt;&gt;n&amp;&amp;m+n) &#123; for(int i =0;i&lt;=m;++i) dp[i] = 1; int sum = 0; for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;v[i]&gt;&gt;p[i]; &#125; for(int i =1;i&lt;=n;++i) &#123; for(int j = m; j &gt;= v[i] ; --j ) &#123; dp[j] = min(dp[j],dp[j-v[i]]*(1-p[i]));//拿不到offer的最小值 &#125; &#125; printf("%.1f%%\n",(1-dp[m])*100); &#125; system("pause"); return 0;&#125;]]></content>
      <tags>
        <tag>01Backpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Backpack problem]]></title>
    <url>%2FAngelNI.github.io%2FBackpack-problem%2F</url>
    <content type="text"><![CDATA[背包四讲。 1、01背包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/*一共有n件物品，背包容量为m，每件物品有体积weight 和value，求背包可以装的最大价值。01背包是最简单的背包问题，每件物品只有选与不选两种情况：dp[i][j] :表示选第i件物品时重量为j的最大价值。1.不选第i件物品dp[i][j] = dp[i-1][j]2.选第i件物品的最大值（背包容量足够）dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i])*/#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int dp[N][N],weight[N],value[N];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;weight[i]&gt;&gt;value[i]; &#125; for(int i =1;i&lt;=n;++i) &#123; for(int j =0;j&lt;=m;++j) &#123; dp[i][j] = dp[i-1][j]; if(j&gt;=weight[i]) &#123; dp[i][j] = max(dp[i-1][j],dp[i-1][j-weight[i]] + value[i]); &#125; &#125; &#125; /* 一维优化 int dp[N]; for(int i=1;i&lt;=n;++i) &#123; for(int j =m;j&gt;=weight[i];--j) &#123; dp[j] = max(dp[j],dp[j-weight[i]] + value[i]); &#125; &#125; ans = dp[m]; */ int ans = dp[n][m]; cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0;&#125;// 练习1 HDU2602 HDU2546,HDU2955,HDU1203,HDU1171,HDU2639,// 练习2 https://www.acwing.com/problem/content/2/ 2、完全背包1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/*完全背包与01背包的区别是每件物品有无限个，每件物品可以去N件；for(int i =1;i&lt;=n;++i)&#123; for(int j =m;j&gt;=weight[i];--j) &#123; for(int k =0;k*weight[i]&lt;=j;++k) &#123; dp[j] = max(dp[j],dp[j-k*weight[i]]+k*value[i]); &#125; &#125;&#125;优化之后变为：for(int i =1;i&lt;=n;++i)&#123; for(int j =weight[i];j&lt;=m;++j) &#123; dp[j] = max(dp[j],dp[j-weight[i]] + value[i]); &#125;&#125;*/#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int dp[N],weight[N],value[N];int main()&#123; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;weight[i]&gt;&gt;value[i]; &#125; for(int i =1;i&lt;=n;++i) &#123; for(int j =weight[i];j&lt;=m;++m) &#123; dp[j] = max(dp[j],dp[j-weight[i]]+value[i]); &#125; &#125; int ans = dp[m]; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125;//练习https://www.acwing.com/problem/content/3/// 3、多重背包1234567891011121314151617181920212223242526272829303132333435/*多重背包与上述背包的区别是，每件物品只有有限个，拿取的数量有限。*/#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int n,m;int dp[N];int w[N],v[N],s[N];int main()&#123; cin&gt;&gt;n&gt;&gt;m; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;w[i]&gt;&gt;v[i]&gt;&gt;s[i]; &#125; for(int i=1;i&lt;=n;++i) &#123; for(int j = m ;j&gt;=0;--j) &#123; for(int k= 1;k&lt;=s[i]&amp;&amp;k*w[i]&lt;=j;++k) &#123; dp[j] = max(dp[j],dp[j-k*w[i]]+ k*v[i] ) ; &#125; &#125; &#125; int ans = dp[m]; cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0;&#125;// 练习 https://www.acwing.com/problem/content/4/ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//二进制优化/*多重背包与上述背包的区别是，每件物品只有有限个，拿取的数量有限。*/#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;const int N = 2200;int n,m;int dp[N];int w[N],v[N],s[N];struct good&#123; int w,v;&#125;;int main()&#123; cin&gt;&gt;n&gt;&gt;m; vector&lt;good&gt; goods; for(int i=1;i&lt;=n;++i) &#123; int w,v,s; cin&gt;&gt;w&gt;&gt;v&gt;&gt;s; for(int k=1;k&lt;=s;k*=2) &#123; s-=k; goods.push_back(&#123;w*k,v*k&#125;); &#125; if(s&gt;0) goods.push_back(&#123;w*s,v*s&#125;); &#125; for(auto it = goods.begin();it!=goods.end();++it) &#123; for(int j = m ;j&gt;=it-&gt;w;--j) &#123; dp[j] = max(dp[j],dp[j-it-&gt;w]+ it-&gt;v ) ; &#125; &#125; int ans = dp[m]; cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0;&#125;// 练习 https://www.acwing.com/problem/content/4/ 4、混合背包123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/*混合背包是每件物品分为三类:1.只有拿与不拿两种状态2.有无数件3.件数有限制混合背包问题分组解决子问题*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;#include&lt;vector&gt;using namespace std;const int N = 1010;struct Thing&#123; int kind; int w,v;&#125; ;int dp[N];int main()&#123; vector&lt;Thing &gt; thing; int n,m; cin&gt;&gt;n&gt;&gt;m; for(int i =1;i&lt;=n;++i) &#123; int v,w,s; cin&gt;&gt;w&gt;&gt;v&gt;&gt;s; if(s&lt;0) thing.push_back(&#123;-1,w,v&#125;); else if(s==0) thing.push_back(&#123;0,w,v&#125;); else &#123; for(int k=1;k&lt;=s;k*=2) &#123; s-=k; thing.push_back(&#123;-1,w*k,v*k&#125;); &#125; if(s&gt;0) thing.push_back(&#123;-1,s*w,s*v&#125;); &#125; &#125; for(auto it = thing.begin();it!=thing.end();++it) &#123; if(it-&gt;kind &lt; 0) &#123; for(int j=m;j&gt;=it-&gt;w;j--) &#123; dp[j] = max(dp[j],dp[j-it-&gt;w]+it-&gt;v); &#125; &#125; else &#123; for(int j =it-&gt;w;j&lt;=m;++j) &#123; dp[j] = max(dp[j],dp[j-it-&gt;w]+it-&gt;v); &#125; &#125; &#125; cout&lt;&lt;dp[m]&lt;&lt;endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Backpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[winter camp 2]]></title>
    <url>%2FAngelNI.github.io%2Fwinter-camp-2%2F</url>
    <content type="text"><![CDATA[穿越了千万个时间线里人海里相依 A做游戏签到题，贪心就可以 123456789101112131415#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll a,b,c;ll x,y,z;int main()&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; cout&lt;&lt;(min(a,y)+min(b,z)+min(c,x))&lt;&lt;endl; system("pause"); return 0;&#125; B排数字数学问题，关键在于6和1的数量，616161616161，1616161616，这样是616子串出现最多的情形。 1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;typedef long long ll;string s;ll n;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;s; ll num1=0,num2=0; for(int i=0;i&lt;n;++i) &#123; if(s[i]=='6') num1++; if(s[i]=='1') num2++; &#125; cout&lt;&lt;min(num1-1,num2)&lt;&lt;endl; s.clear(); system("pause"); return 0;&#125; D数三角暴力求解就行，在这里用到数学中的如何判断一个钝角三角形，我用的是向量 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;typedef long long ll;pair&lt;ll,ll&gt; p[510];ll n;int judge(pair&lt;ll,ll&gt; x,pair&lt;ll,ll&gt; y,pair&lt;ll,ll&gt; z)&#123; if(((y.first-x.first)*(z.first-x.first)+(y.second-x.second)*(z.second-x.second))&lt;0&amp;&amp;((y.second-x.second)*(z.first-x.first)!=(z.second-x.second)*(y.first-x.first))) return 1; else &#123; return 0; &#125; &#125;int main()&#123; cin&gt;&gt;n; ll num = 0; for(int i =0;i&lt;n;++i) cin&gt;&gt;p[i].first&gt;&gt;p[i].second; for(ll i=0;i&lt;n;++i) for(ll j=i+1;j&lt;n;++j) for(ll k =j+1;k&lt;n;++k) &#123; if(judge(p[i],p[j],p[k])||judge(p[j],p[i],p[k])||judge(p[k],p[i],p[j])) num++; &#125; cout&lt;&lt;num&lt;&lt;endl; system("pause"); return 0;&#125; E做计数数学问题，将式子两侧平方，就会发现 i*j 一定是平方数，数平方数的个数就行 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll n;int main()&#123; ll num = 0; cin&gt;&gt;n; ll i,j,k; for( i=1;i&lt;=sqrt(n);i++) &#123; k = i*i; for(j =1;j&lt;=sqrt(k);++j) &#123; if(i==j) num++; else if(k%j==0) num+=2; &#125; &#125; cout&lt;&lt;num&lt;&lt;endl; system("pause"); return 0;&#125; G判正误板子，快速幂 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll a,b,c,d,e,f,g;ll sum;const ll mod = 1145141919;int t; ll quick(ll a ,ll b)&#123; ll res = 1; //a %=mod; while(b) &#123; if(b&amp;1) res = res * a % mod; a = a*a%mod; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d&gt;&gt;e&gt;&gt;f&gt;&gt;g; ll sum1 = quick(a,d); ll sum2 = quick(b,e); ll sum3 = quick(c,f); sum = (sum1+sum2+sum3);//%mod; if(sum == g) cout&lt;&lt;"Yes"&lt;&lt;endl;//puts("Yes"); else &#123; cout&lt;&lt;"No"&lt;&lt;endl;//puts("No"); &#125; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Winter Camp 1]]></title>
    <url>%2FAngelNI.github.io%2Fwinter-camp-1%2F</url>
    <content type="text"><![CDATA[《Z的悲剧》 A honoka和格点三角形123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const ll mod = 1000000007;ll n,m;int main()&#123; cin&gt;&gt;n&gt;&gt;m; ll a = (m-1)%mod*m%mod*(n-2)%mod*2%mod; ll b = (m-2)%mod*m%mod*(n-1)%mod*2%mod; ll c = (n-1)%mod*n%mod*(m-2)%mod*2%mod; ll d = (n-2)%mod*n%mod*(m-1)%mod*2%mod; //ll re1 = (m-2)%mod*(n-1)%mod*4%mod; //ll re2 = (n-2)%mod*(m-1)%mod*4%mod; //ll re = (re1+re2)%mod; ll sum = (a+b+c+d)%mod; //sum = (sum-re)%mod; cout&lt;&lt;sum&lt;&lt;endl; //cout&lt;&lt;(a%mod+b%mod+c%mod+d%mod-re1%mod-re2%mod)%mod&lt;&lt;endl; system("pause"); return 0;&#125; B kotori和bangdream签到题 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long ll;int main()&#123; //ios::sync_with_stdio(false); //cin.tie(NULL); //cout.tie(NULL); double n,x,a,b; cin&gt;&gt;n&gt;&gt;x&gt;&gt;a&gt;&gt;b; double ans = a*x/100.0+b-b*x/100.0; ans = ans * n; printf("%.2f\n",ans); system("pause"); return 0; &#125; D hanayo和米饭签到题 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;using namespace std;typedef long long ll;ll n;ll a[100001];int main()&#123; ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); cin&gt;&gt;n; //memset(a,0,sizeof(a)); for(ll i = 1;i&lt;n;++i) &#123; int x; cin&gt;&gt;x; a[x]++; &#125; ll flag ; for(ll i=1;i&lt;=n;++i) &#123; if(a[i]==0) &#123; flag = i; break; &#125; &#125; cout&lt;&lt;flag&lt;&lt;endl; //system("pause"); return 0; &#125; E rin和快速迭代暴力求解就可以，在这里用到约束个数定理 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;using namespace std;typedef long long ll;ll n;ll count(ll n)&#123; ll s = 1; for(ll i =2;i*i &lt;= n;++i) &#123; if(n%i==0) &#123; ll a = 0; while(n%i==0) &#123; n = n/i; a++; &#125; s = s*(a+1); &#125; &#125; if(n&gt;1) s = s * 2; return s;&#125;int main()&#123; cin&gt;&gt;n; ll num = 1; while(count(n)!=2) &#123; n = count(n); num++; &#125; cout&lt;&lt;num&lt;&lt;endl; system("pause"); return 0;&#125; G eli和字符串这道题可以用尺取法来解决 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;#define INF 0x3f3f3f3fll n,k;int main()&#123; cin&gt;&gt;n&gt;&gt;k; string s; cin&gt;&gt;s; int l,r,ans; ans = INF; int a[100]=&#123;0&#125;; l = r = 0; while(r&lt;s.size()) &#123; a[s[r]-'a']++; while(a[s[r]-'a']&gt;=k) &#123; ans = min(ans,r-l+1); a[s[l]-'a']-=1; l++; &#125; r++; &#125; if(ans==INF) cout&lt;&lt;-1&lt;&lt;endl; else cout&lt;&lt;ans&lt;&lt;endl; system("pause"); return 0;&#125; H nozomi和字符串用到二分+前端和，check()部分不算是太明白，贴上代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;bits/stdc++.h&gt;typedef long long ll;using namespace std;int a[200009];int n,k;bool check(int x)&#123; for(int i=x;i&lt;=n;i++) &#123; int ans = a[i]-a[i-x];//求零的数量也就是操作次数 if(ans&lt;=k||x-ans&lt;=k)//如果0的数量比K小，那就在区间的右侧； return 1; &#125; return 0;//否则在区间左侧 &#125;int main()&#123; cin &gt;&gt; n &gt;&gt; k; string s; cin&gt;&gt;s; a[1] = s[0]-'0'; /*前缀和*/ for(int i=1;i&lt;n;++i) &#123; a[i+1]=a[i]+s[i]-'0'; //cout&lt;&lt;a[i]&lt;&lt;endl; &#125; /*二分*/ int l = 1,r = n,mid; while(l&lt;=r) &#123; mid = (l+r)&gt;&gt;1; if(check(mid)) &#123; if(!check(mid+1)) break; l = mid+1; &#125; else r = mid-1; &#125; cout &lt;&lt; mid &lt;&lt;endl; system("pause"); return 0;&#125; 最后总结，菜是罪恶的源泉。]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python制作中国疫情地图]]></title>
    <url>%2FAngelNI.github.io%2F2019-nCov%2F</url>
    <content type="text"><![CDATA[快开学了啊 pyhton制作中国地图根据百度中国新型冠状肺炎疫情数据绘制（数据更新至 2020.02.01 21:21），通过python编写程序生成地图，再通过对HTML文件代码重改编写完成。 1234567891011from pyecharts import Map import numpy as npvalue = np.array([7153, 599, 535, 422, 389, 297, 286, 247, 207, 206, 202, 169, 156, 144, 101, 100, 96, 91, 80, 63, 62, 47, 38, 35, 29, 26, 23, 18, 17, 13,10,9,7,1])attr = ["湖北","浙江","广东","河南","湖南","安徽","江西","重庆","四川","山东","江苏","上海","北京","福建","陕西","广西","河北","云南","黑龙江","辽宁","海南","山西","天津","甘肃","贵州","宁夏","内蒙古","新疆","吉林","香港","台湾","青海","澳门","西藏"]print(len(value))print(len(attr))map = Map("截至 2020-2-1 数据统计", width=1000, height=800)map.add("",attr,value,is_map_symbol_show=True,maptype="china", is_visualmap=True, visual_text_color='#404a59', ##ffffff#000#404a59 is_label_show=True, visual_range=[np.min(value),599])map.render(r'e:\\2020-2-1.html')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>2019_nCov</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[冬日]]></title>
    <url>%2FAngelNI.github.io%2Fwinter-scenery%2F</url>
    <content type="text"><![CDATA[冬日。感谢美丽的摄影师（ORZ）]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Scenery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PY文件打包成EXE]]></title>
    <url>%2FAngelNI.github.io%2Fpy-pkg%2F</url>
    <content type="text"><![CDATA[奔向远方 前言py文件打包成exe，就是说将Python程序打包成应用程序，不在只是几十行代码了，是一个可以运行的小应用了。 就拿我之前写的python爬虫文件，打包后就可以当做应用程序运行了。 pyinstaller使用 PyInstaller 将 Python 程序生成可直接运行的程序，这个程序就可以被分发到对应的 Windows 或 Mac OS X 平台上运行。 安装 1pip install pyinstaller 使用pyinstaller打包py文件成exe程序 12345678910要打包的py文件所在目录执行pyinstaller -F ant.py常用参数说明：–icon=图标路径-F 打包成一个exe文件-w 使用窗口，无控制台-c 使用控制台，无窗口-D 创建一个目录，里面包含exe以及其他一些依赖性文件pyinstaller -h 来查看参数 生成这两个文件 dist文件夹下，就是生成的应用程序 pyinstaller 改变生成exe程序的图标 1pyinstaller -F --icon=my.ico test.py my.ico 是一个图标名，和当前的test.py文件在同一个目录下]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>pyinstaller</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵分解ML-latest-small]]></title>
    <url>%2FAngelNI.github.io%2FTF-MF%2F</url>
    <content type="text"><![CDATA[你的努力将成就更好的自己。 矩阵分解并作出推荐123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#字符编码！！！#-*- Coding: utf-8 -*-import pandas as pdimport numpy as npimport tensorflow as tfdef data_process(): ratings = pd.read_csv("F:\\ml-latest-small\\ratings.csv") movies = pd.read_csv("F:\\ml-latest-small\\movies.csv") movies['movieRow'] = movies.index movies = movies[['movieRow','movieId','title']] movies.to_csv("F:\\ml-latest-small\\moviesProcessed.csv",index = False,header = True,encoding = 'utf-8') print(movies.tail()) ratings = pd.merge(ratings,movies,on = 'movieId') ratings = ratings[['userId','movieRow','rating']] ratings.to_csv('F:\\ml-latest-small\\ratingsProcessed.csv', index=False, header=True, encoding='utf-8') print(ratings.head()) return ratings,movies#构建矩阵def build_matrix(ratings): user_no = ratings['userId'].max()+1 movies_no = ratings['movieRow'].max()+1 rate = np.zeros((movies_no,user_no)) print(rate.shape) flag = 0 ratings_length = np.shape(ratings)[0] print(np.shape(ratings)) for index, row in ratings.iterrows(): rate[int(row['movieRow']),int(row['userId'])] = row['rating'] flag+1 record = rate &gt; 0 record = np.array(record,dtype= int) print(record) return rate,record,user_no,movies_no#构建模型def normalizeRatings(rate,record): m,n = rate.shape rating_mean = np.zeros((m,1)) rating_norm = np.zeros((m,n)) for i in range(m): idx = (record[i,:]!=0) rating_mean[i] = np.mean(rate[i,idx]) rating_norm[i,idx] = rate[i,idx] - rating_mean[i] return rating_norm,rating_meandef build_model(rate,record,movies_no,user_no): rating_norm,rating_mean = normalizeRatings(rate,record) rating_mean = np.nan_to_num(rating_mean) num_features = 12 x = tf.Variable(tf.random_normal([movies_no,num_features],stddev= 0.35)) theta = tf.Variable(tf.random_normal([user_no,num_features],stddev=0.35)) loss = 1/2 * tf.reduce_sum(((tf.matmul(x, theta, transpose_b=True) - rating_norm) * record) ** 2) + \ 0.5*(1/2 * (tf.reduce_sum(x ** 2) + tf.reduce_sum(theta ** 2))) train = tf.train.AdamOptimizer(1e-3).minimize(loss) return x,theta,train,loss,rating_mean#训练模型def Train(loss): tf.summary.scalar('train_loss',loss) summaryMerged = tf.summary.merge_all() filename = "F:\\ml-latest-small\\movie_tensorborad.csv" writer = tf.summary.FileWriter(filename) return summaryMerged,writer def recommend(movies): user_id = input(u'您要想哪位用户进行推荐？请输入用户编号：') sortedResult = predicts[:, int(user_id)].argsort()[::-1] # argsort()函数返回的是数组值从小到大的索引值; argsort()[::-1] 返回的是数组值从大到小的索引值 print(u'为该用户推荐的评分最高的20部电影是：'.center(80, '=')) # center() 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串。默认填充字符为空格。 idx = 0 for i in sortedResult: print(u'评分: %.2f, 电影名: %s' % (predicts[i, int(user_id)]-2, movies.iloc[i]['title'])) idx += 1 if idx == 20: break#评估模型if __name__ == "__main__": ratings,movies = data_process() rate,record,user_no,movies_no =build_matrix(ratings) x,theta,train,loss,rating_mean = build_model(rate,record,movies_no,user_no) summaryMerged,writer = Train(loss) init = tf.global_variables_initializer() with tf.Session() as sess: sess.run(init) for i in range(2000): _,movie_summary = sess.run([train,summaryMerged]) writer.add_summary(movie_summary,i) current_x,current_theta = sess.run([x,theta]) predicts = np.dot(current_x,current_theta.T) + rating_mean error = np.sqrt(np.sum(((predicts - rate)*record)**2)) print(u'模型评估errors：', error) recommend(movies) 结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445 movieRow movieId title9737 9737 193581 Black Butler: Book of the Atlantic (2017)9738 9738 193583 No Game No Life: Zero (2017)9739 9739 193585 Flint (2017)9740 9740 193587 Bungo Stray Dogs: Dead Apple (2018)9741 9741 193609 Andrew Dice Clay: Dice Rules (1991) userId movieRow rating0 1 0 4.01 5 0 4.02 7 0 4.53 15 0 2.54 17 0 4.5(9742, 611)(100836, 3)[[0 1 0 ... 1 1 1] [0 0 0 ... 1 0 0] [0 1 0 ... 1 0 0] ... [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0] [0 0 0 ... 0 0 0]]模型评估errors： 151.9801784601805您要想哪位用户进行推荐？请输入用户编号：1==============================为该用户推荐的评分最高的20部电影是：===============================评分: 5.39, 电影名: Now You See Me (2013)评分: 4.43, 电影名: Postman, The (Postino, Il) (1994)评分: 4.40, 电影名: My Neighbor Totoro (Tonari no Totoro) (1988)评分: 4.35, 电影名: Color Purple, The (1985)评分: 4.23, 电影名: The Revenant (2015)评分: 4.21, 电影名: Smoke (1995)评分: 4.19, 电影名: Big Sleep, The (1946)评分: 4.19, 电影名: Drugstore Cowboy (1989)评分: 4.16, 电影名: Whale Rider (2002)评分: 4.12, 电影名: Gandhi (1982)评分: 4.10, 电影名: Murder in the First (1995)评分: 4.10, 电影名: Lone Star (1996)评分: 4.03, 电影名: Lifeboat (1944)评分: 4.00, 电影名: Planes, Trains &amp; Automobiles (1987)评分: 3.99, 电影名: Moonstruck (1987)评分: 3.93, 电影名: Remains of the Day, The (1993)评分: 3.91, 电影名: To Kill a Mockingbird (1962)评分: 3.90, 电影名: Crash (1996)评分: 3.89, 电影名: Grave of the Fireflies (Hotaru no haka) (1988)评分: 3.88, 电影名: Wallace &amp; Gromit: The Best of Aardman Animation (1996)]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>MF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单爬取网站图片]]></title>
    <url>%2FAngelNI.github.io%2FCrawler%2F</url>
    <content type="text"><![CDATA[涉世浅，点染亦浅；历事深，机械亦深。故君子与其练达，不若朴鲁；与其曲谨，不若疏狂。 pyhton爬取图片1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-import requests #调用第三方库import re #正则import urllib.request#print(requests.get(url))def rree(url): wb_date = requests.get(url).text #获取当前网页的Html,返回Unicode格式 #返回的是一个包含服务器资源的Response对象。包含从服务器返回的所有的相关资源。 res = re.compile(r'src="(http.+?jpg)"') #正则表达式匹配图片 reg = re.findall(res,wb_date) #print(wb_date) return regdef download(reg,path): num=0 path = path for i in reg: #遍历 print(i) a = requests.get(i) #f =open('%s.jpg'%nun,'wb') f =open(path+'%s.jpg'%num,'wb') f.write(a.content)#requests.get(url).content 返回bytes格式 f.close() num=num+1 print('第%s个图片下载完毕'%num)if __name__ =="__main__": #网站链接 url = input("Please input the correct url: ") #储存位置 path = "F:/C-and-Python-Algorithn/python/interest/image/ " reg = rree(url) download(reg,path) requests.get(url).text1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;script src="/js/src/click.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="//libs.baidu.com/jquery/1.8.3/jquery.min.js"&gt;&lt;/script&gt;&lt;html lang="en"&gt;&lt;head&gt;&lt;meta name="generator" content="Hexo 3.9.0"&gt; &lt;meta charset="utf-8"&gt;&lt;title&gt;AngelNI&amp;#39;s Blog&lt;/title&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt;&lt;meta name="google-site-verification" content="JwzmnANXlpmQlhwaSORuqpEB6P3Sr-tRhw4R_XDRcEc"&gt;&lt;meta name="baidu-site-verification" content="ztPAF2oDcw"&gt; &lt;meta name="description" content="This is a simple record of learning bits and pieces, so that each step of learning into an unforgettable memory."&gt; &lt;meta name="keywords" content="learning note"&gt;&lt;meta property="og:type" content="website"&gt;&lt;meta property="og:title" content="AngelNI&amp;#39;s Blog"&gt;&lt;meta property="og:url" content="https://angelni.github.io/index.html"&gt; ...... re.compile(r’src=”(http.+?jpg)”‘)12&lt;!--图片格式--&gt;&lt;img class="thumbnail" src="https://s2.ax1x.com/2020/01/29/1QPiUf.jpg" alt="冬日" title="" style=""&gt; 拿我的博客举栗]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一个爬虫小程序]]></title>
    <url>%2FAngelNI.github.io%2Ffirst-crawl%2F</url>
    <content type="text"><![CDATA[小岛加油！武汉加油！（小岛仍保持着0记录） 第一个爬虫程序利用之前编写的简单爬虫的py文件，再利用 pyinstaller（第三方库） 将python打包成exe，通过tkinter（第三方库），实现程序窗口化，通过对窗口内容编辑设置，读入输入，通过button 进行所需要的功能。 下图是我的爬虫程序 百度网盘链接 提取码：c1hm]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>crawler</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 图片转字符串]]></title>
    <url>%2FAngelNI.github.io%2Fstr-image%2F</url>
    <content type="text"><![CDATA[鲸可落 python 图片转字符串1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -- coding=utf-8 --from PIL import Imageimport argparse#命令行输入参数处理parser = argparse.ArgumentParser()parser.add_argument('--file') #输入文件parser.add_argument('-o', '--output') #输出文件parser.add_argument('--width', type = int, default = 80) #输出字符画宽parser.add_argument('--height', type = int, default = 80) #输出字符画高#超参数设定args = parser.parse_args()IMG = "E:\\1.jpg"WIDTH = 57HEIGHT = 41OUTPUT = "E:\\1.txt"#字符序列ascii_char = list("$@B%8&amp;WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\|()1&#123;&#125;[]?-_+~&lt;&gt;i!lI;:,\"^`'. ")# 将256灰度映射到70个字符上def get_char(r,g,b,alpha = 256): if alpha == 0: return ' ' length = len(ascii_char) gray = int(0.2126 * r + 0.7152 * g + 0.0722 * b) unit = (256.0 + 1)/length return ascii_char[int(gray/unit)]if __name__ == '__main__': #读取图片 im = Image.open(IMG) #resize im = im.resize((WIDTH,HEIGHT), Image.NEAREST) txt = "" for i in range(HEIGHT): for j in range(WIDTH): txt += get_char(*im.getpixel((j,i))) txt += '\n' #打印 print(txt) #字符画输出到文件 if OUTPUT: with open(OUTPUT,'w') as f: f.write(txt) else: with open("output.txt",'w') as f: f.write(txt) 下面附一张效果图]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>str_image</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2FAngelNI.github.io%2Fre%2F</url>
    <content type="text"><![CDATA[达人物外之物，思身后之身，宁受一时之寂寞，毋取万古之凄凉。 正则式正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。re 模块使 Python 语言拥有全部的正则表达式功能。 re.matchre.match 尝试从字符串的起始位置匹配一个模式，如果不是起始位置匹配成功的话，match()就返回none。 1234567print(re.match('www','www.angelni.io').span())#起始位置匹配print(re.match('www','www.angelni.io'))#非起始位置匹配'''结果(0, 3)&lt;_sre.SRE_Match object; span=(0, 3), match='www'&gt;''' re.searchre.search 扫描整个字符串并返回第一个成功的匹配。 1234567print(re.search('www','www.angelni.io').span())#起始位置匹配print(re.search('io','www.angelni.io').span())'''(0, 3)(12, 14)''' re.subre 模块提供了用于替换字符串中的匹配项。 123456789101112phone = "183-3918-9296 # 这是我的电话号码"# 删除字符串中的 Python注释num = re.sub(r'#.*$', "", phone) # r 代表正则表达式,将在后面介绍具体规则print("电话号码是：", num)# 删除非数字(-)的字符串 num = re.sub(r'\D', "", phone)print("电话号码是：", num)'''电话号码是： 183-3918-9296电话号码是： 18339189296''' re.compilecompile 函数用于编译正则表达式，生成一个正则表达式（ Pattern ）对象。 1234567891011partten1 = re.compile(r'\d+')partten2 = re.compile(r'\d')result1 = partten1.findall('runoob123google456')result2 = partten2.findall('runoob123google456')print(result1)print(result2)'''['123', '456']['1', '2', '3', '4', '5', '6']''' re.splitsplit 方法按照能够匹配的子串将字符串分割后返回列表 1234print(re.split('\W+', 'runoob, runoob, runoob.'))'''['runoob23', 'runoob23', 'runoob121', '']''' re.findall返回字符串中所有不重叠匹配项的列表。如果模式中存在一个或多个捕获组，则返回组列表； 12345678910re.findall(pattern, string, flags=0)#两种用法pattern = re.compile(r'\d+')pattern.findall('one1two2three3four4')#[1,2,3,4] #注意此处findall()的用法，可传两个参数;pattern = re.compile(r'\d+')re.findall(pattern,"one123")#[1,2,3]]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>RE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的简单操作]]></title>
    <url>%2FAngelNI.github.io%2FBiTree-Op%2F</url>
    <content type="text"><![CDATA[爱就像蓝天白云，晴空万里，突然暴风雨…… BiTree Operation1.先序创建二叉树1234567891011121314151617BiTree Creat_Bitree()&#123; char ch; cin&gt;&gt;ch; BiTree T = new BiNode; if(ch =='#') &#123; T = NULL; &#125; else &#123; T-&gt;data = ch; T-&gt;lchild = Creat_Bitree(); T-&gt;rchild = Creat_Bitree(); &#125; return T;&#125; 2.二叉树的深度1234567891011121314151617/*计算二叉树的深度*/int Depth(BiTree T)&#123; //递归算法 if(T==NULL) return 0; else &#123; int m = Depth(T-&gt;lchild);//左子树深度 int n = Depth(T-&gt;rchild);//右子树深度 if(m&gt;n) return (m+1); else return (n+1); &#125; &#125; 3.二叉树的节点数12345678910int NodeCount(BiTree T)&#123; if(T==NULL)//结点为空 return 0; else &#123; //左子树结点+右子树结点+当前结点 return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1; &#125;&#125; 4.二叉树的叶子节点数123456789101112131415int leaf_num(BiTree T)&#123; if(T == NULL) &#123; return 0; &#125; else if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL) &#123; return 1; &#125; else &#123; return leaf_num(T-&gt;lchild)+leaf_num(T-&gt;rchild); &#125;&#125; 5.复制二叉树12345678910111213141516BiTree Copy_Tree(BiTree T)&#123; BiTree newT; if(T==NULL) &#123; return NULL; &#125; else &#123; newT = new BiNode; newT-&gt;data = T-&gt;data; newT-&gt;lchild = Copy_Tree(T-&gt;lchild); newT-&gt;rchild = Copy_Tree(T-&gt;rchild); &#125; return newT;&#125; 6.镜像二叉树123456789101112131415void swap_BiNode(BiTree T)&#123; //根据先序的思想对二叉树进行左右子树交换 BiTree t = NULL; if(T) &#123; t = T-&gt;lchild; T-&gt;lchild = T-&gt;rchild; T-&gt;rchild = t; swap_BiNode(T-&gt;lchild); swap_BiNode(T-&gt;rchild); &#125; else return ;&#125; 7.判断两棵二叉树是否相等12345678910111213141516171819/*判断两棵二叉树是否相等*/int Judge_Tree(BiTree T1,BiTree T2)&#123; //左右子树相等 if(!T1&amp;&amp;!T2)//都为空 &#123; return 1; &#125; if(!T1||!T2)//其中一个为空 &#123; return 0; &#125; if(T1-&gt;data == T2-&gt;data)//数据相等 &#123; return Judge_Tree(T1-&gt;lchild,T2-&gt;lchild) &amp;&amp; Judge_Tree(T1-&gt;rchild,T2-&gt;rchild); &#125; else return 0;&#125; 8.判断是否为完全二叉树12345678910111213141516171819202122232425/*判断二叉树是否为完全二叉树*/int is_CBiTree(BiTree T)&#123; if(T == NULL) &#123; return 0; &#125; queue&lt;BiTree&gt; q; int flag = 0; q.push(T); while(!q.empty()) &#123; BiTree p = q.front(); q.pop(); if((flag&amp;&amp;(p-&gt;lchild!=NULL||p-&gt;rchild!=NULL))||(p-&gt;lchild==NULL&amp;&amp;p-&gt;rchild!=NULL)) return 0; if(p-&gt;lchild!=NULL) q.push(p-&gt;lchild); if(p-&gt;rchild!=NULL) q.push(p-&gt;rchild); if((p-&gt;lchild!=NULL&amp;&amp;p-&gt;rchild==NULL)||(p-&gt;lchild==NULL&amp;&amp;p-&gt;rchild==NULL)) flag = 1; &#125; return 1;&#125; 9.总体代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdlib&gt;#include&lt;queue&gt;#include&lt;stack&gt;using namespace std;typedef struct node&#123; char data; struct node *lchild,*rchild;&#125;BiNode,*BiTree;/*先序创建二叉树*/BiTree Creat_Bitree()&#123; char ch; cin&gt;&gt;ch; BiTree T = new BiNode; if(ch =='#') &#123; T = NULL; &#125; else &#123; T-&gt;data = ch; T-&gt;lchild = Creat_Bitree(); T-&gt;rchild = Creat_Bitree(); &#125; return T;&#125;/*复制二叉树*/BiTree Copy_Tree(BiTree T)&#123; BiTree newT; if(T==NULL) &#123; return NULL; &#125; else &#123; newT = new BiNode; newT-&gt;data = T-&gt;data; newT-&gt;lchild = Copy_Tree(T-&gt;lchild); newT-&gt;rchild = Copy_Tree(T-&gt;rchild); &#125; return newT;&#125;/*计算二叉树的深度*/int Depth(BiTree T)&#123; if(T==NULL) return 0; else &#123; int m = Depth(T-&gt;lchild); int n = Depth(T-&gt;rchild); if(m&gt;n) return (m+1); else return (n+1); &#125; &#125;/*统计节点数*/int NodeCount(BiTree T)&#123; if(T==NULL) return 0; else &#123; return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1; &#125;&#125;/*交换二叉树结点的左右孩子*/void swap_BiNode(BiTree T)&#123; //根据先序的思想对二叉树进行左右子树交换 BiTree t = NULL; if(T) &#123; t = T-&gt;lchild; T-&gt;lchild = T-&gt;rchild; T-&gt;rchild = t; swap_BiNode(T-&gt;lchild); swap_BiNode(T-&gt;rchild); &#125; else return ; &#125;/*判断两棵二叉树是否相等*/int Judge_Tree(BiTree T1,BiTree T2)&#123; //左右子树相等或者左右子树互换相等 if(!T1&amp;&amp;!T2) &#123; return 1; &#125; if(!T1||!T2) &#123; return 0; &#125; if(T1-&gt;data == T2-&gt;data) &#123; return Judge_Tree(T1-&gt;lchild,T2-&gt;lchild) &amp;&amp; Judge_Tree(T1-&gt;rchild,T2-&gt;rchild); &#125; else return 0;&#125;/*叶子结点数*/int leaf_num(BiTree T)&#123; if(T == NULL) &#123; return 0; &#125; else if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL) &#123; return 1; &#125; else &#123; return leaf_num(T-&gt;lchild)+leaf_num(T-&gt;rchild); &#125; &#125;/*判断二叉树是否为完全二叉树*/int is_CBiTree(BiTree T)&#123; if(T == NULL) &#123; return 0; &#125; queue&lt;BiTree&gt; q; int flag = 0; q.push(T); while(!q.empty()) &#123; BiTree p = q.front(); q.pop(); if((flag&amp;&amp;(p-&gt;lchild!=NULL||p-&gt;rchild!=NULL))||(p-&gt;lchild==NULL&amp;&amp;p-&gt;rchild!=NULL)) return 0; if(p-&gt;lchild!=NULL) q.push(p-&gt;lchild); if(p-&gt;rchild!=NULL) q.push(p-&gt;rchild); if((p-&gt;lchild!=NULL&amp;&amp;p-&gt;rchild==NULL)||(p-&gt;lchild==NULL&amp;&amp;p-&gt;rchild==NULL)) flag = 1; &#125; return 1;&#125;/*先序遍历*/void pre_travel(BiTree T)&#123; if(T==NULL) return ; printf("%c ",T-&gt;data); pre_travel(T-&gt;lchild); pre_travel(T-&gt;rchild); &#125;//中序遍历void in_travel(BiTree T)&#123; if(T) &#123; in_travel(T-&gt;lchild); cout&lt;&lt;T-&gt;data&lt;&lt;" "; in_travel(T-&gt;rchild); &#125;&#125;//后序遍历void post_travel(BiTree T)&#123; if(T) &#123; post_travel(T-&gt;lchild); post_travel(T-&gt;rchild); cout&lt;&lt;T-&gt;data&lt;&lt;" "; &#125;&#125;int main()&#123; BiTree T1,T2,T3; //先序创建二叉树 T1 = Creat_Bitree(); //深度 cout&lt;&lt;endl; int dep = Depth(T1); cout&lt;&lt;"The depth of the BiTree is "&lt;&lt;dep&lt;&lt;endl; //节点数 int node_num = NodeCount(T1); cout&lt;&lt;"The number of the Node of the BiTree is "&lt;&lt;node_num&lt;&lt;endl; //叶子节点数 int leaf_n = leaf_num(T1); cout&lt;&lt;"The number of leaf Node is "&lt;&lt;leaf_n&lt;&lt;endl&lt;&lt;endl; //复制二叉树 T2 = Copy_Tree(T1); T3 = Copy_Tree(T1); cout&lt;&lt;"The following traversal results are pre-order traversal"&lt;&lt;endl; cout&lt;&lt;"The copying result:"&lt;&lt;endl; cout&lt;&lt;"T1 : ";pre_travel(T1);cout&lt;&lt;endl; cout&lt;&lt;"T2 : ";pre_travel(T2);cout&lt;&lt;endl; cout&lt;&lt;"T3 : ";pre_travel(T3);cout&lt;&lt;endl&lt;&lt;endl; //镜像二叉树 swap_BiNode(T2); cout&lt;&lt;"The swaping result: "&lt;&lt;endl; cout&lt;&lt;"T2 : ";pre_travel(T2);cout&lt;&lt;endl&lt;&lt;endl; //判断是否相等 cout&lt;&lt;endl; cout&lt;&lt;"T1 and T2 are "; if(Judge_Tree(T1,T2)) cout&lt;&lt;"Equal"&lt;&lt;endl; else &#123; cout&lt;&lt;"Different"&lt;&lt;endl; &#125; cout&lt;&lt;"T1 and T3 are "; if(Judge_Tree(T1,T3)) cout&lt;&lt;"Equal"&lt;&lt;endl; else cout&lt;&lt;"Different"&lt;&lt;endl; cout&lt;&lt;endl; //是否为完全二叉树 cout&lt;&lt;"T1 is "; if(is_CBiTree(T1)) cout&lt;&lt;"CBT"&lt;&lt;endl; else cout&lt;&lt;"not CBT"&lt;&lt;endl; cout&lt;&lt;"T2 is "; if(is_CBiTree(T2)) cout&lt;&lt;"CBT"&lt;&lt;endl; else cout&lt;&lt;"not CBT"&lt;&lt;endl; //测试样例A B D H # # # E # # C F # # G # # system("pause"); return 0;&#125; 结果如下]]></content>
      <categories>
        <category>Data-Structure</category>
      </categories>
      <tags>
        <tag>BiTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF-RNN]]></title>
    <url>%2FAngelNI.github.io%2FTF-RNN%2F</url>
    <content type="text"><![CDATA[愿天堂也有亲爱的篮球。 TF-RecurrentNeuralNetwork123456789101112131415161718192021222324252627282930313233343536373839404142434445import tensorflow as tffrom tensorflow.examples.tutorials.mnist import input_dataimport numpy as np#读取数据mnist = input_data.read_data_sets("data/MNIST_data/", one_hot = True)#设置常量n_inputs = 28max_size = 28lstm_size = 100classes = 10batch_size = 50n_batch = mnist.train.num_examples/batch_size#占位符x = tf.placeholder(tf.float32,[None,28*28])y = tf.placeholder(tf.float32,[None,10])#权值weight = tf.Variable(tf.truncated_normal([lstm_size,classes],stddev = 0.1))#偏执bias = tf.Variable(tf.constant(0.1,shape = [classes]))#构建RNNdef RNN(x,weight,bias): inputs = tf.reshape(x,[-1,max_size,n_inputs]) lstm_cell = tf.contrib.rnn.BasicLSTMCell(lstm_size) outputs ,finall_state = tf.nn.dynamic_rnn(lstm_cell,inputs,dtype = tf.float32) result = tf.nn.softmax(tf.matmul(finall_state[1],weight)+bias) return resultprediction = RNN(x,weight,bias)loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits = prediction,labels=y))optimizer = tf.train.AdamOptimizer(1e-4).minimize(loss)correct_pre = tf.equal(tf.argmax(y,1),tf.argmax(prediction,1))accuracy = tf.reduce_mean(tf.cast(correct_pre,tf.float32))init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) for epoch in range(20): for batch in range(int(n_batch)): batch_x,batch_y = mnist.train.next_batch(batch_size) sess.run(optimizer,feed_dict=&#123;x:batch_x,y:batch_y&#125;) acc = sess.run(accuracy,feed_dict=&#123;x:mnist.test.images,y:mnist.test.labels&#125;) print("Iter" + str(epoch)+",Accuracy :"+str(acc)) 结果如下 1234567891011121314151617181920Iter0,Accuracy :0.7592Iter1,Accuracy :0.8672Iter2,Accuracy :0.902Iter3,Accuracy :0.917Iter4,Accuracy :0.9247Iter5,Accuracy :0.9285Iter6,Accuracy :0.9417Iter7,Accuracy :0.943Iter8,Accuracy :0.9463Iter9,Accuracy :0.9452Iter10,Accuracy :0.952Iter11,Accuracy :0.9519Iter12,Accuracy :0.9533Iter13,Accuracy :0.9536Iter14,Accuracy :0.9542Iter15,Accuracy :0.958Iter16,Accuracy :0.9618Iter17,Accuracy :0.9607Iter18,Accuracy :0.9563Iter19,Accuracy :0.9561]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>RNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF-CNN]]></title>
    <url>%2FAngelNI.github.io%2FTF-CNN%2F</url>
    <content type="text"><![CDATA[低头不是认输，是要看清自己的路；仰头不是骄傲，是要看见自己的天空。——科比·布莱恩特 TF-ConvNets卷积神经网络比普通的神经网络多了卷积层，池化层和平滑层，最后一层的激活函数为softmax。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147import tensorflow as tf#手写数字数据集import tensorflow.examples.tutorials.mnist.input_data as input_dataimport numpy as npimport matplotlib.pyplot as plt from time import time import os#屏蔽INFO + WARNING，输出ERROR + FATALos.environ['TF_CPP_MIN_LOG_LEVEL'] = '2''''定义重复使用的函数'''#显示手写图片def show(image): plt.imshow(image.reshape(28,28),cmap='binary') plt.show()def plot_image_label_prediction(images,labels,prediction=[],idx= 0 ,num = 10): fig = plt.gcf() fig.set_size_inches(12,14) if num&gt;25: num = 25 for i in range(num): ax = plt.subplot(5,5,1+i) ax.imshow(np.reshape(images[idx],(28,28)),cmap = "binary") title = "label ="+str(np.argmax(labels[idx])) if len(prediction)&gt;0: title += ", prediction = "+ str(prediction[idx]) ax.set_title(title,fontsize = 10) ax.set_xticks([]) ax.set_yticks([]) idx+=1 plt.show()#定义隐藏层def layter(out_dim,in_dim,inputs,activation = None): w = tf.Variable(tf.random_normal([in_dim,out_dim]))#权值 b = tf.Variable(tf.random_normal([1,out_dim]))#偏执 wbx = tf.matmul(inputs,w)+b#计算 #激活函数 if activation is None: outputs = wbx else: outputs = activation(wbx) return outputs#定义权值变量def weight(shape): return tf.Variable(tf.truncated_normal(shape,stddev = 0.1),name = 'w')#定义偏执变量def bias(shape): return tf.Variable(tf.constant(0.1,shape = shape),name = 'b')#定义卷积层def conv2d(x,w): return tf.nn.conv2d(x,w,strides = [1,1,1,1],padding = 'SAME')#定义最大池化def max_pool_2x2(x): return tf.nn.max_pool(x,ksize = [1,2,2,1],strides = [1,2,2,1],padding = 'SAME')#下载数据集mnist = input_data.read_data_sets("data/MNIST_data/", one_hot = True)#打印第一个标签print("labels[0]: ",mnist.train.labels[0])print("labels[0]: ",np.argmax(mnist.train.labels[0]))#两个卷积层和池化层with tf.name_scope("Input_layter"): x = tf.placeholder("float",[None,28*28],name='x')#占位符 x_image = tf.reshape(x,[-1,28,28,1])with tf.name_scope("C1_Conv"): w1 = weight([5,5,1,16]) b1 = bias([16]) Conv1 = conv2d(x_image,w1) + b1 C1_Conv = tf.nn.relu(Conv1)with tf.name_scope("C1_Pool"): C1_Pool = max_pool_2x2(C1_Conv)with tf.name_scope("C2_Conv"): w2 = weight([5,5,16,36]) b2 = bias([36]) Conv2 = conv2d(C1_Pool,w2)+b2 C2_Conv = tf.nn.relu(Conv2)with tf.name_scope("C2_Pool"): C2_Pool = max_pool_2x2(C2_Conv)#平化层with tf.name_scope("D_Flat"): D_Flat = tf.reshape(C2_Pool,[-1,1764])#隐藏层with tf.name_scope("D_Hidden_Layer"): w3 = weight([1764,128]) b3 = bias([128]) D_Hidden = tf.nn.relu(tf.matmul(D_Flat,w3)+b3) D_Hidden_Dropout = tf.nn.dropout(D_Hidden,keep_prob= 0.8)#输出层with tf.name_scope("Output_layter"): w4 = weight([128,10]) b4 = bias([10]) y_pre = tf.nn.softmax(tf.matmul(D_Hidden_Dropout,w4)+b4) #优化器with tf.name_scope("Optimizer"): y_label = tf.placeholder("float",[None,10],name = "y_label") loss = tf.reduce_mean(tf.nn.softmax_cross_entropy_with_logits(logits = y_pre,labels = y_label)) optimizer = tf.train.AdamOptimizer(learning_rate = 0.001).minimize(loss)#评估with tf.name_scope("evaluate_accuracy"): correct_predict = tf.equal(tf.argmax(y_label,1),tf.argmax(y_pre,1)) accuracy = tf.reduce_mean(tf.cast(correct_predict,"float"))#定义超参数epochs = 15batch_size = 100total_batches = int(mnist.train.num_examples/batch_size)#列表储存结果loss_list = []epochs_list = []accuracy_list = []start_time = time()#全局变量初始化init = tf.global_variables_initializer()with tf.Session() as sess: sess.run(init) print('-'*24) for i in range(epochs): for j in range(total_batches): batch_x , batch_y = mnist.train.next_batch(batch_size) sess.run(optimizer,feed_dict = &#123;x:batch_x,y_label: batch_y&#125;) los , acc = sess.run([loss,accuracy],feed_dict = &#123;x:mnist.validation.images,y_label:mnist.validation.labels&#125;) epochs_list.append(i) loss_list.append(los) accuracy_list.append(acc) print("Train Epoch: ","%2d, "%(i+1),"Loss = &#123;:.9f&#125;, ".format(los),"Accuracy = ",acc) print("-"*24) duration = time() - start_time print("Train finished task: ",duration) print("-"*24) print("Accuracy: ",sess.run(accuracy,feed_dict = &#123;x:mnist.test.images,y_label:mnist.test.labels&#125;)) prediction_result = sess.run(tf.argmax(y_pre,1),feed_dict = &#123;x:mnist.test.images&#125;) print("predict result: ",prediction_result[:10]) plot_image_label_prediction(mnist.test.images,mnist.test.labels,prediction_result,num = 25) merged = tf.summary.merge_all() train_train_writer = tf.summary.FileWriter("log/tfCNN/", sess.graph) 运行结果 12345678910111213141516171819202122232425262728293031323334353637labels[0]: [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.]labels[0]: 7------------------------Train Epoch: 1, Loss = 1.583467722, Accuracy = 0.8794------------------------Train Epoch: 2, Loss = 1.575986981, Accuracy = 0.884------------------------Train Epoch: 3, Loss = 1.484323025, Accuracy = 0.9774------------------------Train Epoch: 4, Loss = 1.478819370, Accuracy = 0.9828------------------------Train Epoch: 5, Loss = 1.477949262, Accuracy = 0.9838------------------------Train Epoch: 6, Loss = 1.478563309, Accuracy = 0.983------------------------Train Epoch: 7, Loss = 1.475089312, Accuracy = 0.9864------------------------Train Epoch: 8, Loss = 1.475567698, Accuracy = 0.9858------------------------Train Epoch: 9, Loss = 1.474923730, Accuracy = 0.9864------------------------Train Epoch: 10, Loss = 1.473058224, Accuracy = 0.9884------------------------Train Epoch: 11, Loss = 1.471417427, Accuracy = 0.99------------------------Train Epoch: 12, Loss = 1.473668575, Accuracy = 0.988------------------------Train Epoch: 13, Loss = 1.472185969, Accuracy = 0.9886------------------------Train Epoch: 14, Loss = 1.474017739, Accuracy = 0.9866------------------------Train Epoch: 15, Loss = 1.472573996, Accuracy = 0.9886------------------------Train finished task: 1015.9626131057739------------------------Accuracy: 0.9875predict result: [7 2 1 0 4 1 4 9 5 9] 重要函数分解1.tf.nn.conv2d123456W = tf.truncated_normal([5, 5, 1, 32], stddev=0.1)tf.nn.conv2d(x, W, strides=[1, 2, 2, 1], padding=&apos;SAME&apos;)1.shape = [5,5,1,32] ,卷积核长宽为5,5；通道数为1，卷积核个数32（输出32张图）2.strides=[1, 2, 2, 1]，规定前后必唯 1 ，中间两个数表示水平滑动和垂直滑动步长值3.padding=&apos;SAME&apos;，表示在扫描时，如果遇到卷积核比剩下的元素要大时，这个时候需要补0进行最后一次的行扫描或者列扫描 2.tf.nn.max_pool12345tf.nn.max_pool(value, ksize, strides, padding, name=None)1.value，池化输入，通常是feature map ,shape=[1,height,width,1]2.ksize,池化窗口大小，一般是[1, height, width, 1]3.strides,与卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1]4.padding，和卷积类似，shape=[batch, height, width, channels] 3.tf.nn.softmax_cross_entropy_with_logits12345损失函数tf.nn.softmax_cross_entropy_with_logits(logits, labels, name=None)1.logits，神经网络最后一层的输出如果有batch的话，它的大小就是[batchsize，num_classes]，单样本的话，大小就是num_classes2.labels，实际的标签 4.tf.equal入门必备——判断是否相等 5.tf.argmax123tf.argmax(vector, 1)：返回的是vector中的最大值的索引号，如果vector是一个向量，那就返回一个值，如果是一个矩阵，那就返回一个向量，这个向量的每一个维度都是相对应矩阵行的最大值元素的索引号。 6.tf.summary.merge_all自动管理模式 7.tf.nn.softmax123激活函数函数定义softmax = tf.exp(logits) / tf.reduce_sum(tf.exp(logits), axis) 8.tf.reshape1函数的作用是将tensor变换为参数shape形式 9.tf.train.AdamOptimizer123456789tf.train.AdamOptimizer()函数是Adam优化算法：是一个寻找全局最优点的优化算法，引入了二次方梯度校正。tf.train.AdamOptimizer.__init__( learning_rate=0.001, beta1=0.9, beta2=0.999, epsilon=1e-08, use_locking=False, name=&apos;Adam&apos;) 10.tf.cast数据类型转换 11.tf.nn.dropout12345678tf.nn.dropout()是tensorflow里面为了防止或减轻过拟合而使用的函数，它一般用在全连接层tf.nn.dropout( x, keep_prob, noise_shape=None, seed=None name=None)]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF-NN]]></title>
    <url>%2FAngelNI.github.io%2FTF-NN%2F</url>
    <content type="text"><![CDATA[他只是趁着凌晨四点去另一个世界训练了. TF-Neural Network12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import tensorflow as tfimport numpy as npfrom matplotlib import pyplot as plt#构建隐藏层build the hidden layerdef add_layter(inputs,in_size,out_size,activation_function = None): #权值weight weight = tf.Variable(tf.random_normal([in_size,out_size])) #tf.random_normal()正态分布的数据[in_size,out_size]的矩阵 #偏执 bias = tf.Variable(tf.zeros(shape = [1,out_size])+0.1) wx_plus = tf.matmul(inputs,weight)+bias#矩阵相乘 if activation_function is None: outputs = wx_plus else: outputs = activation_function(wx_plus)#calcute the activative function return outputs#-1 to 1 size = 3000 等差数列x = np.linspace(-1,1,3000,dtype = np.float32)[:,np.newaxis]#添加噪声add noizenoise = np.random.normal(0,0.05,x.shape).astype(np.float32)#数据datay = np.square(x)+noise-0.5#显示数据view the datafig = plt.figure()ax = fig.add_subplot(1,1,1)ax.scatter(x,y)plt.ion()#打开交互模式plt.show()#占位符xx = tf.placeholder(tf.float32,[None,1])yy = tf.placeholder(tf.float32,[None,1])'''设置隐藏层数和每层的神经元个数'''l1 = add_layter(xx,1,10,activation_function = tf.nn.relu)l2 = add_layter(l1,10,15,activation_function = tf.nn.relu)l3 = add_layter(l2,15,10,activation_function = tf.nn.relu)###定义输出层outputs = add_layter(l1,10,1,activation_function=None)##定义损失函数##线性回归问题，loss = MSEloss = tf.reduce_mean(tf.reduce_sum(tf.square(yy-outputs),reduction_indices=[1]))#train 训练train = tf.train.GradientDescentOptimizer(learning_rate = 0.1).minimize(loss = loss)#initial 初始化init = tf.global_variables_initializer()#create the graph 创建图with tf.Session() as sess: sess.run(init) for i in range(1000): sess.run(train,feed_dict = &#123;xx:x,yy:y&#125;) if i % 50 == 0: print(sess.run(loss,feed_dict=&#123;xx:x,yy:y&#125;)) try: ax.lines.remove(lines[0]) except Exception: pass prediction = sess.run(outputs,feed_dict = &#123;xx:x&#125;) lines = ax.plot(x,prediction,'r-',lw = 5) plt.pause(0.5) 线性回归方程拟合动态图(matplotlib制作)]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Neural_Network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TF-GD]]></title>
    <url>%2FAngelNI.github.io%2FTF-GD%2F</url>
    <content type="text"><![CDATA[有生才有死，有暗才有光。——科比·布莱恩特 TF_GradientDescent1234567891011121314151617181920212223242526272829303132333435363738394041import tensorflow as tf #导包##采用线性模型y = w*x+b，实现简单的GD##模型参数Model parametersw = tf.Variable([.3],dtype = tf.float32)b = tf.Variable([-.3],dtype = tf.float32)learn_rate = 0.01#学习效率loop = 1000#迭代次数##模型输入输出，Model input and outputx = tf.placeholder(tf.float32)#占位符y = tf.placeholder(tf.float32)#占位符liner = w*x+b#模型##计算损失函数 calculate the lossloss = tf.reduce_sum(tf.square(liner-y))#一维张量平方差和##优化器optimizer optimizer = tf.train.GradientDescentOptimizer(learn_rate)#设置学习效率train = optimizer.minimize(loss)#梯度计算和梯度更新#此处处理特殊数据时建议将二者操作分开，可以对计算的梯度进行限制，防止梯度消失和爆炸#training datax_train = [1,2,3,4]y_train = [0,-1,-2,-3]#训练traininginit = tf.global_variables_initializer()#初始化参数#creat the graph 创建图los = []step = []with tf.Session() as sess: sess.run(init) for i in range(loop): sess.run(train,&#123;x:x_train,y:y_train&#125;) cur_w,cur_b,cur_loss = sess.run([w,b,loss],&#123;x:x_train,y:y_train&#125;) step.append(i) los.append(cur_loss) #print("w: %s b: %s loss: %s "%(cur_w,cur_b,cur_loss))from matplotlib import pyplot as pltplt.scatter(step,los,color = 'r')plt.show() 得到的损失函数图像如下：]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>GradientDescent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自定义Vscode背景]]></title>
    <url>%2FAngelNI.github.io%2Fvscodebackground%2F</url>
    <content type="text"><![CDATA[我从不会倒下，我是打不死的小强。 Vscode设置背景打开安装目录，拿我的举个栗子E:\VScode\Microsoft VS Code\resources\app\out\vs\workbench，找到该目录下的workbench.desktop.main.css文件右键编辑，添加如下代码，注意是添加。 123456body &#123; background-image: url('file:///E:/VScode/Microsoft VS Code/61.png');/*在这里添加图片路径*/ background-size: 100%; opacity: 0.75; background-repeat: no-repeat;&#125; 然后重启,他会提示vscode损坏，忽略就行了。 效果图如下：]]></content>
      <tags>
        <tag>vscode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[西南民族大学程序竞赛]]></title>
    <url>%2FAngelNI.github.io%2Fnowcoder-3%2F</url>
    <content type="text"><![CDATA[No matter what activities you join,whether you want or not, you could gain unexpected something . A链接：https://ac.nowcoder.com/acm/contest/3570/A 在SMU算法竞赛团队中，谁的地位最高呢？答案是毋庸置疑的——大家发自内心爱戴的川川教练。川川教练对队内事务都非常上心，队员们的需求都尽量满足，队员们的问题也都尽快解决。但是最近川川总感觉力不从心，什么都要自己做实在是太累了！所以他需要你的帮助，这样他就可以有更多的时间和精力去和领导斗智斗勇，去为团队争取更多经费。最近，川川教练需要在新加入的集训队员中，挑选出一支最强的队伍去参加大学生程序设计竞赛。 ​ 川川之前太忙了，并不了解新的集训队员，只能根据HJ提供的队员能力值来筛选队员了。我们的大原则就是强强联手。具体的，新的集训队员一共n个人，HJ会为你提供每个人的编程能力值w。你需要找到编程能力值之和最大的三个人，输出他们的编程能力值之和。特别的，如果找不到一个队伍的编程能力值之和大于m，则输出”Waiver!”。 输入描述:1第一行输入一个整数n，一个整数m，中间用空格隔开。第二行输入n个整数wiw_iwi代表编程能力值。保证所有数据：3≤n≤1003 \leq n \leq 1003≤n≤1000≤m≤3000 \leq m \leq 3000≤m≤300−100≤wi≤100-100 \leq w_i \leq 100−100≤wi≤100 输出描述:1如果任意组合，都无法使得队伍的编程能力值之和大于m，输出一行字符串：&quot;Waiver!&quot;(不含引号)否则输出一个整数，表示在满足队伍编程能力值之和大于m的情况下能组成的最大编程能力值。 输入124 10050 50 55 -5 输出1155 说明1我们选择前三个人，编程能力为155满足要求，同时也能获得最大的编程能力和。 输入124 30050 50 55 -5 输出1Waiver! 说明1怎么选也满足不了要求，Waiver! 备注:1编程能力可能为负数哦，这也是可以理解的。 123456789101112131415161718192021222324252627#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n;int a[1000];int Max;int main()&#123; while (cin&gt;&gt;n&gt;&gt;Max) &#123; for(int i=0;i&lt;n;++i) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n,greater&lt;int&gt;()); int mm = a[0]+a[1]+a[2]; if(mm&gt;Max) cout&lt;&lt;mm&lt;&lt;endl; else &#123; cout&lt;&lt;"Waiver!"&lt;&lt;endl; &#125; &#125; return 0;&#125; D链接：https://ac.nowcoder.com/acm/contest/3570/D来源：牛客网 题目描述 kth特别喜欢自拍,但是她的手机被zyj摔在地上后,前置摄像头坏了,不管拍什么照片都是逆时针旋转了90°,而且照片都还是黑白的.这样的照片怎么能让kth找到对象呢? 现在kth向聪明的你求助,写一个程序帮助kth把图像旋转回来.(她手机太垃圾了,不带图片旋转功能). 因为照片是黑白的.所以对于手机屏幕来说,只有白色和黑色2种情况. 现在给你图片(通过01矩阵表示),对该图片进行旋转.使得图片显示正常. 输入描述:1给你n*n的矩阵且矩阵元素只有0和1,对矩阵实现旋转操作,使得图片恢复正常.2≤n≤10002 \le n \le 10002≤n≤1000 输出描述:1输出旋转之后的矩阵.矩阵每个元素间隔一个空格. 输入12320 11 0 输出121 00 1 备注:1考虑一下旋转的方向. 12345678910111213141516171819202122232425262728293031#include&lt;bits/stdc++.h&gt;using namespace std;int n;int a[1009][1009];int main()&#123; while(cin&gt;&gt;n) &#123; for(int i =1;i&lt;=n;++i) &#123; for(int j =1;j&lt;=n;++j) &#123; cin&gt;&gt;a[i][j]; &#125; &#125; for(int j =1;j&lt;=n;++j) &#123; for(int i=n;i&gt;=1;--i) &#123; if(i==n) cout&lt;&lt;a[i][j]; else &#123; cout&lt;&lt;" "&lt;&lt;a[i][j]; &#125; &#125; cout&lt;&lt;endl; &#125; &#125; return 0;&#125; E链接：https://ac.nowcoder.com/acm/contest/3570/E来源：牛客网 题目描述 HJGG现在有一个大小为 n（米）*m（米）的矩形花园。 由于HJGG有强迫症，所以这片花园被划分nm个为11（平方米）的方格。 现在，HJ想在这片花园上种好多种花，并且他想要相邻的格子上种不同的花~（解释：相邻指的是上下左右四个方向相邻） 添加解释。相邻的格子上种不同的花指的是：一个位置和他上下左右四个方向位置的颜色不同，对于上下左右这四个位置，是可以相同的。 由于HJ被集训队小可爱蕾酱缠着不能脱身，所以想要你来帮帮他~ 如果可以满足HJ哥哥的要求，就告诉他“Beautiful flowers!”,如果不可以就告诉他“Oh! My poor HJ!”（输出均不含双引号） 谁让大家都不能拒绝蕾蕾呢！ 输入描述:1输入仅一行三个整数n,m,k(1≤n,m,k≤105)n, m, k(1 \leq n, m, k \leq 10^5)n,m,k(1≤n,m,k≤105)，分别表示HJGG花园的长和宽，HJGG拥有的花的种类数 输出描述:1输出一行你要告诉HJGG的话~ 输入11 3 5 输出1Beautiful flowers! 输入13 4 1 输出1Oh! My poor HJ! 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;bits/stdc++.h&gt;using namespace std;int m,n,k;int main()&#123; while(cin&gt;&gt;n&gt;&gt;m&gt;&gt;k) &#123; int flag = 0; if(n==1&amp;&amp;m&gt;1) &#123; if(k&gt;=2) flag = 1; &#125; else if(m==1&amp;&amp;n&gt;1) &#123; if(k&gt;=2) flag = 1; &#125; else if(m==1&amp;&amp;n==1) &#123; if(k&gt;=1) flag = 1; &#125; else &#123; if(k&gt;=3) flag = 1; &#125; if(flag) cout&lt;&lt;"Beautiful flowers!"&lt;&lt;endl; else &#123; cout&lt;&lt;"Oh! My poor HJ!"&lt;&lt;endl; &#125; &#125; return 0;&#125; F链接：https://ac.nowcoder.com/acm/contest/3570/F来源：牛客网 题目描述​ SMU的英文全称是Southwest Minzu University，中文名叫做西南民族大学。这所大学因为男女比例约为2比8，因此又被大家戏称为稀男民族大学，又因为民族同学们，通常能歌善舞，且校内的舞蹈、唱歌活动非常之多，所以被戏称为稀男歌舞大学。 ​ 在计算机学院中，男同学的比例远高于其余学院，所以计算机学院的脱单率遥遥领先。但在计算机学院的算法竞赛团队中，却出现了诡异的一个现象：某一届的集训队员，竟然全都是SingleDog。他们非常讨厌被人私下嘲笑为SingleDog。最初，如果听到或者看到SingleDog这个字眼，他们就会失去理智，慢慢的，他们只要看到情侣出现，就抑制不住心中的愤怒。现在情况更加严重了！他们只要看到成双成对的东西，都会开始无能狂怒。现在有一份集训队的通知文件，必须要发到群里，为了让他们心平气和的看完这份文件，只能精简一些文字了。具体的精简策略：集训队的通知文件是一堆小写字母，为了使这些字母不要成双成对的出现，我们只保留每种字母出现的第一个就好。 输入描述:1第一行输入一个n，代表集训队的通知文件的长度。第二行输入一个字符串s，代表集训队的通知文件。保证对于所有数据：1 &lt;= n &lt;= 1000字符串s中，只包含a ~ z 的小写字母。 输出描述:1第一行输出处理后的通知文件长度。第二行输出处理后的集训队通知文件。 输入1218 woyexiangtanlianai 输出1211woyexiangtl 12345678910111213141516171819202122232425262728293031323334#include&lt;bits/stdc++.h&gt;using namespace std;int aa[27];int n;string a;string b;int main()&#123; while(cin&gt;&gt;n) &#123; memset(aa,0,sizeof(aa)); cin&gt;&gt;a; int mm = 0; for(int i =0;i&lt;a.length();++i) &#123; aa[a[i]-96]++; if(aa[a[i]-96]==1) &#123; mm++; b+=a[i]; &#125; &#125; cout&lt;&lt;mm&lt;&lt;endl; for(int i =0;i&lt;b.length();++i) &#123; cout&lt;&lt;b[i]; &#125; cout&lt;&lt;endl; a.clear(); b.clear(); &#125; return 0;&#125; G链接：https://ac.nowcoder.com/acm/contest/3570/G来源：牛客网 题目描述在简谱中，音符是记录音的高低和长短的符号。而用来表示这些音的高低的符号，是用七个阿拉伯数字作为标记，它们的写法是：1、2、3、4、5、6、7，读法为：do、re、mi、fa、sol、la、si。现在给你一段由N个音符构成的简谱，以及唱出来的读音（长度小于10的字符串）的记录，请你判断总共唱错了几个读音。 输入描述:1第一行输入一个整数N（0&lt;N≤1040&lt; N\leq10^&#123;4&#125;0&lt;N≤104）;第二行包含N个数字构成的简谱，数字间用空格隔开；第三行包含N个读音，读音间用空格隔开. 输出描述:1总共唱错的读音个数. 输入12381 2 3 4 5 6 7 1do re mi fa sol la si der 输出11 说明1仅最后一个读音唱错. 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;string a[10006];int n;map&lt;int , string&gt; mp;int aa[10005];int main()&#123; mp[1] = "do"; mp[2] = "re"; mp[3] = "mi"; mp[4] = "fa"; mp[5] = "sol"; mp[6] = "la"; mp[7] = "si"; while(cin&gt;&gt;n) &#123; for(int i =1;i&lt;=n;++i) cin&gt;&gt;aa[i]; for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; //cout&lt;&lt;a[i]&lt;&lt;" "; &#125; int flag= 0; for(int i =1;i&lt;=n;++i) &#123; if(mp[aa[i]] != a[i]) flag++; &#125; cout&lt;&lt;flag&lt;&lt;endl; for(int i=1;i&lt;=n;++i) a[i].clear(); &#125; return 0;&#125; J链接：https://ac.nowcoder.com/acm/contest/3570/J来源：牛客网 题目描述大家都知道斐波那契数列吧！它的定义是这样的：斐波那契数列（Fibonacci sequence），又称黄金分割数列、因数学家列昂纳多·斐波那契（Leonardoda Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子数列”，指的是这样一个数列：1、1、2、3、5、8、13……在数学上，斐波那契数列以如下被以递推的方法定义：F(1) = 1，F(2) = 1, F(n) = F(n-1) + F(n-2) （n≥3,n∈N∗n \geq 3,n \in N^*n≥3,n∈N∗)。 这题的题意也很简单，给你一个正整数n(1≤n≤107)n ( 1 \leq n \leq10^7)n(1≤n≤107)，让你输出斐波那契数列的第n项~由于答案较大，所以输出答案对109+710^9+7109+7取模后的数。 输入描述:1多组读入，保证不超过10组，每组一个正整数n(1≤n≤107)n ( 1 \leq n \leq10^7)n(1≤n≤107)。 输出描述:1斐波那契数列的第n项，答案对109+710^9+7109+7取模。 输入11 输出11 备注:1请留意本题使用空间限制。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566//#include&lt;bits/stdc++.h&gt;#include &lt;iostream&gt;#include&lt;cstring&gt;#include&lt;stdio.h&gt;using namespace std;typedef long long ll;const ll mod=1e9+7;ll f=2;struct node&#123; ll materix[5][5];&#125;;node mul(node a,node b) //矩阵乘法 &#123; node res; memset(res.materix,0,sizeof res.materix); for(int i=1;i&lt;=f;i++) for(int j=1;j&lt;=f;j++) for(int k=1;k&lt;=f;k++) res.materix[i][j]=(res.materix[i][j]+a.materix[i][k]*b.materix[k][j])%mod; return res; &#125;node ksm(node a,ll b)&#123; node ans; memset(ans.materix,0,sizeof ans.materix); for(int i=1;i&lt;=f;i++) ans.materix[i][i]=1; while(b) &#123; if(b&amp;1) ans=mul(ans,a); b&gt;&gt;=1; a=mul(a,a); &#125; return ans;&#125;int main()&#123; ll N; while(cin&gt;&gt;N&amp;&amp;N!=-1) &#123; if(N==1||N==2) printf("1\n"); else if(N==0) printf("0\n"); else &#123; node a,b; a.materix[1][1]=1; a.materix[1][2]=1; a.materix[2][1]=1; a.materix[2][2]=0; //a是那个幂矩阵， b.materix[1][1]=1; b.materix[1][2]=0; b.materix[2][1]=1; b.materix[2][2]=0; //b是最初始的矩阵 //假如a*a*a*b就是a^3*b，所以先求用快速幂求a的三次方，再用结果和b相乘 //注意乘的顺序，矩阵相乘a*b！=b*a，顺序不能搞错 //这里个人有个小诀窍，因为.f(n)=a*f(n-1)+b*f(n-2)+c，所以前边的那个应该是构造矩阵 node ans = ksm(a ,N-2); //从3开始，所以-2 ans = mul(ans ,b) ; printf("%d\n",ans.materix[1][1] ) ; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈理工新生赛]]></title>
    <url>%2FAngelNI.github.io%2Fnowcoder-2%2F</url>
    <content type="text"><![CDATA[每天水水题，处处有惊喜，python过题也很爽（重要的是抽奖）链接 A题目描述最近ACM协会的同学总是利用休息的时间来玩LOL，而且一不小心就玩过头，就耽误了培训时间，这让会长很头疼。玩LOL的同学都知道LOL的全英文名是League of Legends，那么问题来了，如果给你这个单词leagueofl，也就是league这个单词加of这个单词加字母l，然后给你一个全部由小写英文字母组成的字符串，希望这个串中含leagueofl这个单词尽量多。例如串是eagueofaaalltyleagueofl，那么我们可以整理成leagueoflleagueoflaaaty，那么这个串中最多含有两个这个单词。 输入描述:1包含多组数据，输入一串字符串全部有小写英文字母组成。（长度不超过100） 输出描述:1这个串中所包含的最多leagueofl的个数。 示例1 输入1eagueofaaalltyleagueofl 输出12 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;string&gt;using namespace std;string a;int aa[100];int main()&#123; while(cin&gt;&gt;a) &#123; memset(aa,0,sizeof(aa)); for(int i =0;i&lt;a.length();++i) &#123; if(a[i]=='l') aa[1]++; if(a[i]=='e') aa[2]++; if(a[i]=='a') aa[3]++; if(a[i]=='g') aa[4]++; if(a[i]=='u') aa[5]++; if(a[i]=='o') aa[6]++; if(a[i]=='f') aa[7]++; &#125; int sum = 0; while(1) &#123; if(aa[1]&lt;2||aa[2]&lt;2||aa[3]&lt;1||aa[4]&lt;1||aa[5]&lt;1||aa[6]&lt;1||aa[7]&lt;1) break; else &#123; aa[1]-=2; aa[2]-=2; aa[3]-=1; aa[4]-=1; aa[5]-=1; aa[6]-=1; aa[7]-=1; sum++; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; a.clear(); &#125; return 0;&#125; B题目描述 不同的游戏有着不同的开始提示，像Are you really?Go!或者Can you start?。再一些大型的比赛中也有一些提示语，像Wa,Ac.等等。所以现在要求你输出一句提示语:Do you want to play ACM?(yes\no) 输入描述:1无 输出描述:1在一行中输出这一句话，所有符号均为英文符号。一定要仔细 示例1 输入1无 输出1Do you want to play ACM?(yes\no) 1234567#include&lt;iostream&gt;using namespace std;int main()&#123; cout&lt;&lt;"Do you want to play ACM?(yes\\no)"&lt;&lt;endl; return 0;&#125; C题目描述 如图所示为一个由n个圆圈构成的圆环。将自然数1，2，…，n放入圆圈内，并且要求任意两个相邻的圆圈内的数字之和为素数。请问给你圆圈数，你能给出放置自然数的所有正确方案吗？ 注意：圆圈中的数字一定是从1开始的，并且连续不重复。 输入描述:1输入包含多组测试数据。每组输入占一行，为整数n(0&lt;n&lt;20)，表示圆圈数。 输出描述:1对于每组输入，输出所有正确的方案，按字典序从小到大排序。每组输出后输出一个空行。具体输出格式见输出样例。 示例1 输入1268 输出123456789Case 1:1 4 3 2 5 61 6 5 2 3 4Case 2:1 2 3 8 5 6 7 41 2 5 8 3 4 7 61 4 7 6 5 8 3 21 6 7 4 3 8 5 2 备注:1注意：只能按照顺时针方向放置数字。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int a[50];int pre[206];void f()&#123; memset(pre,0,sizeof(pre)); pre[1] = 1; for(int i =2;i*i&lt;201;++i) &#123; if(!pre[i]) for(int j =i*i;j&lt;201;j+=i) pre[j] = 1; &#125;&#125;int main()&#123; int n ; f(); int nn=0; while(cin&gt;&gt;n) &#123; nn++; for(int i =1;i&lt;=n;++i) &#123; a[i] = i; &#125; printf("Case %d:\n",nn); do &#123; if(a[1]!=1) break; int flag1 = 0,flag2 = 0; for(int i =1;i&lt;=n;++i) &#123; if(pre[a[i]+a[i+1]]==0&amp;&amp;i!=n) flag1++; else if(i==n&amp;&amp;pre[a[i]+a[1]]==0) flag1++; else &#123; flag2 = 1; break; &#125; &#125; if(flag2) continue; if(flag1==n) &#123; for(int i =1;i&lt;=n;++i) &#123; if(i==1) cout&lt;&lt;a[i]; else &#123; cout&lt;&lt;" "&lt;&lt;a[i]; &#125; &#125; cout&lt;&lt;endl; &#125; &#125;while(next_permutation(a+1,a+1+n)); cout&lt;&lt;endl; &#125; return 0;&#125; E题目描述 你知道c需要中的缩写吗？ 或者你知道ACM比赛中一些缩写的词组吗？ 像Presentation Error (PE)，Wrong Answer (WA)，time limit exceeded (TLE)。 往往这些缩写可以带给我们一些方便的好处，也可以相当于一些专业词组。 现在要求你自己来定义缩写，根据你若输入的单词，注意，输入词组，输出他的缩写。 输入描述:1输入的第一行是一个整数T，表示一共有T组测试数据。接下来有T行，每组测试数据占一行，每行有一个词组，每个词组由一个或多个单词组成；每组的单词个数不超过10个，每个单词有一个或多个大写或小写字母组成；单词长度不超过10，由一个或多个空格分隔这些单词。 输出描述:1请为每组测试数据输出规定的缩写，每组输出占一行。 示例1 输入12343Cool DownAttack Disabled Carryxiao xue sheng 输出123CDADCXXS 说明1每行的单词不仅仅有一个，所以cin/scanf是不行的 12345678910111213141516171819202122232425262728293031323334#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;cstring&gt;#include&lt;cctype&gt;using namespace std;string a;int main()&#123; int n; cin&gt;&gt;n; getchar(); while(n--) &#123; getline(cin,a,'\n'); string b; b = a[0]; for(int i =0;i&lt;a.length();++i) &#123; if(a[i]==' '&amp;&amp;a[i+1]!=' ') b+=a[i+1]; &#125; transform(b.begin(),b.end(),b.begin(),::toupper); // for(int i =0;i&lt;b.length();++i) // &#123; // transform(b.begin(),b.end(),b.begin(),::toupper); // &#125; //cout&lt;&lt;islower(b[0])&lt;&lt;endl; cout&lt;&lt;b&lt;&lt;endl; a.clear(); b.clear(); &#125; return 0;&#125; F题目描述有一群耗纸，它们喜欢在ACM协会的集训楼的电梯里反复玩弄电梯（假定有这栋楼。。。），这些耗纸定义了一种规则，当他们从一楼涌进电梯之后，每只耗纸都会在电梯上啪啪啪，到处乱拍，第i只耗纸，把楼层是i的倍数全都按了一遍，也就是说第13只耗纸会把第13,26,39等楼全部按一遍，假设这个电梯的质量比较好，开始的时候全是灭的，而且电梯上的按键，每按一次会亮，再按一次会灭掉，再按一次会亮，周而复始。如果知道会长的女神正在n楼自习，会长身边有n只耗纸，他想要尽快的见到他的女神，但是会长不知道这样n只手贱的耗子在一起坐电梯能不能顺利到达n层，因此他想请hlgrc的acmer们帮他算算，他该不该和这些手贱的耗纸一起坐电梯。 输入描述:1多组测试，每组输入一个数字n(0&lt;n&lt;10^15)；当n=0时，程序退出，该组数据不运行； 输出描述:1如果会长该和这些手贱的耗纸一起坐电梯，输出“Goddess,I&apos;m coming~~~”否则输出“Farewell~” 示例1 输入1234111310 输出123Farewell~Farewell~Goddess,I&apos;m coming~~~ 说明1第一组样例，一共有11只耗子，第一只耗纸会把所有的楼层全部按一遍，第二只会把2,4,6,8,10按一遍，...直到第11只耗纸把11层按一遍，那么电梯最后会去的楼层有只有4楼，会长懒得爬楼梯，因此见不到自己的女神,而女神也因为等不到会长，抑郁而终。 12345678910111213141516171819202122#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll; int main()&#123; ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); ll n; while(cin&gt;&gt;n) &#123; if(n==0) break; ll m=sqrt(n); if(m*m==n) cout&lt;&lt;"Goddess,I'm coming~~~"&lt;&lt;endl; else cout&lt;&lt;"Farewell~"&lt;&lt;endl; &#125; return 0;&#125; G题目描述 作为ACM协会的成员，这段时间最盼望的日子就是新生赛那几天。成绩再过几个小时就公布了，会长想给一直顽强拼搏的的参赛队员发一笔奖金。 但是会长就在考虑一个问题：如果每个同学的奖金额都知道，最少需要准备多少张人民币，才能在给每位同学发奖金的时候都不用会长找零呢？ 这里假设同学的奖金都是正整数，单位元，人民币一共有100元、50元、20元、10元、5元和1元六种。 输入描述:1第一行为正整数T，输入数据包含T个测试实例，每个测试实例的第一行是一个整数n（n&lt;100），表示同学的人数，然后是n个同学的奖金。 输出描述:1对于每个测试实例输出一个整数x,表示至少需要准备的人民币张数。每个输出占一行。 示例1 输入12345231 2 32500 500 输出12610 说明1哈理工荣成新生赛 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;int main()&#123; ios::sync_with_stdio(false); cin.tie(0);cout.tie(0); int T;cin&gt;&gt;T; while(T--) &#123; ll sum=0; int n;cin&gt;&gt;n; while(n--) &#123; int x;cin&gt;&gt;x; if(x&gt;=100) &#123; sum=sum+x/100; x=x%100; &#125; if(x&gt;=50) &#123; sum=sum+x/50; x=x%50; &#125; if(x&gt;=20) &#123; sum=sum+x/20; x=x%20; &#125; if(x&gt;=10) &#123; sum=sum+x/10; x=x%10; &#125; if(x&gt;=5) &#123; sum=sum+x/5; x=x%5; &#125; if(x) &#123; sum=sum+x; x=0; &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; H题目描述 大家比赛的时候一定要放轻松！你看，刚来参加比赛的菜鸟小一一做不出题目来急的满头大汗！这让她情何以堪！究竟是一道什么题目搞得她这么纠结？我们来看一下吧！ ACM协会招收了许多热爱编程的小萌新，为增进大家友情周末要进行男子拔河比赛。 为了比赛的可看性，现要选出体重较重的男同学，所以按照从轻到重的体重顺序占成一排进行筛选。 求出这些男同学的体重从轻到重的排序。 输入描述:1输入数据有多组，第一行输入男同学的人数n（1&lt;=n&lt;=10）,第二行分别输入她们的体重m（150&gt;m&gt;0），以EOF作为结束标志. 输出描述:1输出他们的体重由低到高的序列。结果保留2位小数。 示例1 输入1234568.00 59.00 66.67 55.55 45.00277 77 输出1245.00 55.55 59.00 66.67 68.0077.00 77.00 说明1哈理工荣成新生赛 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;double a[100000];int main()&#123; int n ; while(cin&gt;&gt;n) &#123; for(int i =0;i&lt;n;++i) &#123; cin&gt;&gt;a[i]; &#125; sort(a,a+n); for(int i =0;i&lt;n;++i) &#123; if(i==0) printf("%.2lf",a[i]); else &#123; printf(" %.2lf",a[i]); &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; I题目描述 ACM协会的会员越来越多了，训练量也越来也大，为使会员们在高强度的训练下得到放松，会员之间更加亲近，协会想为会员们准备一个晚会，晚会节目由会员们表演。 消息一出，报名要表演节目的会员很多，多达N个，尤其是才华横溢的史老师，点名要上台唱毛不易的《消愁》，但是由于场地和时间有限，只能从这N个人中选M个，请你帮会长算一算，一共有多少种选择方法？ 输入描述:1数据的第一行是一个正整数T，接下来有T组数据，每组数据占一行。每组数据包含两个整数N（来报名的人数，1&lt;=N&lt;=30），M（节目需要的人数0&lt;=M&lt;=30）。 输出描述:1每组数据输出一个整数，每个输出占一行。 示例1 输入12345653 25 34 43 68 0 输出12345310101 12345678910111213t = int(input())for case in range(t): x = y = 1 a,b = map(int,input().split()) j = a for i in range(1,b+1): x = x*i y = y*j j = j-1 print("%d" % ( y/x))]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《悲惨的世界》读后感]]></title>
    <url>%2FAngelNI.github.io%2FThe-Miserable-Ones%2F</url>
    <content type="text"><![CDATA[我们每一个人都是社会的映射，只是这是个大多数人社会。 The Miserable Ones##略述，如有不对请指正## 《The Miserable Ones》（《悲惨的世界》），偶然得读起了这本书，便立刻被开头的米里哀主教所感动，就像第一章的标题一样，他如天使般感化世界，给穷人送去温暖，给强盗讲道，正是他的仁慈，恩惠，塑造了这篇文章的主人公冉阿让。冉阿让原本是因为偷了一块面包去监狱坐牢19年的囚徒，出狱后边对社会充满了仇恨，但主教用自己的行动感化了主人公，也因此有了后面的故事。冉阿让也就是后来的马德兰市长，主教死后，不，没有死，冉阿让就像是主教在世，他开设工厂，接济穷人，就算自己的仇人，也用于去帮助。相反之下，警察局的探长沙威，一眼就认出然就是马德兰市长，是监狱里的囚徒，想方设法的揭穿他的行径，但马德兰市长的行为，让他很难去判断，他只好暗暗观察。 芳汀，是一个苦命的人，独自带着孩子珂赛特，因为社会的教条，她独自带着一个孩子会被被人说闲话，他只好将自己的女儿送给了看上去善良的旅店的老板（恶毒）。每月芳汀都会送去生活费，但旅店的老板不满足此，一次一次撕咬芳汀，而珂赛特呢，成了旅店老板的丫鬟，做各种脏事累活，还吃不饱，捉襟见肘，那时她才不到十岁啊！而芳汀为了孩子想方设法的筹集生活费，后来的她寄生活费的消息，被人知道，因为这个社会，她离开了马德兰的工厂（并不是马德兰），后来因为生活费，他卖掉了头发，卖掉了她的两颗门牙，甚至出去卖，谁知被沙威抓到。巧合的是被马德兰市长知道，听说她的经历后决定放了她并亲自去接她的孩子，珂赛特。在马德兰市长和沙威争执下，最终还是统一发了她。但沙威也因此对马德兰市长有些尊敬。 谁知道假的冉阿让（尚马第）被抓了，马德兰市长听说后，立刻就亲自去赎罪，可他还答应了芳汀去救他的孩子，再三权衡之下，他还是去赎罪。就这样，他又被沙威抓起来（芳汀也去世了），沙威洋洋得意。后来冉阿让在船上做苦力，偶然的一次机会为了就他人，掉落海中（他跑了）。冉阿让没有忘记自己的诺言，去把珂赛特接回来，但旅店老板却认为珂赛特是他的摇钱树，甚至拿起枪杀了冉阿让，但冉阿让和珂赛特逃走了，也就成为了后来的白先生和黑姑娘。 后来马吕斯，因父亲获得爵位世袭，但那都是过去，祖父从来就没让他见过他的父亲，他父亲只好在每次去教堂时，躲在角落里偷偷的流泪。后来马吕斯都知道了，他是马吕斯伯爵，他离开了外祖父的家，独自生存。后来他遇到了白先生和黑姑娘，从来没接触过女性的他，边立刻就对珂赛特充满了爱意，每次去公园里偶遇，但白先生发现了，只好搬家。马吕斯的邻居，就是那个旅店的老板，也是他父亲的恩人（救过他父亲一命，只是为了他父亲的钱财），决定去杀了白先生，可他家的大女儿是个善良的人（对马吕斯充满了爱意），偷偷的帮助他和黑姑娘，帮助白先生逃跑。而马吕斯到底是帮助谁呢，犹豫不决。最后被沙威拿下和四大盗。 后来，革命的烈火熊熊燃起，革命军对抗政府军。马吕斯成为了革命军的领袖，他给珂赛特写信说，他要为革命献身，谁知被冉阿让得知，冉阿让奋不顾身冲去一线。他不打人，他只是将每个人背回来，后来他与被抓沙威相遇，将沙威放走。战火结束后，革命失败了，昏倒的马吕斯被冉阿让从下水道背回，谁知又遇到了旅店的老板 ，想发财，想从马吕斯身上榨取钱财，就这样马吕斯还是活下来了，后来冉阿让也同意了珂赛特和马吕斯的婚姻。而马吕斯也认清了父亲的救命恩人是个什么样的人。后来冉阿让我们的主人公，离开了这个世界。 《悲惨的世界》，一部厚重的人类苦难的”百科全书“。到底是我们塑造了这个世界，还是这个世塑造我们。人之初，性本善，是这个世界将人性变恶。所谓的坏人永远都是坏人是真的对吗？难道坏人没有一丝感恩之心吗？为什么我们要用异样的眼光对待他。我们只是不了解他。雨果，《悲惨的世界》批判整个世界，揭露这个世界的丑恶，不仅是过去，还是现在。]]></content>
      <categories>
        <category>literature</category>
      </categories>
      <tags>
        <tag>The Miserable Ones</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[长沙理工新生赛]]></title>
    <url>%2FAngelNI.github.io%2Fnowcoder-1%2F</url>
    <content type="text"><![CDATA[感觉题挺好的，去签个到，记录一下。点我呦 A链接： https://ac.nowcoder.com/acm/contest/3530/A 题目描述 众所周知，常守朱是一个优秀的执行官，她凭借自身的卓越能力解决了许多案件，当然她手中的支配者也为办案提供了很大的便利，支配者可以测量一个人的犯罪指数，当超过一定值时，则被认为是罪犯。 支配者的工作原理如下：将一个人的脑电波转化为01串（我瞎编的），01串中1的个数越多，则犯罪指数越高，下面给你一个01串，请你统计该串中1的个数 输入描述:1一个字符串s，字符串的长度小于1e5 输出描述:1一个整数，字符串中1的个数 示例1 输入10101 输出12 AC——遍历string1234567891011121314151617181920#include&lt;string&gt;#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;int n;int num;string a;int main()&#123; cin&gt;&gt;a; num = 0; for(int i=0;i&lt;a.length();++i) &#123; if(a[i]=='1') num++; &#125; cout&lt;&lt;num&lt;&lt;endl; return 0;&#125; E链接： https://ac.nowcoder.com/acm/contest/3530/E 来源：牛客网 题目描述众所周知，佳爷是集训队最强，他经常喜欢鄙视集训队最菜的PC，这天他又来了，他丢给PC一道题目： 给你一个字符串，该字符串只包含符号 ‘(’ 和 ‘)’, ，我们称那些左右括号可以一一对应的括号字符串为完美字符串， 比如”()()()”, “((()))”, “((()))()()”, 都是完美字符串 而”((())”, “()(“, “((()))()(“ 不是完美字符串。 这么难的题目，PC当然是不会写的，但他又不想被佳爷鄙视，所以他找到了你，聪明的ACMer啊，请你帮PC解出这题把 输入描述:123第一行一个整数n，代表字符串的长度 n， 1 &lt;= n &lt;= 1e5第二行一串字符串s，只包含字符 &apos;(&apos; , &apos;)&apos;。 输出描述:1如果该字符串是完美字符串，就输出YES，。否则输出NO 示例1 输入124(()) 输出1YES AC——栈的简单应用12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cstdlib&gt;#include&lt;string&gt;using namespace std;string a;int n;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;a; stack&lt;char&gt; s1; stack&lt;char&gt; s2; for(int i=0;i&lt;n;++i) &#123; if(s1.empty()) s1.push(a[i]); else if(a[i]==')'&amp;&amp;s1.top()=='('&amp;&amp;!s1.empty()) &#123; s1.pop(); &#125; else &#123; s1.push(a[i]); &#125; &#125; if(s1.empty()) cout&lt;&lt;"YES"&lt;&lt;endl; else &#123; cout&lt;&lt;"NO"&lt;&lt;endl; &#125; system("pause"); return 0;&#125; F链接： https://ac.nowcoder.com/acm/contest/3530/F 来源：牛客网 题目描述 ——你要是愿意，我就永远存在 某人的朋友圈实在是过于庞大且复杂，要判断两个人是不是朋友，那还真不容易。 现给出某个朋友圈关系图，求任意给出的两个人是否是朋友。 规定：如果x和y是朋友，y和z是朋友，那么x和z也是朋友。 如果x和y是朋友，那么x的朋友都是y的朋友，y的朋友也都是x的朋友。 输入描述:12345第一行，三个整数n,m,p,(n ≤ 50000,m ≤ 50000,p≤50000)，分别表示有n个人，m个朋友关系，询问p对朋友关系。以下m行：每行两个数Mi, Mj，1 ≤ Mi, Mj ≤ n，表示Mi和Mj具有朋友关系。接下来p行：每行两个数Pi ,Pj,询问Pi，Pj是否具有盆友关系 输出描述:1P行，每行一个“Yes”或“No”(不包含引号)。表示第i个询问的答案为“具有”或“不具有”朋友关系。 示例1 输入1234567896 5 31 21 53 45 21 31 42 35 6 输出123YesYesNo AC ——赤果果的并查集123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;cstdlib&gt;using namespace std;int pre[500001];int n,m,p;int find(int x)&#123; if(pre[x]==x) &#123; return x; &#125; else &#123; return pre[x] = find(pre[x]); &#125; &#125;void join(int x,int y)&#123; int fx = find(x); int fy = find(y); if(x!=fy) &#123; pre[fx] = fy; &#125;&#125;int main()&#123; cin&gt;&gt;n; cin&gt;&gt;m; cin&gt;&gt;p; for(int i =1;i&lt;=n;++i) &#123; pre[i] = i; &#125; for(int i =1;i&lt;=m;++i) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; join(x,y); &#125; for(int i =1;i&lt;=p;++i) &#123; int x,y; cin&gt;&gt;x&gt;&gt;y; int dx = find(x); int dy = find(y); if(dy==dx) cout&lt;&lt;"Yes"&lt;&lt;endl; if(dy!=dx) cout&lt;&lt;"No"&lt;&lt;endl; &#125; system("pause"); return 0;&#125; C链接： https://ac.nowcoder.com/acm/contest/3530/C 来源：牛客网 题目描述 咚咚咚！在安静的7教417夜晚，车神带来了一堆神秘的数字。 而417的小伙伴都只钟爱于包含4和7的数字。 例如数字：747,4,7747,4,7是他们钟爱的数字，而476,5,27476,5,27不是。 车神灵机一动，突然问：对于给定的数字n，能否找出各个数位上数字和为n的最小钟爱数字。 如果找到则输出这个最小数, 如果找不到，则输出“YingYingYing”。 输入描述:1一行，一个整数n(1 ≤ n ≤ 1e6) 代表要求车牌号的各个数位上数字的和 输出描述:1输出仅一行，为满足条件的最小车牌号，如果不存在这个车牌号就输出“YingYingYing”。 示例1 输入111 输出147 示例2 输入110 输出1YingYingYing AC——思维123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; int n; cin&gt;&gt;n; int a,b; for(a=0;a*4&lt;=n;++a) &#123; for(b=0;a*4+b*7&lt;=n;++b) &#123; if(a*4+b*7==n) break; &#125; if(a*4+b*7==n) break; &#125; if(a*4+b*7!=n) cout&lt;&lt;"YingYingYing"&lt;&lt;endl; else &#123; for(int i=0;i&lt;a;++i) &#123; cout&lt;&lt;4; &#125; for(int i=0;i&lt;b;++i) &#123; cout&lt;&lt;7; &#125; &#125; system("pause"); return 0;&#125; B链接： https://ac.nowcoder.com/acm/contest/3530/B 来源：牛客网 题目描述 给你n个人，每一个人最多可以选k张牌，这n个人都喜欢数s，一张牌有一个数，如果这个数是s，则这个牌称为happy card 每一个人拿到不同数量的happy card 可以获得不同数量的欢乐值。 假如一个人拿到了 i 张happy card ，则可以获得 hi 的欢乐值( hi 数组单调递增)， 没有happy card的人的欢乐值为0. 如果没有拿到happy card，则获得的欢乐值为0。 现在你需要把着n张牌分配给这n个人（每个人的牌数都可以为0），使这n个人的快乐值总和最大 输入描述:1第一行三个数字n,k,s, 1 &lt;= n &lt;= 500, 1&lt;= k &lt;= n , 1 &lt;= s &lt;= 1e9接下来n个数代表n张牌上的数ai， 1 &lt;= ai &lt;= 1e9接下来k个数代表hi的值,1 &lt;= hi &lt;= 1e9保证 hi-1 &lt;= hi 输出描述:1最大的快乐值和 示例1 输入1235 3 22 2 2 2 22 6 7 输出114 示例2 输入1234 3 99 9 9 9 1 2 3 输出14 AC——DP/01背包？123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define ll long longusing namespace std;int n,k,s;int h[1000];ll f[1000];int main() &#123; cin&gt;&gt;n&gt;&gt;k&gt;&gt;s; int sum=0; for(int i=1,x;i=&lt;n;i++) &#123; cin&gt;&gt;x if(x==s) sum++; &#125; for(int i=1;i&lt;=k;i++) cin&gt;&gt;h[i]; for(int i=1;i&lt;=k;i++) &#123; for(int j=i;j&lt;=sum;j++) &#123; f[j]=max(f[j],f[j-i]+h[i]); &#125; &#125; printf("%lld\n",f[sum]); system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JUST YOU]]></title>
    <url>%2FAngelNI.github.io%2Flife%2F</url>
    <content type="text"><![CDATA[A person ‘s strength is often their biggest weakness and that also means that weakness can be their strength Getting successful ,it is not a magic trick . You have a say-so in that . You can decide to be rich .But you first have to think it .The difference between successful people and non-successful people is here(Mind). You have to change your mind . If you keep doing what you been doing . You’re gonna keep getting what you’ve been getting . So if you’re at a place in your life and you’re not happy with it , you have to change some things. But you have to make a conscientious decision that you’re going to change .And it’s not dependent on anybody else .It’s don’t matter what your mother think .It’s don’t matter what your coworkers think.It’s don’t matter what your siblings think . It’s don’t matter what your children think. it’s don’t matter. They have nothing to do with it . This decision is yours and yours alone . Never let anybody tell you that you can’t. A lot of times as a leader ,a lot of times as a business builder , a lot of times as a craft person ,we will have an idea for a business or a product where the rest of the world says that’s impossible .And we have to be coming from a place within where our I can is larger than I can’t .You absolutely must do the interior work required where you have these firey levels of confidence ,where when the world is saying ,”you know what? I dismiss your vision,or that’s impossible you have to be that lone vice who goes , no ,you know what ? It’s possible .And just watch me do it .”I am not going to allow anything to shape me.I am not gonna allow anything to stop me. I am not gonna allow anything to stop my happiness and growth.You gotta live beyond reality .Even before you do it ,see yourself doing it .Even before you accomplish it ,see yourself accomplishing it .Your perception is everything ,not your circumstances,not your situation ,it’s how you see it .And if you can learn to see it correctly,if you can learn to just get passed the pain ,get passed the litter hurt, and if you can learn to see it properly, I guarantee ,you can be what you wanna be ; you can have what you wanna have ; you can do what you wanna do.]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最小生成树]]></title>
    <url>%2FAngelNI.github.io%2Fminitree%2F</url>
    <content type="text"><![CDATA[加油！活成自己喜欢的样子，干嘛要在意别人的眼光。 最小生成树，学了好久了，理论学起来简单易懂，代码一直也没写，今天补起来。 自己太菜了，只能背板子了。 我只是板子的搬运工，哪里需要哪里套。 最小生成树——水题HDU1233 Kruskal1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n;struct node&#123; int x,y; int w;&#125;mp[10000];int pre[10000];bool cmp(node a,node b)&#123; return a.w&lt;b.w;&#125;int find(int x)&#123; if(pre[x]==x) return x; else &#123; return pre[x] = find(pre[x]); &#125; &#125;void join(int x,int y)&#123; int fx = find(x),fy = find(y); if(x!=fy) &#123; pre[fx] = fy; &#125;&#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(int i =1;i&lt;=n;++i)//并查集初始化 pre[i] = i; for(int i =1;i&lt;=n;++i) &#123; cin&gt;&gt;mp[i].x&gt;&gt;mp[i].y&gt;&gt;mp[i].w; &#125; int N =(n-1)*n/2;//n个顶点可能共有这些边 sort(mp+1,mp+1+n,cmp);//kruskal算法从最小边开始 int k = 0,sum=0; for(int i =1;i&lt;=N;++i) &#123; if(k==n-1)//n个顶点的连通图最少有n-1条边 break; if(find(mp[i].x)!=find(mp[i].y))//判断顶点是否被访问，未访问，则归为一家 join &#123; k++; join(mp[i].x,mp[i].x); sum+=mp[i].w;//记录最小距离 &#125; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; Prim1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define INF 0x3f3f3f3f int n;int mp[10000][10000];int vis[10000];int dis[10000];int ans;void prim(int n)&#123; for(int i=1;i&lt;=n;++i) dis[i] = mp[1][i]; dis[1] = 0; vis[1] = 1; for(int i =2;i&lt;=n;++i) &#123; int t =INF,k; for(int j=1;j&lt;=n;++j) &#123; if(!vis[j]&amp;&amp;dis[j]&lt;t) &#123; t = dis[j]; k = j; &#125; &#125; if(t==INF) break; vis[k] = 1; ans+=t; for(int j=1;j&lt;=n;++j) &#123; if(!vis[j]&amp;&amp;dis[j]&gt;mp[k][j]) dis[j] = mp[k][j]; &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl;&#125;int main()&#123; while(cin&gt;&gt;n&amp;&amp;n) &#123; ans = 0; int m = (n-1)*n/2; memset(vis,0,sizeof(vis)); for(int i =1;i&lt;=m;++i) &#123; int x,y,w; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; mp[x][y] = mp[y][x] = w; &#125; prim(n); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>MST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++的快读+快写]]></title>
    <url>%2FAngelNI.github.io%2Fqread%2F</url>
    <content type="text"><![CDATA[快读，快读，快速读入 关闭同步流卡时间真是卡到死。 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int x[1000005];int main()&#123; //关闭同步流 ios::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL); // int t; cin &gt;&gt; t; while( t-- )&#123; int n; cin &gt;&gt; n; for( int i = 0 ; i &lt; n ; i++ ) cin &gt;&gt; x[i]; sort( x , x + n ); for( int i = 0 ; i &lt; n ; i++ )&#123; if( i == n - 1 ) cout &lt;&lt; x[i] &lt;&lt; endl; else cout &lt;&lt; x[i] &lt;&lt; " "; &#125; &#125;&#125; 快读1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int T;int arr[1000007]; //快读inline int read()&#123; int s=0,w=1; char ch=getchar(); while(ch&lt;'0'||ch&gt;'9')&#123;if(ch=='-')w=-1;ch=getchar();&#125; while(ch&gt;='0'&amp;&amp;ch&lt;='9') s=s*10+ch-'0',ch=getchar(); return s*w;&#125;//快写inline void write(int x)&#123; if(x&lt;0) &#123; putchar('-'); x = -x; &#125; if(x&gt;9) write(x / 10); putchar(x % 10 + '0');&#125;int main()&#123; cin&gt;&gt;T; while(T--)&#123; int n;cin&gt;&gt;n; for(int i = 0;i&lt;n;i++)&#123; arr[i] = read(); &#125; sort(arr,arr+n); for(int i = 0;i&lt;n;i++)&#123; printf("%d",arr[i]); if(i&lt;n-1) printf(" "); &#125; puts(""); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-2]]></title>
    <url>%2FAngelNI.github.io%2Fsort-2%2F</url>
    <content type="text"><![CDATA[桶排序，又简单，又快速，适合处理大量数据 桶排序12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;int n ;int a[1000];// O(m+n)int main()&#123; while(cin&gt;&gt;n) &#123; for(int i=1;i&lt;=n;++i) &#123; int t; cin&gt;&gt;t; a[t]++; &#125; //桶排序 for(int i = 1;i&lt;1000;++i)//从小到大 //for(int i =1000-1;i&gt;=0;--i)//从大到小 &#123; for(int j =1;j&lt;=a[i];++j) &#123; cout&lt;&lt;i&lt;&lt;" "; &#125; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 归并排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;typedef long long ll;ll a[1000000];void merge(ll *A,ll start,ll mid,ll end)&#123; ll p =start,q = mid+1; ll arr[end-start+1],k =0; for(ll i =start;i&lt;=end;i++) &#123; if(p&gt;mid) arr[k++] = A[q++]; else if(q&gt;end) &#123; arr[k++] = A[p++]; &#125; else if(A[p]&lt;A[q]) &#123; arr[k++] = A[p++]; &#125; else &#123; arr[k++] = A[q++]; &#125; &#125; for(int p=0;p&lt;k;++p) &#123; A[start++] =arr[p]; &#125;&#125;void mergesort(ll *A,ll start,ll end)&#123; if(start&lt;end) &#123; ll mid = (start+end)/2; mergesort(A,start,mid); mergesort(A,mid+1,end); merge(A,start,mid,end); &#125;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; for(int i =0;i&lt;n;++i) cin&gt;&gt;a[i]; mergesort(a,0,n-1); for(int i=0;i&lt;n;++i) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125; 堆排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;using namespace std;typedef long long ll;ll a[100000];void swap(ll *a,ll i,ll j)&#123; ll t = a[i]; a[i] = a[j]; a[j] = t;&#125;void heapify(ll *tree,ll n,ll i)&#123; if(i&gt;=n) return ; ll c1 = 2*i+1; ll c2 = 2*i+2; ll max = i; if(c1&lt;n&amp;&amp;tree[c1]&gt;tree[max]) &#123; max = c1; &#125; if(c2&lt;n&amp;&amp;tree[c2]&gt;tree[max]) &#123; max = c2; &#125; if(max != i) &#123; swap(tree,max,i); heapify(tree,n,max); &#125;&#125;void heapsort(ll *a,ll n)&#123; for(ll i =n/2-1;i&gt;=0;i--) &#123; heapify(a,n,i); &#125; for(ll i=n-1;i&gt;=0;i--) &#123; swap(a,i,0); heapify(a,i,0); &#125;&#125;int main()&#123; int n; while(cin&gt;&gt;n) &#123; for(ll i =0;i&lt;n;++i) cin&gt;&gt;a[i]; heapsort(a,n); for(ll i =0;i&lt;n;++i) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; &#125; return 0;&#125; qsortc++的函数库 123456789101112131415161718#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;int cmp(const void *a,const void *b)&#123; return *(int *)a - *(int *)b;&#125;int main()&#123; int n = 10; int a[10] = &#123;-7,6,2,0,3,9,8,4,1,5&#125;; qsort(a,n,sizeof(n),cmp); for(int i =0;i&lt;=10;++i) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[陌上花开]]></title>
    <url>%2FAngelNI.github.io%2Frecord%2F</url>
    <content type="text"><![CDATA[12月的第一天，也是一年中的最后一个月，不知不觉你又长大一岁。 纤尘陌陌终有花开时,花开一季芬芳至永远。陌上那千年的等候,终究等来了花开一世的最终绚烂。陌上花开已迟暮,但终究在千年的等候里绽放出了美丽。这份美丽,或许于陌上而言,真的是经久的等待。或许,陌上早已有了等不来陌上花开的平和,如若陌上花开,阡陌或许觉得已经是生命的奇迹了。 纤尘陌陌里,风舞尽沙,在千年的翘首里,阡陌已经忘了什么是风和沙的 缠绵。在终年的清寂里,阡陌或许看透尘世,舞尽人生,不再对花开有所期待。对于突然在陌上开出的那朵尘世青莲,或许是经久等待之外的惊喜。 秋风习习里,绝尘于陌上那孤寂的青莲,在不知不觉中已露尖尖角,那花 蕾在晨露里绽吐芬芳。它已经错过了花开的最好季节,在秋已至的时候,抹开了沉睡已久的眼,终于明白自己为什么沉睡这么久,只因一直在寻找属于自己生命的阡陌。 或许,属于它生命的阡陌一直在尘世的浮华里,未曾停留。所以千百年来的找寻,终究一次次的和属于它生命的阡陌错过。青莲想它这一生,或许已经找不到属于它生命的那方净土了。于是,沉睡再沉睡,在所有的睡意朦胧里,诠释着自己的前世今生。 不过,青莲是倔强的,惟有找到它想要的阡陌,才愿意在这世绽放属于它自己的美丽。如若,遇不到给它灵魂洗涤的净土,它将永远的沉睡下去,不再醒来。或许,这份倔强终究有一天会感动苍天,让它在醒来的时候遇到了能让它娇艳开放的那方阡陌。 几经轮回,沉睡之中醒来再沉睡,反复了千年,不怕一直在纤尘里流离,只因找不到让它尘埃落定的芬芳。经久的沉睡,但是记忆的芬芳一直是浓郁的,它明白自己为何一直在沉睡,因为在等待着属于它芬芳的阡陌风尘仆仆而来。 所有的轮回里,遇到错过,错过再遇,一场场的浩劫最青莲它把自己禁锢 在了沉睡里。青莲明白自己只是倔强又绝然的,在等着属于它的那一方陌,那一池水。如若能拥有自己想要的阡陌,最后自己的生命会归于一切的平静之中。 青莲或许已经闻到了那方属于它的阡陌的味道,只是那方阡陌还在遥远的地方苍凉的遥望。青莲明白,总有一天自己等待着的那方陌,那池水,会从滚滚的红尘里最后卸下所有的喧嚣,还一切一片清寂。卸下所有的繁华,卸下所有的琐碎,呈有素颜的那天。 青莲明白自己这样倔强的沉睡,为的就是找寻属于自己生命的那方阡陌。它最终需要的是不醉红尘只醉君的那份酣畅淋漓,或许此生也找不到这样的酣畅淋漓。但她自己知道,如若君不来,它就迟迟不开,不管是千年还是万年,永远的沉睡下去。如若君,一世的颠沛流离,那么它就一世的孤芳沉睡。 ——《陌上花开》]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单前缀和]]></title>
    <url>%2FAngelNI.github.io%2Fprefix-sum%2F</url>
    <content type="text"><![CDATA[一切都在潜移默化中ing 【问题引入】 给定n个数，再给出m个询问，每个询问给出区间（i，j）和x，要求 i 到 j 的每一个值都加上x，最后给出每一个询问区间（i，j）的区间和。 暴力：O（n^2）;线段树或者树状数组O（logn）；差分O（n）； 前缀和下图为前缀和的定义式和递推式 差分什么是差分？差分是一个数组相邻两元素的差，一般为下标靠后的减去靠前的一个。设差分数组p[]，即： p[i] = a[i] - a[i - 1] 前缀和 和 差分 的联系 令F(a)表示前缀和数组，G(a)表示差分数组，则 F(G(a)) = G(F(a)) = a 前缀和 和 差分 是一对互逆过程。 一维前缀和根据上述表达式我们可以以O(1)求出区间[i,j]的区间和 sum(i,j) = a[j] - a[i-1] 通过一维前缀和可求得数组中前 i 个元素的和 二维前缀和b[ i ] [ j ] = b[ i - 1 ] [ j] +b[ j ] [ j - 1] -b[ i-1] [ j - 1] + a[ i ] [ j ] 练习51nod1081子段求和12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstdlib&gt;using namespace std;typedef long long ll;ll m,n,a[100000],b[100000];ll x,y;int main()&#123; cin&gt;&gt;n; b[0] = 0; for(ll i =1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; b[i] = b[i-1]+a[i]; &#125; // for(int i =1;i&lt;=n;++i) // cout&lt;&lt;b[i]&lt;&lt;" "; cout&lt;&lt;endl; cin&gt;&gt;m; while(m--) &#123; cin&gt;&gt;x&gt;&gt;y; printf("%lld\n",b[x+y-1]-b[x-1]); &#125; system("pause"); return 0;&#125; HDU1559最大子矩阵123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;#include&lt;cstdlib&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int t;int mp[1005][1004];int b[1005][1005];int n,m,x,y;int main()&#123; cin&gt;&gt;t; while(t--) &#123; memset(b,0,sizeof(b)); cin&gt;&gt;m&gt;&gt;n&gt;&gt;x&gt;&gt;y; for(int i =1;i&lt;=m;++i) &#123; for(int j =1;j&lt;=n;++j) &#123; cin&gt;&gt;mp[i][j]; b[i][j] = b[i-1][j]+b[i][j-1]-b[i-1][j-1]+mp[i][j]; &#125; &#125; int ans=0; for(int i =x;i&lt;=m;++i) &#123; for(int j =y;j&lt;=n;++j) &#123; ans=max(ans,b[i][j]-b[i-x][j]-b[i][j-y]+b[i-x][j-y]); &#125; &#125; cout&lt;&lt;ans&lt;&lt;endl; &#125; system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Prefix_sum</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法-1]]></title>
    <url>%2FAngelNI.github.io%2Fsort-1%2F</url>
    <content type="text"><![CDATA[记住一切都会好起来。给他一点时间。 排序一共有十种排序算法，虽然都没有Algorithm的sort简单好用，但多学无害。 如果你对代码理解起来比较难，你可以参考这篇博文，介绍了十种排序算法排序的动画演示GIF.排序动画演示 下面就看是介绍比较简单的三种排序算法，分别是冒泡排序，选择排序，计数排序，简单插入排序，折半插入排序，希尔排序，快速排序，话不多说，上代码。 冒泡排序冒泡排序有两种方法，一种是最原始的，还有一种是改进过的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;iostream&gt;using namespace std;typedef long long ll;#define rep(i,x,y) for(ll i =x;i&lt;=y;++i)#define MAX 1000000ll a[MAX],n;inline void swap(ll i ,ll j)&#123; ll t = a[i]; a[i] = a[j]; a[j] = t;&#125;//ordinary sort inline void bubblesort(ll a[])//&#123; for(ll i=1;i&lt;n;++i) &#123; for(ll j =n-1;j&gt;=i;--j) // for(ll j =1;i&lt;=n-j;++j) &#123; if(a[j]&gt;a[j+1]) &#123; swap(j,j+1); &#125; &#125; &#125;&#125;//Optimized sortinline void bubblesort_1(ll a[])&#123; int flag =1; for(ll i =1;i&lt;n&amp;&amp;flag;++i) &#123; flag = 0; for(ll j = n-1;j&gt;=i;--j ) &#123; if(a[j]&gt;a[j+1]) &#123; swap(j,j+1); flag = 1; &#125; &#125; &#125;&#125;int main()&#123; cout&lt;&lt;"please input the size of the data："&lt;&lt;endl; while(cin&gt;&gt;n) &#123; ll i; rep(i,1,n) &#123; cin&gt;&gt;a[i]; &#125; //two measures of sorting data //first //bubblesort(a); //second bubblesort_1(a); rep(i,1,n) &#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; cout&lt;&lt;"Please input the size of the data:"&lt;&lt;endl; &#125; return 0;&#125; 选择排序123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;using namespace std; typedef long long ll; ll a[10000],n;inline void swap(ll i,ll j)&#123; ll t = a[i]; a[i] = a[j]; a[j] = t;&#125; inline void selectsort(ll a[]) &#123; ll k,t; for(ll i =1;i&lt;n;++i) &#123; k =i; for(ll j =i+1;j&lt;=n;++j) &#123; if(a[j]&gt;a[k]) k = j; &#125; if(k!=i) &#123; swap(k,i); &#125; &#125; &#125;int main()&#123; while(cin&gt;&gt;n) &#123; for(ll i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; &#125; selectsort(a); //select_sort(a); for(ll i =1;i&lt;=n;++i) &#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; 计数排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;using namespace std;//bilibili//https://www.bilibili.com/video/av54557540/?spm_id_from=333.788.videocard.1int a[10000]; void getarray(int *a,int n)&#123; //unsigned sr = time(NULL); int t=1000; srand(time(NULL)); while(t&lt;1||t&gt;100) &#123; for(int i=0;i&lt;n;++i) &#123; t=rand()%100; a[i] = t; &#125; &#125; cout&lt;&lt;"Random array is: "&lt;&lt;endl; for(int i =0;i&lt;n;++i) cout&lt;&lt;a[i]&lt;&lt;" "; cout&lt;&lt;endl;&#125;void countsort(int *A,int *Aux,int *sortedA,int n)&#123; int k =0; for(int i=0;i&lt;n;++i) &#123; k = max(k,A[i]); &#125; for(int i=0;i&lt;k;++i) &#123; Aux[i] = 0; &#125; for(int i=0;i&lt;n;++i) &#123; Aux[A[i]]++; &#125; int j =0; for(int i=0;i&lt;=k;++i) &#123; int t = Aux[i]; while(t--) &#123; sortedA[j] = i; j++; &#125; &#125; &#125;int main()&#123; int n; cout&lt;&lt;"请输入数量"&lt;&lt;endl; while(cin&gt;&gt;n) &#123; getarray(a,n); int b[10000],c[1000]; countsort(a,b,c,n); cout&lt;&lt;"排序结果为：\n"; for(int i =0;i&lt;n;++i) cout&lt;&lt;c[i]&lt;&lt;" "; cout&lt;&lt;endl; cout&lt;&lt;"请输入数量"&lt;&lt;endl; &#125; return 0;&#125; 简单插入排序123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;using namespace std;#define MAX 100000#define rep(i,x,y) for(int i =x;i&lt;=y;++i)typedef long long ll;typedef struct&#123; ll aa;&#125;data;typedef struct&#123; data a[MAX]; ll length;&#125;List;void insertsort(List &amp;L)&#123; ll i,j; rep(i,2,L.length) &#123; if(L.a[i].aa&lt;L.a[i-1].aa) &#123; L.a[0] = L.a[i]; L.a[i] = L.a[i-1]; for( j =i-2;L.a[0].aa&lt;L.a[j].aa;--j) &#123; L.a[j+1] = L.a[j]; &#125; L.a[j+1] = L.a[0]; &#125; &#125;&#125;int main()&#123; int n; List L; cout&lt;&lt;"请输入数据大小"&lt;&lt;endl; while(cin&gt;&gt;n) &#123; ll i; L.length = n; rep(i,1,n) &#123; cin&gt;&gt;L.a[i].aa; &#125; insertsort(L); rep(i,1,n) &#123; cout&lt;&lt;L.a[i].aa&lt;&lt;" "; &#125; cout&lt;&lt;endl; cout&lt;&lt;"请输入数据大小"&lt;&lt;endl; &#125; return 0;&#125; 折半插入排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;using namespace std;typedef long long ll;#define MAX 10000#define rep(i,x,y) for(int i =x;i&lt;=y;++i)typedef struct &#123; ll aa;&#125;data;typedef struct&#123; data a[MAX]; ll length;&#125;List;void binary_insert_sort(List &amp;L)&#123; ll i; ll low,high,m; rep(i,2,L.length) &#123; L.a[0] = L.a[i]; low = 1;high = i-1; while(low&lt;=high) &#123; m = (low+high)/2; if(L.a[0].aa&lt;L.a[m].aa) high = m-1; else low = m+1; &#125; for(ll j = i-1;j&gt;=high+1;--j) L.a[j+1] = L.a[j]; L.a[high+1] = L.a[0]; &#125;&#125;int main()&#123; int n; List L; cout&lt;&lt;"请输入数据大小"&lt;&lt;endl; while(cin&gt;&gt;n) &#123; ll i; L.length = n; rep(i,1,n) &#123; cin&gt;&gt;L.a[i].aa; &#125; binary_insert_sort(L); rep(i,1,n) &#123; cout&lt;&lt;L.a[i].aa&lt;&lt;" "; &#125; cout&lt;&lt;endl; cout&lt;&lt;"请输入数据大小"&lt;&lt;endl; &#125; return 0;&#125; 希尔排序123456789101112131415161718192021222324252627282930313233343536373839#include&lt;iostream&gt;using namespace std;typedef long long ll;ll n,a[10000];inline void shellsort(ll a[])&#123; int t; for(int gap = n/2;gap&gt;0;gap/=2) &#123; for(int i=gap;i&lt;n;++i) &#123; for(int j = i-gap;j&gt;=0&amp;&amp;a[j]&gt;a[j+gap];j-=gap ) &#123; t = a[j]; a[j] = a[j+gap]; a[j+gap] = t; &#125; &#125; &#125;&#125; int main()&#123; cout&lt;&lt;"请输入数据大小"&lt;&lt;endl; while(cin&gt;&gt;n) &#123; for(int i =0;i&lt;n;++i) &#123; cin&gt;&gt;a[i]; &#125; shellsort(a); for(int i =0;i&lt;n;++i) &#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; cout&lt;&lt;"请输入数据大小"&lt;&lt;endl; &#125; return 0;&#125; 快速排序12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;iostream&gt;using namespace std;typedef long long ll;ll n,a[100000];inline ll partition(ll a[],ll begin,ll end)&#123; a[0] = a[begin]; ll key = a[begin]; while(begin&lt;end) &#123; while(begin&lt;end&amp;&amp;a[end]&gt;=a[0]) end--; a[begin] = a[end]; while(begin&lt;end&amp;&amp;a[begin]&lt;=a[0]) begin++; a[end] = a[begin]; &#125; a[end] = a[0]; return end;&#125;inline void quicksort(ll a[],ll begin, ll end)&#123; if(begin&lt;end) &#123; ll pivotkey = partition(a,begin,end); quicksort(a,begin,pivotkey-1); quicksort(a,pivotkey+1,end); &#125;&#125;int main()&#123; cout&lt;&lt;"Please input the size of the data"&lt;&lt;endl; while(cin&gt;&gt;n) &#123; for(ll i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a[i]; &#125; quicksort(a,1,n); for(ll i=1;i&lt;=n;++i) &#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; cout&lt;&lt;"Please input the size of the data"&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周练19.11.24]]></title>
    <url>%2FAngelNI.github.io%2F3%2F</url>
    <content type="text"><![CDATA[积薄而为厚，积少而为多。 CodeForces - 1180A While playing with geometric figures Alex has accidentally invented a concept of a nn-th order rhombus in a cell grid. A 11-st order rhombus is just a square 1×11×1 (i.e just a cell). A nn-th order rhombus for all n≥2n≥2 one obtains from a n−1n−1-th order rhombus adding all cells which have a common side with it to it (look at the picture to understand it better). Alex asks you to compute the number of cells in a nn-th order rhombus. Input The first and only input line contains integer nn (1≤n≤1001≤n≤100) — order of a rhombus whose numbers of cells should be computed. Output Print exactly one integer — the number of cells in a nn-th order rhombus. Examples Input 11 Output 11 Input 12 Output 15 Input 13 Output 113 Note Images of rhombus corresponding to the examples are given in the statement. 123456789101112131415#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;typedef long long ll;ll n;ll num;int main()&#123; while(cin&gt;&gt;n) &#123; num = 2*(n-1)*(n-1)+2*n-1; cout&lt;&lt;num&lt;&lt;endl; &#125; return 0; &#125; CodeForces - 1180BNick had received an awesome array of integers a=[a1,a2,…,an]a=[a1,a2,…,an] as a gift for his 55 birthday from his mother. He was already going to explore its various properties but after unpacking he was disappointed a lot because the product a1⋅a2⋅…ana1⋅a2⋅…an of its elements seemed to him not large enough. He was ready to throw out the array, but his mother reassured him. She told him, that array would not be spoiled after the following operation: choose any index ii (1≤i≤n1≤i≤n) and do ai:=−ai−1ai:=−ai−1. For example, he can change array [3,−1,−4,1][3,−1,−4,1] to an array [−4,−1,3,1][−4,−1,3,1] after applying this operation to elements with indices i=1i=1 and i=3i=3. Kolya had immediately understood that sometimes it’s possible to increase the product of integers of the array a lot. Now he has decided that he wants to get an array with the maximal possible product of integers using only this operation with its elements (possibly zero, one or more times, as many as he wants), it is not forbidden to do this operation several times for the same index. Help Kolya and print the array with the maximal possible product of elements a1⋅a2⋅…ana1⋅a2⋅…an which can be received using only this operation in some order. If there are multiple answers, print any of them. Input The first line contains integer nn (1≤n≤1051≤n≤105) — number of integers in the array. The second line contains nn integers a1,a2,…,ana1,a2,…,an (−106≤ai≤106−106≤ai≤106) — elements of the array Output Print nn numbers — elements of the array with the maximal possible product of elements which can be received using only this operation in some order from the given array. If there are multiple answers, print any of them. Examples Input 1242 2 2 2 Output 1-3 -3 -3 -3 Input 1210 Output 10 Input 123-3 -3 2 Output 1-3 -3 2 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll n;ll a[200000],b[200000];ll Max1,Max2;int main()&#123; while(cin&gt;&gt;n) &#123; ll Min = 0; for(int i =0;i&lt;n;++i) &#123; cin&gt;&gt;a[i]; &#125; for(int i =0;i&lt;n;++i) &#123; if(a[i]&gt;=0) a[i] = -a[i] - 1; if(a[i]&lt;0) Min= min(a[i],Min); &#125; if(n%2==1) &#123; for(int i=0;i&lt;n;++i) &#123; if(a[i]==Min) &#123; a[i] = -a[i] - 1; break; &#125; &#125; &#125; for(int i =0;i&lt;n;++i) &#123; cout&lt;&lt;a[i]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125; CodeForces - 1169BToad Ivan has mm pairs of integers, each integer is between 11 and nn, inclusive. The pairs are (a1,b1),(a2,b2),…,(am,bm)(a1,b1),(a2,b2),…,(am,bm). He asks you to check if there exist two integers xx and yy (1≤x&lt;y≤n1≤x&lt;y≤n) such that in each given pair at least one integer is equal to xx or yy. Input The first line contains two space-separated integers nn and mm (2≤n≤3000002≤n≤300000, 1≤m≤3000001≤m≤300000) — the upper bound on the values of integers in the pairs, and the number of given pairs. The next mm lines contain two integers each, the ii-th of them contains two space-separated integers aiaiand bibi (1≤ai,bi≤n,ai≠bi1≤ai,bi≤n,ai≠bi) — the integers in the ii-th pair. Output Output “YES” if there exist two integers xx and yy (1≤x&lt;y≤n1≤x&lt;y≤n) such that in each given pair at least one integer is equal to xx or yy. Otherwise, print “NO”. You can print each letter in any case (upper or lower). Examples Input 12345674 61 21 31 42 32 43 4 Output 1NO Input 123455 41 22 33 44 5 Output 1YES Input 123456300000 51 21 21 21 21 2 Output 1YES Note In the first example, you can’t choose any xx, yy because for each such pair you can find a given pair where both numbers are different from chosen integers. In the second example, you can choose x=2x=2 and y=4y=4. In the third example, you can choose x=1x=1 and y=2y=2. The circle line of the Roflanpolis subway has nn stations. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;typedef long long ll;ll n,m;ll a[400000],b1[400000],b2[400000];struct node&#123; ll x,y;&#125;mm[300006];ll con,num,flag;int main()&#123; cin&gt;&gt;n&gt;&gt;m; num = 0; flag = 0; for(int i =1;i&lt;=m;++i) &#123; cin&gt;&gt;mm[i].x&gt;&gt;mm[i].y; &#125; for(int i =2;i&lt;=m;++i) &#123; if(mm[i].x!=mm[1].x&amp;&amp;mm[i].y!=mm[1].x) &#123; a[num++] = i; &#125; &#125; for(int i =0;i&lt;num;++i) &#123; b1[mm[a[i]].x]++; b1[mm[a[i]].y]++; if(b1[mm[a[i]].x] == num||b1[mm[a[i]].y]==num) flag = 1; &#125; if(num ==0) flag = 1; num = 0; for(int i =2;i&lt;=m;++i) &#123; if(mm[i].x!=mm[1].y&amp;&amp;mm[i].y!=mm[1].y) &#123; a[num++] = i; &#125; &#125; for(int i =0;i&lt;num;++i) &#123; b2[mm[a[i]].x]++; b2[mm[a[i]].y]++; if(b2[mm[a[i]].x] == num||b2[mm[a[i]].y]==num) flag = 1; &#125; if(num == 0) flag = 1; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; return 0;&#125; CodeForces - 1169A There are two parallel routes in the subway. The first one visits stations in order 1→2→…→n→1→2→…1→2→…→n→1→2→… (so the next stop after station xx is equal to (x+1)(x+1) if x&lt;nx&lt;n and 11otherwise). The second route visits stations in order n→(n−1)→…→1→n→(n−1)→…n→(n−1)→…→1→n→(n−1)→…(so the next stop after station xx is equal to (x−1)(x−1) if x&gt;1x&gt;1 and nn otherwise). All trains depart their stations simultaneously, and it takes exactly 11 minute to arrive at the next station. Two toads live in this city, their names are Daniel and Vlad. Daniel is currently in a train of the first route at station aa and will exit the subway when his train reaches station xx. Coincidentally, Vlad is currently in a train of the second route at station bb and he will exit the subway when his train reaches station yy. Surprisingly, all numbers a,x,b,ya,x,b,y are distinct. Toad Ilya asks you to check if Daniel and Vlad will ever be at the same station at the same time during their journey. In other words, check if there is a moment when their trains stop at the same station. Note that this includes the moments when Daniel or Vlad enter or leave the subway. Input The first line contains five space-separated integers nn, aa, xx, bb, yy (4≤n≤1004≤n≤100, 1≤a,x,b,y≤n1≤a,x,b,y≤n, all numbers among aa, xx, bb, yy are distinct) — the number of stations in Roflanpolis, Daniel’s start station, Daniel’s finish station, Vlad’s start station and Vlad’s finish station, respectively. Output Output “YES” if there is a time moment when Vlad and Daniel are at the same station, and “NO” otherwise. You can print each letter in any case (upper or lower). Examples Input 15 1 4 3 2 Output 1YES Input 110 2 1 9 10 Output 1NO Note In the first example, Daniel and Vlad start at the stations (1,3)(1,3). One minute later they are at stations (2,2)(2,2). They are at the same station at this moment. Note that Vlad leaves the subway right after that. Consider the second example, let’s look at the stations Vlad and Daniel are at. They are: initially (2,9)(2,9), after 11 minute (3,8)(3,8), after 22 minutes (4,7)(4,7), after 33 minutes (5,6)(5,6), after 44 minutes (6,5)(6,5), after 55 minutes (7,4)(7,4), after 66 minutes (8,3)(8,3), after 77 minutes (9,2)(9,2), after 88 minutes (10,1)(10,1), after 99 minutes (1,10)(1,10). After that, they both leave the subway because they are at their finish stations, so there is no moment when they both are at the same station. 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;using namespace std;typedef long long ll;ll aa[105];ll n;ll a,x,b,y;int main()&#123; while(cin&gt;&gt;n) &#123; int flag = 0; cin&gt;&gt;a&gt;&gt;x&gt;&gt;b&gt;&gt;y; for(ll i =a,j = b;;i++,j--) &#123; if(i&gt;n) i = 1; if(j==0) j=n; if(i==j) flag = 1; if(i==x||j==y) break; &#125; if(flag) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"NO"&lt;&lt;endl; &#125; return 0; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周练19.11.17]]></title>
    <url>%2FAngelNI.github.io%2F2%2F</url>
    <content type="text"><![CDATA[愿能把握当下，珍惜每一段追逐的时光，铭记每一次美好的相遇，不给人生留下遗憾。 B - Consecutive IntegersProblem Statement Snuke has N integers: 1,2,[ldots],N. He will choose K of them and give those to Takahashi. How many ways are there to choose K consecutive integers? Constraints All values in input are integers. 1≤K≤N≤50 Input Input is given from Standard Input in the following format: 1N K Output Print the answer. Sample Input 1 13 2 Sample Output 1 12 There are two ways to choose two consecutive integers: (1,2) and (2,3). Sample Input 2 113 3 Sample Output 2 111 AC 1234567891011#include&lt;iostream&gt;using namespace std;int main()&#123; int n,k; while(cin&gt;&gt;n&gt;&gt;k) &#123; cout&lt;&lt;(n-k)+1&lt;&lt;endl; &#125; return 0;&#125; C - ModSum Problem Statement For an integer N, we will choose a permutation {P1,P2,…,P**N} of {1,2,…,N}. Then, for each i=1,2,…,N, let M**i be the remainder when i is divided by P**i. Find the maximum possible value of M1+M2+[cdots]+M**N. Constraints N is an integer satisfying 1≤N≤109. Input Input is given from Standard Input in the following format: 1N Output Print the maximum possible value of M1+M2+[cdots]+M**N. Sample Input 1 12 Sample Output 1 11 When the permutation {P1,P2}={2,1} is chosen, M1+M2=1+0=1. Sample Input 2 113 Sample Output 2 178 Sample Input 3 11 Sample Output 3 10 AC 123456789101112#include&lt;iostream&gt;using namespace std;int main()&#123; long long int n; cin&gt;&gt;n; long long int sum = 0 ; for(long long int i=1;i&lt;=n-1;i++) sum+=i; cout&lt;&lt;sum&lt;&lt;endl; return 0;&#125; F - Monsters Battle RoyaleProblem Statement There are N monsters, numbered 1,2,…,N. Initially, the health of Monster i is A**i. Below, a monster with at least 1 health is called alive. Until there is only one alive monster, the following is repeated: A random alive monster attacks another random alive monster. As a result, the health of the monster attacked is reduced by the amount equal to the current health of the monster attacking. Find the minimum possible final health of the last monster alive. Constraints All values in input are integers. 2≤N≤105 1≤A*i*≤109 Input Input is given from Standard Input in the following format: 12NA1 A2 … AN Output Print the minimum possible final health of the last monster alive. Sample Input 1 1242 10 8 40 Sample Output 1 12 When only the first monster keeps on attacking, the final health of the last monster will be 2, which is minimum. Sample Input 2 1245 13 8 1000000000 Sample Output 2 11 Sample Input 3 1231000000000 1000000000 1000000000 Sample Output 3 11000000000 AC 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;int a[(int)1e5 + 10];int main() &#123; int n; while(~scanf("%d", &amp;n)) &#123; for (int i = 0; i &lt; n; i++) &#123; scanf("%d", &amp;a[i]); &#125; int begin = 0; int ans; int flag = 0; while (true) &#123; sort(a + begin, a + n); while (a[begin] == 0) begin++; if (begin == n - 1) break; for (int i = begin + 1; i &lt; n; i++) &#123; a[i] %= a[begin]; if (a[i] == 1) &#123; ans = 1; flag = 1; break; &#125; &#125; if(flag) break; &#125; if(!flag) ans = a[n-1]; printf("%d\n", ans); &#125; return 0;&#125; G - Powerful Discount TicketsProblem Statement Takahashi is going to buy N items one by one. The price of the i-th item he buys is A**i yen (the currency of Japan). He has M discount tickets, and he can use any number of them when buying an item. If Y tickets are used when buying an item priced X yen, he can get the item for X/2^Y (rounded down to the nearest integer) yen What is the minimum amount of money required to buy all the items? Constraints All values in input are integers. 1≤N,M≤105 1≤A*i*≤109 Input Input is given from Standard Input in the following format: 12N MA1 A2 … AN Output Print the minimum amount of money required to buy all the items. Sample Input 1 123 32 13 8 Sample Output 1 19 We can buy all the items for 9 yen, as follows: Buy the 1-st item for 2 yen without tickets. Buy the 2-nd item for 3 yen with 2 tickets. Buy the 3-rd item for 4 yen with 1 ticket. Sample Input 2 124 41 9 3 5 Sample Output 2 16 Sample Input 3 121 1000001000000000 Sample Output 3 10 We can buy the item priced 1000000000 yen for 0 yen with 100000 tickets. Sample Input 4 1210 11000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 Sample Output 4 19500000000 AC 123456789101112131415161718192021222324252627282930313233343536#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std; int main()&#123; int m,n; while(cin&gt;&gt;n&gt;&gt;m) &#123; priority_queue&lt;int&gt;q; int t; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;t; q.push(t); &#125; long long sum=0; while(m) &#123; t=q.top()/2; q.pop(); q.push(t); m--; &#125; while(!q.empty()) &#123; sum+=q.top(); q.pop(); &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; I - LowerProblem Statement There are N squares arranged in a row from left to right. The height of the i-th square from the left is H**i. You will land on a square of your choice, then repeat moving to the adjacent square on the right as long as the height of the next square is not greater than that of the current square. Find the maximum number of times you can move. Constraints All values in input are integers. 1≤N≤105 1≤H*i*≤109 Input Input is given from Standard Input in the following format: 12NH1 H2 … HN Output Print the maximum number of times you can move. Sample Input 1 12510 4 8 7 3 Sample Output 1 12 By landing on the third square from the left, you can move to the right twice. Sample Input 2 1274 4 5 6 6 5 5 Sample Output 2 13 By landing on the fourth square from the left, you can move to the right three times. Sample Input 3 1241 2 3 4 Sample Output 3 10 AC 1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int a[100000009];int main()&#123; int t; while(cin&gt;&gt;t) &#123; int con=0,num=0; for(int i=1;i&lt;=t;++i) &#123; cin&gt;&gt;a[i]; &#125; int k = a[1]; for(int i =2;i&lt;=t;++i) &#123; if(k&gt;=a[i]) &#123; num++; k=a[i]; &#125; if(k&lt;a[i]) &#123; con = max(num,con); num = 0; k = a[i]; &#125; &#125; con = max(con,num); cout&lt;&lt;con&lt;&lt;endl; &#125;&#125; M - AB SubstringsProblem Statement Snuke has N strings. The i-th string is s**i. Let us concatenate these strings into one string after arranging them in some order. Find the maximum possible number of occurrences of AB in the resulting string. Constraints 1≤N≤104 2≤|s**i|≤10 s**i consists of uppercase English letters. Input Input is given from Standard Input in the following format: 1234Ns1\vdotss_N Output Print the answer. Sample Input 1 12343ABCAXBAZBAD Sample Output 1 12 For example, if we concatenate ABCA, BAD and XBAZ in this order, the resulting string ABCABADXBAZ has two occurrences of AB. Sample Input 2 123456789109BEWPVCRWHZZNQYIJXBAVREAPAHJMYITEOXBCJHMRMNKBPQVFABZPRGKSPUNA Sample Output 2 14 Sample Input 3 123456787RABYBBEJOZBMHQUVABPAISUMCMABAOBHZSZMEHMA Sample Output 3 14 AC 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;char a[1100];int main()&#123; long long int t; while(cin&gt;&gt;t) &#123; int head=0,tail=0,mid=0,con=0,ans=0; for(int i=0;i&lt;t;++i) &#123; scanf("%s",&amp;a); int len = strlen(a); if(a[0]=='B'&amp;&amp;a[len-1]=='A') con++; if(a[0]=='B'&amp;&amp;a[len-1]!='A') head++; if(a[len-1]=='A'&amp;&amp;a[0]!='B') tail++; for(int j =1;j&lt;len-1;++j) &#123; if(a[j]=='B'&amp;&amp;a[j-1]=='A') ans++; &#125; &#125; int h=0,t=0; if(con) &#123; ans = ans+con-1; if(head) t = 1; if(tail) h = 1; &#125; head = head+h; tail = tail+t; ans = ans+min(head,tail); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找（下）]]></title>
    <url>%2FAngelNI.github.io%2FFind-2%2F</url>
    <content type="text"><![CDATA[可倒一定连续，连续不一定可倒 查找（下）1.排序二叉树]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找（上）]]></title>
    <url>%2FAngelNI.github.io%2Ffind-1%2F</url>
    <content type="text"><![CDATA[我该如何是好~ 插入查找？斐波那契查找？ 查找（静态查找）1.顺序查找12345678910111213141516171819#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int a[101] =&#123;5,16,20,27,30,36,44,55,60,67,74&#125;; vector&lt;int &gt; b(a,a+11); cout&lt;&lt;"5,16,20,27,30,36,44,55,60,67,74" &lt;&lt;endl; cout&lt;&lt;"请输入要查找的数字"&lt;&lt;endl; int k; cin&gt;&gt;k; for(int i =0;i&lt;=b.size();++i) &#123; if(b[i]==k) cout&lt;&lt;"位于第"&lt;&lt;i+1&lt;&lt;"个"&lt;&lt;endl; &#125; return 0;&#125; 2.哨兵查找12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int a[20]; cout&lt;&lt;"请输入序列长度"&lt;&lt;endl; int l ; cin&gt;&gt;l; cout&lt;&lt;"请输入查找的序列"&lt;&lt;endl; for(int i=1;i&lt;=l;++i) cin&gt;&gt;a[i]; cout&lt;&lt;"请输入要查找的数字"&lt;&lt;endl; int k; cin&gt;&gt;k; a[0]=k;//定义哨兵 int j; for( j =l;a[j]!=k;--j); cout&lt;&lt;"位于第"&lt;&lt;j&lt;&lt;"个"&lt;&lt;endl; return 0;&#125; 3.二分查找123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[20];int len ;int k ;int search_bin()&#123; int l=1,r = len; while(l&lt;=r) &#123; int mid = (l+r)/2; if(a[mid]==k) return mid; else if(k&lt;a[mid]) r = mid-1; else l = mid+1; &#125;&#125;int main()&#123; cout&lt;&lt;"请输入序列长度"&lt;&lt;endl; cin&gt;&gt;len; cout&lt;&lt;"请输入查找的序列"&lt;&lt;endl; for(int i=1;i&lt;=len;++i) cin&gt;&gt;a[i]; cout&lt;&lt;"请输入要查找的数字"&lt;&lt;endl; cin&gt;&gt;k; //二分对有序序列查找 ，先排序，在查找 sort(a,a+len); int ans = search_bin(); cout&lt;&lt;"位于第"&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 4. 斐波那契查找1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[100];int F[100]; int len ;int k ;int Fibonacci_Search(int *a,int n,int key)&#123; int low,high,mid,i,k=0; low=1; /* 定义最低下标为记录首位 */ high=n; /* 定义最高下标为记录末位 */ while(n&gt;F[k]-1) k++; for (i=n;i&lt;F[k]-1;i++) a[i]=a[n]; while(low&lt;=high) &#123; mid=low+F[k-1]-1; if (key&lt;a[mid]) &#123; high=mid-1; k=k-1; &#125; else if (key&gt;a[mid]) &#123; low=mid+1; k=k-2; &#125; else &#123; if (mid&lt;=n) return mid; /* 若相等则说明mid即为查找到的位置 */ else return n; &#125; &#125; return 0;&#125; int main()&#123; F[0]=0; F[1]=1; for(int i = 2;i &lt; 100;i++) &#123; F[i] = F[i-1] + F[i-2]; &#125; cout&lt;&lt;"请输入序列长度"&lt;&lt;endl; cin&gt;&gt;len; cout&lt;&lt;"请输入查找的序列"&lt;&lt;endl; for(int i=1;i&lt;=len;++i) cin&gt;&gt;a[i]; cout&lt;&lt;"请输入要查找的数字"&lt;&lt;endl; cin&gt;&gt;k; int result=Fibonacci_Search(a,len,k); printf("位于第:%d 位\n",result); return 0;&#125; 5.插入查找12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[100];int F[100]; int len ;int k ;int inter_Search(int *a,int n,int key)&#123; int low,high,mid; low=1; /* 定义最低下标为记录首位 */ high=n; /* 定义最高下标为记录末位 */ while(low&lt;=high) &#123; mid=low+ (high-low)*(key-a[low])/(a[high]-a[low]); /* 插值 */ if (key&lt;a[mid]) /* 若查找值比插值小 */ high=mid-1; /* 最高下标调整到插值下标小一位 */ else if (key&gt;a[mid])/* 若查找值比插值大 */ low=mid+1; /* 最低下标调整到插值下标大一位 */ else return mid; /* 若相等则说明mid即为查找到的位置 */ &#125; return 0;&#125;int main()&#123; cout&lt;&lt;"请输入序列长度"&lt;&lt;endl; cin&gt;&gt;len; cout&lt;&lt;"请输入查找的序列"&lt;&lt;endl; for(int i=1;i&lt;=len;++i) cin&gt;&gt;a[i]; cout&lt;&lt;"请输入要查找的数字"&lt;&lt;endl; cin&gt;&gt;k; int result=inter_Search(a,len,k); printf("位于第 %d 位\n",result); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[周练19.11.03/10]]></title>
    <url>%2FAngelNI.github.io%2F1%2F</url>
    <content type="text"><![CDATA[花于无声处绽放最美，人于宁静中沉淀愈浓。 POJ3984Description定义一个二维数组： 12345678910111213int maze[5][5] = &#123; 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0,&#125;; 它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的最短路线。 Input一个5 × 5的二维数组，表示一个迷宫。数据保证有唯一解。 Output左上角到右下角的最短路径，格式如样例所示。 Sample Input123450 1 0 0 00 1 0 1 00 0 0 0 00 1 1 1 00 0 0 1 0 Sample Output123456789(0, 0)(1, 0)(2, 0)(2, 1)(2, 2)(2, 3)(2, 4)(3, 4)(4, 4) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;using namespace std;int mp[5][5];int d[4][2] = &#123;-1,0,0,-1,1,0,0,1&#125;;struct node&#123; int x,y;&#125;now,nt,path[5][5];void show(int x,int y)&#123; if(x==0&amp;&amp;y==0) &#123; cout &lt;&lt; "(0, 0)" &lt;&lt; endl; return; &#125; show(path[x][y].x,path[x][y].y); cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; ", " &lt;&lt; y &lt;&lt; ")" &lt;&lt; endl;&#125;int main()&#123; memset(mp,1,sizeof(mp)); for(int i =0;i&lt;5;++i) &#123; for(int j =0;j&lt;5;++j) &#123; cin&gt;&gt;mp[i][j]; &#125; &#125; //BFS queue&lt;node&gt; q; now.x = 0; now.y = 0; q.push(now); mp[now.x][now.y] = 1; while(!q.empty()) &#123; now = q.front(); q.pop(); if(now.x==4&amp;&amp;now.y==4) &#123; break; &#125; for(int i =0;i&lt;4;++i) &#123; nt.x = now.x+d[i][0]; nt.y = now.y+d[i][1]; if(nt.x&gt;=0 &amp;&amp; nt.y&gt;=0 &amp;&amp; nt.x&lt;5 &amp;&amp; nt.y&lt;5 &amp;&amp;mp[nt.x][nt.y]==0) &#123; mp[nt.x][nt.y]=1; path[nt.x][nt.y].x = now.x; path[nt.x][nt.y].y = now.y; q.push(nt); &#125; &#125; &#125; print(4,4); return 0; &#125; // CodeForceHarbin, whose name was originally a Manchu word meaning “a place for drying fishing nets”, grew from a small rural settlement on the Songhua River to become one of the largest cities in Northeast China. Founded in 1898 with the coming of the Chinese Eastern Railway, the city first prospered as a region inhabited by an overwhelming majority of the immigrants from the Russian Empire. Now, Harbin is the capital of Heilongjiang province and the largest city in the northeastern region of the People’s Republic of China. It serves as a key political, economic, scientific, cultural, and communications hub in Northeast China, as well as an important industrial base of the nation. This year, a CCPC regional contest is going to be held in this wonderful city, hosted by Northeast Forestry University. To ensure the contest will be a success and enjoyed by programmers around the country, preparations for the event are well underway months before the contest. You are the leader of a student volunteer group in charge of making banners to decorate the campus during the event. Unfortunately, your group made a mistake and misprinted one of the banners. To be precise, the word “harbin” is missing in that banner. Because you don’t have time to reprint it, the only way to fix it is to cut letters from some used old banners and paste them onto the misprinted banner. You have exactly six banners, and for some reason, you must cut exactly one letter from each banner. Then, you can arrange and paste the six letters onto the misprinted banner and try to make the missing word “harbin”. However, before you start cutting, you decide to write a program to see if this is possible at all. InputThe input contains multiple cases. The first line of the input contains a single integer T (1≤T≤50000)T (1≤T≤50000), the number of cases. For each case, the input contains six lines. Each line contains a non-empty string consisting only of lowercase English letters, describing the letters on one of the old banners. The total length of all strings in all cases doesn’t exceed 2⋅1062⋅106. OutputFor each case, print the string “Yes” (without quotes) if it is possible to make the word “harbin”, otherwise print the string “No” (without quotes). ExampleInput123456789101112132welcometoparticipateintheccpccontestinharbininoctoberharvestbelongninjaresetamazingintriguing Output12NoYes 这道题比较简单，一开始用dfs搜图没搜出来，看了学长的代码，使用全排列写的，记录一下。 123456789101112131415161718192021222324252627282930313233343536#include&lt;bits/stdc++.h&gt;using namespace std;const int maxn=2e6+10;int main()&#123; int t,mp[6][30]; scanf("%d",&amp;t); while(t--) &#123; memset(mp,0,sizeof mp); for(int i=0;i&lt;6;i++) &#123; char st[maxn]; scanf("%s",st); int len=strlen(st); for(int j=0;j&lt;len;j++) mp[i][st[j]-'a']++; &#125; char s[10]=&#123;"abhinr"&#125;;//一定得字典序最小,不然有些情况便利不到 bool flag; do &#123; flag=1; for(int i=0;i&lt;6;i++) if(!mp[i][s[i]-'a']) flag=0; if(flag) break; &#125;while(next_permutation(s,s+6)); if(flag) puts("Yes"); else puts("No"); &#125; return 0;&#125; HDU6575Avin’s company has many ongoing projects with different budgets. His company records the budgets using numbers rounded to 3 digits after the decimal place. However, the company is updating the system and all budgets will be rounded to 2 digits after the decimal place. For example, 1.004 will be rounded downto 1.00 while 1.995 will be rounded up to 2.00. Avin wants to know the difference of the total budget caused by the update. InputThe first line contains an integer n (1 ≤ n ≤ 1, 000). The second line contains n decimals, and the i-th decimal ai (0 ≤ ai ≤ 1e18) represents the budget of the i -th project. All decimals are rounded to 3 digits. OutputPrint the difference rounded to 3 digits.. Sample Input12345611.00110.99921.001 0.999 Sample Output123-0.0010.0010.000 自我感觉这道题太坑了，一开始用double，不行，换成float，WA，最后竟然要用字符串来做，傻眼了。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;cstring&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;string&gt;using namespace std;const int maxx=1e3+100;string s;int n;int main()&#123; while(scanf("%d",&amp;n)!=EOF) &#123; double ans=0.0; int len; for(int i=1;i&lt;=n;i++) &#123; cin&gt;&gt;s; len=s.length(); int x = s[len-1] - '0'; if(x==0) continue; else if(x&gt;=5&amp;&amp;x&lt;=9) ans+=0.001*(10-x); else if(x&lt;5&amp;&amp;x&gt;0) ans-=0.001*x; &#125; printf("%.3lf\n",ans); &#125; return 0;&#125; HDU6573Avin is observing the cars at a crossroads. He finds that there are n cars running in the east-west direction with the i-th car passing the intersection at time ai . There are another m cars running in the north-south direction with the i-th car passing the intersection at time bi . If two cars passing the intersections at the same time, a traffic crash occurs. In order to achieve world peace and harmony, all the cars running in the north-south direction wait the same amount of integral time so that no two cars bump. You are asked the minimum waiting time. InputThe first line contains two integers n and m (1 ≤ n, m ≤ 1, 000). The second line contains n distinct integers ai (1 ≤ ai ≤ 1, 000). The third line contains m distinct integers bi (1 ≤ bi ≤ 1, 000). OutputPrint a non-negative integer denoting the minimum waiting time. Sample Input1234561 1111 221 3 Sample Output1210 这道题不难，但是读懂题很重要。 我语文是体育老师教的哈哈~ 模拟一下就可以了 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxx=5e3+100;bool vis1[maxx];bool vis2[maxx];int a[maxx];int b[maxx];int n,m;int main()&#123; while(scanf("%d%d",&amp;n,&amp;m)!=EOF) &#123; memset(vis1,0,sizeof(vis1)); memset(vis2,0,sizeof(vis2)); for(int i=1;i&lt;=n;i++) scanf("%d",&amp;a[i]),vis1[a[i]]=1; for(int i=1;i&lt;=m;i++) scanf("%d",&amp;b[i]); for(int t=0;t&lt;=3008;t++) &#123; memset(vis2,0,sizeof(vis2)); for(int i=1;i&lt;=m;i++) &#123; vis2[b[i]+t]=1;//对南北方向进行标记 &#125; int flag=0; for(int i=1;i&lt;=t+100;i++) &#123; if(vis1[i]&amp;&amp;vis2[i])//如何南北方向和东西方向同时有车通过，相撞 &#123; flag=1; break; &#125; &#125; if(flag==0) &#123; printf("%d\n",t); break; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RKGE_论文阅读笔记]]></title>
    <url>%2FAngelNI.github.io%2FRKGE%2F</url>
    <content type="text"><![CDATA[while(1) { cout&lt;&lt;”Never Give Up”&lt;&lt;endl; } RKGEAbstract首先，知识图谱已经被证明，可以有效的提高推荐系统的推荐能力。但是也有不足，主要是知识图谱的手动设计的特征（Existing methods mainly rely on hand-engineered features from KGs (e.g., meta paths),）。据此，提出了本篇文章的知识图谱嵌入方法，来自动的学习实体路径的语义表示和实体之间的路径，以描述用户对项目的偏好，解决上述问题。 Introduction首先介绍了目前最先进的方法是基于元路径的方法，但是，摘要中提到的，基于元路径的方法严重依赖于手工构造特征来表示路径语义，而路径语义有进一步依赖于领域知识，并且手工设计的特征可能不是很充分，无法覆盖所有可能的实体关系，这也是主要缺点。 下文又介绍了知识图谱嵌入的方法来推荐，尽管相比于元路径提高了性能，但局限性是忽略了实体之间的语义关系。为此，解决上述方法提出了，RKGE 就拿上图举例子，我们可以找到这样的路径 P(people)——&gt; M（moive）——&gt; C（categories）——&gt;M（Moive） P——&gt;M——&gt;D(director)——&gt;M P——&gt;M——&gt;A(actor)——&gt;M ……….. 等等这些不同长度，不同语义路径关系，可以有很多条，可以有效的找出用户的喜好品味，同时，可以作出不同的电影推荐。这里就有一个问题，这个人会喜欢这些推荐的所有电影吗？答案当然是不是，每个人都有一个偏好。 为此，用递归神经网络来学习实体语义关系，通过循环网路找出不同的语义路径。建立路径模型。提出递归知识图谱嵌入的框架RKGE，捕获路径。为区别不同路径的权重，采用池化操作来区分 Related work基于图的方法主要通过随机游走模型，但容易被流行的实体和中间的实体所偏离。 他们只考虑了KG的拓扑结构，而没有考虑对知识图谱中实体的语义和实体关系进行建模，从而没有充分利用知识图谱进行推荐 基于元路径的方法元路径限制于手工设计特征，限制了推荐系统推荐能力的提高。 基于知识图谱嵌入的方法不能完全捕获实体之间的关系，忽略了实体对之间的关系。 最后总结，RKGE可以解决目前state-of-the-art推荐方法的一些缺点。 RKGE通过给定的数据，利用知识图谱编码的异构信息信息来帮助学习用户和项目之间的更贴切关系，然后用它们来进行更好的推荐。所提取的特征可以完全捕获知识图谱中所编码的实体和实体关系的语义。 操作过程 具体来说，RKGE采用了一种新的递归网络架构，该架构包含一批递归网络，用于对链接相同实体对的路径的语义建模，这些路径无缝地融合到推荐中。它还使用了一个池操作符来区分不同路径在描述用户对项目的偏好时的重要性。 为了更好的挖掘数据中用户与项目之间的关系，提出了两种语义路径挖掘的方法： 只考虑用户到项目之间的路径和这个用户评过分的项目。同时，还会得到用户-用户，项目-项目，这些用户到项目的子序列。 设定阈值。避免引入大量的噪声，失去语义意义。 2.递归网络 主要优点：它们对不同长度的序列进行建模的，以及捕获实体和实体对之间的整个路径的语义的能力 设计了一个网络体系结构来搜索所有可能的关系，它包含了一批递归网络，每个递归网络学习单个路径的语义表示。 递归网络通过学习每个实体的语义表示和整个路径的单一表示对路径进行编码。在RKGE中，这些目标是通过两个网络层来实现的，即嵌入层和注意门控隐藏层。 嵌入层对于p中的每个实体e，嵌入层学习一个分布式表示p，将e映射为一个低维向量，该向量的每个元素表示该实体与潜在语义的密切关系，从而捕获实体的语义意义。 注意门控隐藏层为了学习路径表示，隐含层考虑了路径中实体的嵌入和这些实体的顺序。采用基于流的方法，从路径开始到结束的序列编码。采用注意门机制来控制信息流 3.决策方案研究表明较短的路径可能比较长的路径具有更大的影响，因为较短的路径通常表示具有更强的连接性和更清晰的语义。 注意力机制也能解决这个问题。但是，它的目标通常是识别单个序列中每个元素的重要性，与目标相背。 所以通过池化操作来实现这个操作。 池化有两个操作，实验证明，最大池化相比于平均池化有更好的效果。 Algorithm核心算法]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>RKGE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关键路径]]></title>
    <url>%2FAngelNI.github.io%2Fcritical-path%2F</url>
    <content type="text"><![CDATA[褪去一切繁华，虚无的外表，不知你还有多少真。 关键路径有向图中，用顶点表示事件，用有向边表示活动之间开始的先后顺序，则称这种有向图为AOV（Activity On Vertex）网络；AOV网络可以反应任务完成的先后顺序（拓扑排序）。 在AOV网的边上加上权值表示完成该活动所需的时间，则称这样的AOV网为AOE（Activity On Edge）网，如图： 如何求AOE网中各事件（节点）和各活动（边）的最早开始时间和最迟开始时间以及工程的关键路径？ 整个活动的完成时间是AOE图中从始点到终点的最长路径的长度，这条路径称为关键路径。关键路径上的活动称作关键活动。 注意：关键路径不一定只有一条。 1.最早发生时间：从前往后，前驱结点到当前结点所需时间，取最大值。 结束节点（10）的最早发生时间和最迟发生时间相同。 2.最迟发生时间：从后往前，后继结点的最迟发生时间-边权值，取最小值。 事件 1 2 3 4 5 6 7 8 9 10 最早发生时间 0 5 6 12 15 16 17 19 22 24 最晚发生时间 0 9 6 12 16 20 17 20 22 24 3.关键路径：最早发生时间和最迟发生时间相同的结点即为关键路径上的节点。 这样我们就可以找到关键路径上的结点，通过关键结点也就可以找到关键活动。但是要记住，关键路径不为一(重要的事情说两遍) 不难看出，关键路径上的结点为 4.最早开始时间：等于当前边起始结点的最早发生时间。(Max) 5.最晚开始时间：等于当前边指向结点的最迟发生时间-当前边的权值。 6.最早完工时间：等于当前边指向结点的最早发生时间。 7.最晚完工时间：等于当前边指向结点的最迟发生时间。 活动 a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 最早开始 0 0 5 6 6 12 12 12 15 15 17 19 16 22 最晚开始 4 0 9 6 13 16 13 12 16 16 17 20 20 22 最早完工 5 6 12 12 15 16 15 17 17 19 22 22 24 24 最晚完工 9 6 12 12 16 20 16 17 17 20 22 22 24 24 还有一种找关键路径的方法，就是先找到关键活动，最早最晚开始时间相减为0的活动为关键活动。也就找到了关键事件。 代码后续补上]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>critical-path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假（补） -7]]></title>
    <url>%2FAngelNI.github.io%2FDSU%2F</url>
    <content type="text"><![CDATA[期待已久的并查集如期到来。 并查集(DSU)并查集的英文是Disjoint Set Union， 因此又称（DSU）。 并查集，在一些有N个元素的集合应用问题中，我们通常是在开始时让每个元素构成一个单元素的集合，然后按一定顺序将属于同一组的元素所在的集合合并，其间要反复查找一个元素在哪个集合中。简单的来说就是分门别类的问题。 并查集有两种优化策略： 1.按秩合并 Union by Rank 2.路径压缩 Path Compression 引例江湖中有许多厉害的大侠，他们相互争斗，争个江湖第一，但是这些大侠又有许多的朋友徒弟等熟人，他们见了面不能打架，好了问题来，江湖中有很多大侠，我们该如何区分敌人和朋友呢？ 其实这是一个并查集的问题，将朋友徒弟等熟人归为一个门派（这里其实是集合），如果他们属于一个门派，那么他们就不能打架，否则是敌人，要打架的。 并查集有两个关键的函数，分别的Find（）和Join（）函数 123456789101112131415//find函数int find(int x)&#123; int r = x; while(pre[r]!=r) r = pre[r]; return r;&#125;//join函数void join(int x,int y)&#123; int fx = find(x),fy = find(y); if(x!=fy) pre[fx] = fy;&#125; 以上就是并查集的核心代码。 HDU1232好了来一到并查集的经典题练练手。 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input 1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 Sample Output 1234102998 路径压缩这里有一个问题，想没想过数据量非常大，如果按照上述代码，所有的集合会变成一字长蛇，这就是按秩合并，但这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 好了上代码 12345678910111213141516/*路径压缩是对find()函数的优化*/int find(int x)&#123; if(pre[x] == x) return x; else return pre[x] = find(pre[x]); &#125; void join(int x,int y)&#123; int fx = find(x),fy = find(y); if(x!=fy) pre[fx] = fy;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>DSU</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现贪吃蛇小游戏]]></title>
    <url>%2FAngelNI.github.io%2Fsnake-game%2F</url>
    <content type="text"><![CDATA[一起来玩游戏？ python实现贪吃蛇小游戏先来看看这个小游戏 没错这就是强大的python，实现所有不可能。 先前，有了解到用人工智能训练贪吃蛇，没错就是snake，可以达到很高的分数，并且损失函数随训练次数的增加，逐渐降低，贪吃蛇能够更准确的吃到食物，简直太神奇了。 最近学习了DFS，BFS，这两个搜索图的算法，完全可以用这两个基础算法来实现人工智能的贪吃蛇，A*也可以。算法的主要思路就是通过获取蛇的头部和食物的位置，在避免碰到自己和边缘的前提下进行路径规划。好了就说到这。 下面给出这个贪吃蛇的代码，不是AI-snake哦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328import sysimport osimport pygameimport randomimport mathpygame.init()pygame.display.set_caption("$nAke bRo color fUll--FASAL ")pygame.font.init()random.seed()#globalSPEED = 0.36SNAKE_SIZE = 9APPLE_SIZE = SNAKE_SIZESEPARATION = 10SCREEN_HEIGHT = 600SCREEN_WIDTH = 800FPS = 25KEY = &#123;"UP":1,"DOWN":2,"LEFT":3,"RIGHT":4&#125;#Screen initializationscreen = pygame.display.set_mode((SCREEN_WIDTH,SCREEN_HEIGHT),pygame.HWSURFACE)#Resourcesscore_font = pygame.font.Font(None,38)score_numb_font = pygame.font.Font(None,28)game_over_font = pygame.font.Font(None,46)play_again_font = score_numb_fontscore_msg = score_font.render("Score:",1,pygame.Color("red"))score_msg_size = score_font.size("Score")#pygame coloration for aquabackground_color = pygame.Color(0,255,255)black = pygame.Color(0,255,255)#ClockgameClock = pygame.time.Clock()def checkCollision(posA,As,posB,Bs): #As size of a | Bs size of B if(posA.x &lt; posB.x+Bs and posA.x+As &gt; posB.x and posA.y &lt; posB.y + Bs and posA.y+As &gt; posB.y): return True return Falsedef checkLimits(entity): if(entity.x &gt; SCREEN_WIDTH): entity.x = SNAKE_SIZE if(entity.x &lt; 0): entity.x = SCREEN_WIDTH - SNAKE_SIZE if(entity.y &gt; SCREEN_HEIGHT): entity.y = SNAKE_SIZE if(entity.y &lt; 0): entity.y = SCREEN_HEIGHT - SNAKE_SIZEclass Apple: def __init__(self,x,y,state): self.x = x self.y = y self.state = state self.color = pygame.color.Color("red") def draw(self,screen): pygame.draw.rect(screen,self.color,(self.x,self.y,APPLE_SIZE,APPLE_SIZE),0)class Segment: def __init__(self,x,y): self.x = x self.y = y self.direction = KEY["UP"] self.color = "red"class Snake: def __init__(self,x,y): self.x = x self.y = y self.direction = KEY["UP"] self.stack = [] self.stack.append(self) blackBox = Segment(self.x,self.y + SEPARATION) blackBox.direction = KEY["UP"] blackBox.color = "NULL" self.stack.append(blackBox) def move(self): last_element = len(self.stack)-1 while(last_element != 0): self.stack[last_element].direction = self.stack[last_element-1].direction self.stack[last_element].x = self.stack[last_element-1].x self.stack[last_element].y = self.stack[last_element-1].y last_element-=1 if(len(self.stack)&lt;2): last_segment = self else: last_segment = self.stack.pop(last_element) last_segment.direction = self.stack[0].direction if(self.stack[0].direction ==KEY["UP"]): last_segment.y = self.stack[0].y - (SPEED * FPS) elif(self.stack[0].direction == KEY["DOWN"]): last_segment.y = self.stack[0].y + (SPEED * FPS) elif(self.stack[0].direction ==KEY["LEFT"]): last_segment.x = self.stack[0].x - (SPEED * FPS) elif(self.stack[0].direction == KEY["RIGHT"]): last_segment.x = self.stack[0].x + (SPEED * FPS) self.stack.insert(0,last_segment) def getHead(self): return(self.stack[0]) def grow(self): last_element = len(self.stack)-1 self.stack[last_element].direction = self.stack[last_element].direction if(self.stack[last_element].direction == KEY["UP"]): newSegment = Segment(self.stack[last_element].x,self.stack[last_element].y-SNAKE_SIZE) blackBox = Segment(newSegment.x,newSegment.y-SEPARATION) elif(self.stack[last_element].direction == KEY["DOWN"]): newSegment = Segment(self.stack[last_element].x,self.stack[last_element].y+SNAKE_SIZE) blackBox = Segment(newSegment.x,newSegment.y+SEPARATION) elif(self.stack[last_element].direction == KEY["LEFT"]): newSegment = Segment(self.stack[last_element].x-SNAKE_SIZE,self.stack[last_element].y) blackBox = Segment(newSegment.x-SEPARATION,newSegment.y) elif(self.stack[last_element].direction == KEY["RIGHT"]): newSegment = Segment(self.stack[last_element].x+SNAKE_SIZE,self.stack[last_element].y) blackBox = Segment(newSegment.x+SEPARATION,newSegment.y) blackBox.color = "NULL" self.stack.append(newSegment) self.stack.append(blackBox) def iterateSegments(self,delta): pass def setDirection(self,direction): if(self.direction == KEY["RIGHT"] and direction == KEY["LEFT"] or self.direction == KEY["LEFT"] and direction == KEY["RIGHT"]): pass elif(self.direction == KEY["UP"] and direction == KEY["DOWN"] or self.direction == KEY["DOWN"] and direction == KEY["UP"]): pass else: self.direction = direction def get_rect(self): rect = (self.x,self.y) return rect def getX(self): return self.x def getY(self): return self.y def setX(self,x): self.x = x def setY(self,y): self.y = y def checkCrash(self): counter = 1 while(counter &lt; len(self.stack)-1): if(checkCollision(self.stack[0],SNAKE_SIZE,self.stack[counter],SNAKE_SIZE)and self.stack[counter].color != "NULL"): return True counter+=1 return False def draw(self,screen): pygame.draw.rect(screen,pygame.color.Color("yellow"),(self.stack[0].x,self.stack[0].y,SNAKE_SIZE,SNAKE_SIZE),0) counter = 1 while(counter &lt; len(self.stack)): if(self.stack[counter].color == "NULL"): counter+=1 continue pygame.draw.rect(screen,pygame.color.Color("white"),(self.stack[counter].x,self.stack[counter].y,SNAKE_SIZE,SNAKE_SIZE),0) counter+=1def getKey(): for event in pygame.event.get(): if event.type == pygame.KEYDOWN: if event.key == pygame.K_UP: return KEY["UP"] elif event.key == pygame.K_DOWN: return KEY["DOWN"] elif event.key == pygame.K_LEFT: return KEY["LEFT"] elif event.key == pygame.K_RIGHT: return KEY["RIGHT"] elif event.key == pygame.K_ESCAPE: return "exit" elif event.key == pygame.K_y: return "yes" elif event.key == pygame.K_n: return "no" if event.type == pygame.QUIT: sys.exit()def respawnApple(apples,index,sx,sy): radius = math.sqrt((SCREEN_WIDTH/2*SCREEN_WIDTH/2 + SCREEN_HEIGHT/2*SCREEN_HEIGHT/2))/2 angle = 999 while(angle &gt; radius): angle = random.uniform(0,800)*math.pi*2 x = SCREEN_WIDTH/2 + radius * math.cos(angle) y = SCREEN_HEIGHT/2 + radius * math.sin(angle) if(x == sx and y == sy): continue newApple = Apple(x,y,1) apples[index] = newAppledef respawnApples(apples,quantity,sx,sy): counter = 0 del apples[:] radius = math.sqrt((SCREEN_WIDTH/2*SCREEN_WIDTH/2 + SCREEN_HEIGHT/2*SCREEN_HEIGHT/2))/2 angle = 999 while(counter &lt; quantity): while(angle &gt; radius): angle = random.uniform(0,800)*math.pi*2 x = SCREEN_WIDTH/2 + radius * math.cos(angle) y = SCREEN_HEIGHT/2 + radius * math.sin(angle) if( (x-APPLE_SIZE == sx or x+APPLE_SIZE == sx) and (y-APPLE_SIZE == sy or y+APPLE_SIZE == sy) or radius - angle &lt;= 10): continue apples.append(Apple(x,y,1)) angle = 999 counter+=1def endGame(): message = game_over_font.render("Game Over",1,pygame.Color("white")) message_play_again = play_again_font.render("Play Again? Y/N",1,pygame.Color("green")) screen.blit(message,(320,240)) screen.blit(message_play_again,(320+12,240+40)) pygame.display.flip() pygame.display.update() myKey = getKey() while(myKey != "exit"): if(myKey == "yes"): main() elif(myKey == "no"): break myKey = getKey() gameClock.tick(FPS) sys.exit()def drawScore(score): score_numb = score_numb_font.render(str(score),1,pygame.Color("red")) screen.blit(score_msg, (SCREEN_WIDTH-score_msg_size[0]-60,10) ) screen.blit(score_numb,(SCREEN_WIDTH - 45,14))def drawGameTime(gameTime): game_time = score_font.render("Time:",1,pygame.Color("red")) game_time_numb = score_numb_font.render(str(gameTime/1000),1,pygame.Color("red")) screen.blit(game_time,(30,10)) screen.blit(game_time_numb,(105,14))def exitScreen(): passdef main(): score = 0 #Snake initialization mySnake = Snake(SCREEN_WIDTH/2,SCREEN_HEIGHT/2) mySnake.setDirection(KEY["UP"]) mySnake.move() start_segments=3 while(start_segments&gt;0): mySnake.grow() mySnake.move() start_segments-=1 #Apples max_apples = 1 eaten_apple = False apples = [Apple(random.randint(60,SCREEN_WIDTH),random.randint(60,SCREEN_HEIGHT),1)] respawnApples(apples,max_apples,mySnake.x,mySnake.y) startTime = pygame.time.get_ticks() endgame = 0 while(endgame!=1): gameClock.tick(FPS) #Input keyPress = getKey() if keyPress == "exit": endgame = 1 #Collision check checkLimits(mySnake) if(mySnake.checkCrash()== True): endGame() for myApple in apples: if(myApple.state == 1): if(checkCollision(mySnake.getHead(),SNAKE_SIZE,myApple,APPLE_SIZE)==True): mySnake.grow() myApple.state = 0 score+=5 eaten_apple=True #Position Update if(keyPress): mySnake.setDirection(keyPress) mySnake.move() #Respawning apples if(eaten_apple == True): eaten_apple = False respawnApple(apples,0,mySnake.getHead().x,mySnake.getHead().y) #Drawing screen.fill(background_color) for myApple in apples: if(myApple.state == 1): myApple.draw(screen) mySnake.draw(screen) drawScore(score) gameTime = pygame.time.get_ticks() - startTime drawGameTime(gameTime) pygame.display.flip() pygame.display.update()main()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>snake_game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最短路问题]]></title>
    <url>%2FAngelNI.github.io%2Fminpath%2F</url>
    <content type="text"><![CDATA[过去我也有美梦来着，有幻想来着，可不知神魔时候，都烟消云散了，还是遇见你之前的事。 Floyd算法理论Floyd算法又称为插点法，是一种利用动态规划的思想寻找给定的加权图中多源点之间最短路径的算法。 Floyd算法理解起来最简单。 Floyd算法自我感觉是暴力+贪心的算法，把每一种可能都遍历一遍，在加上动态规划状态转移，把每一种遍历的结果与当前结果比较，如果遍历结果距离小于目前结果，则前一状态转移到的这一状态。 简单的说，如果 I 经过 K 到 J 的距离 小于 I 直接到 J 的 距离 ， 则I 到J 的距离 为 I 经过 K 到 J 的距离 。 例如：有如下有向图，利用Floyd算法，给出每一对顶点之间的最短路径及其路径长度求解过程中的变化。 闲来无聊，就做个GIF图片。 第一步：0行0列不变，依次填入表格。 第二步：遍历其余表格，十字交叉，看两个值相加是否小于当前值，小于则填入，否则，不变。直到遍历所有表格。 第三步：将更新后表格的1行1列不变依次填入，重复步骤二。 直到N行N列 结束 就拿动态图中的蓝色5，根据十字交叉，与红色分别相交于1和3 ，1+3=4&lt;5,所以更新列表，将4填入。 代码代码之前先看几道简单的OJ题 hdu最短路 hdu畅通工程续 Floyd最短路 只要稍微改下输入输出就可以AC。 以上是三道水题，水水更开心。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,m;int mp[1005][1005];int main()&#123; while(cin&gt;&gt;n&gt;&gt;m&amp;&amp;n&amp;&amp;m) &#123; for(int i =1;i&lt;=n;++i) &#123; for(int j=1;j&lt;=n;++j) &#123; if(i!=j) mp[i][j] = 1e9; else mp[i][j] = 0; &#125; &#125; int a,b,c; for(int i =1;i&lt;=m;++i) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(mp[a][b]&gt;c) &#123; mp[a][b] = c; mp[b][a] = c; &#125; &#125; for(int k =1;k&lt;=n;++k) &#123; for(int i = 1;i&lt;=n;++i) &#123; for(int j =1;j&lt;=n;++j) &#123; if(mp[i][k]+mp[k][j]&lt;mp[i][j]) &#123; mp[i][j] = mp[i][k]+mp[k][j]; &#125; &#125; &#125; &#125; for(int i =1;i&lt;=n;++i) &#123; for(int j =1;j&lt;=n;++j) &#123; cout&lt;&lt;mp[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; &#125; &#125; Dijstra算法迪杰斯特拉算法(Dijkstra)是由荷兰计算机科学家狄克斯特拉于1959 年提出的，因此又叫狄克斯特拉算法。是从一个顶点到其余各顶点的最短路径算法，解决的是有权图中最短路径问题。迪杰斯特拉算法主要特点是以起始点为中心向外层层扩展，直到扩展到终点为止。【来自百度百科】 Dijkstra算法虽然好，但是并不能解决负权问题，更准确的说是判断有没有负权的存在。 这个代码在学离散的时候，手动实现过，考试也考过，只是代码没写过，~纠结。 代码hdu最短路 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;iostream&gt;using namespace std;#define inf 0x3f3f3f3fint map[105][105],dis[105],vis[105]; //map存地图，dis存源点到当前点的距离，vis存访问状态 int n,m;void dijkstra(int start) &#123; int i,j,k; for(i=1; i&lt;=n; i++) &#123; dis[i]=map[start][i]; //对dis进行初始化 &#125; for(i=1;i&lt;=n;i++) vis[i]=0; //0表示没有被访问，1表示被访问 vis[start]=1; for(i=1;i&lt;=n-1;i++) //因为最多访问n-1个点，所以循环n-1次 &#123; int mix=inf; int u; for(j=1;j&lt;=n;j++) &#123; if(vis[j]==0 &amp;&amp; mix&gt;dis[j]) &#123; mix=dis[j]; //记录下距离源点最近的点，并且没有被访问 u=j; &#125; &#125; vis[u]=1; //标记为已经被访问 for(k=1;k&lt;=n;k++) &#123; if(vis[k]==0 &amp;&amp; dis[k]&gt;dis[u]+map[u][k]) dis[k]=dis[u]+map[u][k]; //以该点为跳板，对所有点进行松弛 &#125; &#125;&#125;int main()&#123; int i,j,k; while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n || m) &#123; for(i=1;i&lt;=n;i++) for(j=1;j&lt;=n;j++) &#123; if(i==j) map[i][j]=0; else map[i][j]=inf; //初始化 &#125; while(m--) &#123; int x,y,z; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; if(map[x][y]&gt;z) &#123; map[x][y]=map[y][x]=z; //无向图 &#125; &#125; dijkstra(1); cout&lt;&lt;dis[n]&lt;&lt;endl; &#125; return 0;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define Max 1e9int n,m;int mp[10005][10005];int dis[10005],visit[10005];int main()&#123; while(cin&gt;&gt;n&gt;&gt;m)//n条边 m个顶点 &#123; for(int i =1;i&lt;=m;++i) &#123; mp[i][i] = 0; for(int j=1;j&lt;i;++j) &#123; mp[i][j] = mp[j][i] = Max; &#125; &#125; int a,b,c; for(int i=1;i&lt;=n;++i) &#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; if(mp[a][b]&gt;c) mp[a][b] = mp[b][a] = c; &#125; for(int i =1;i&lt;=m;++i) &#123; dis[i] = mp[1][i]; &#125; memset(visit,0,sizeof(visit)); int Min,k; visit[1]=1; for(int i =1;i&lt;=m;++i) &#123; Min = Max; k = 1; for(int j =1;j&lt;=m;++j) &#123; if(visit[j]==0&amp;&amp;Min&gt;dis[j]) &#123; Min = dis[j]; k = j; &#125; &#125; visit[k] = 1; for(int j =1;j&lt;=m;++j) &#123; if(visit[j]==0&amp;&amp;dis[j]&gt;dis[k]+mp[k][j]) dis[j] = dis[k] + mp[k][j]; &#125; &#125; cout&lt;&lt;dis[m]&lt;&lt;endl; &#125; return 0; &#125; Bellman_Fod算法贝尔曼-福特算法（英语：Bellman–Ford algorithm），求解单源最短路径问题的一种算法，由理查德·贝尔曼（Richard Bellman） 和 莱斯特·福特 创立的。有时候这种算法也被称为 Moore-Bellman-Ford 算法，因为 Edward F. Moore 也为这个算法的发展做出了贡献。它的原理是对图进行次松弛操作，得到所有可能的最短路径。其优于迪科斯彻算法的方面是边的权值可以为负数、实现简单，缺点是时间复杂度过高，高达。但算法可以进行若干种优化，提高了效率。 hdu最短路 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt; using namespace std; #define inf 0x3f3f3f3f #define max 10000 int u[2*max+10],v[2*max+10],w[2*max+10],dis[105]; int main() &#123; //u存起点，v存终点，w存权值，dis和迪杰一样，由于是无向图，所以要 *2 int n,m,i,j,k; int x,y,z; while(cin&gt;&gt;n&gt;&gt;m &amp;&amp; n || m) &#123; for(i=1; i&lt;=2*m; i++) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;z; u[i]=x; v[i]=y; w[i]=z; j=i+1; //构造无向图 u[j]=y; v[j]=x; w[j]=z; i++; &#125; for(i=1; i&lt;=n; i++) dis[i]=inf; dis[1]=0; //将起点设置为零，这样可以保证从起点开始松弛 for(k=1; k&lt;=n-1; k++) &#123; //最多循环n-1次 for(i=1; i&lt;=2*m; i++) &#123; if(dis[v[i]]&gt;dis[u[i]]+w[i]) dis[v[i]]=dis[u[i]]+w[i]; //对所有的边进行松弛操作 &#125; &#125; for(i=1; i&lt;=2*m; i++) &#123; if(dis[v[i]]&gt;dis[u[i]]+w[i]) return false; //这里检测有没有负权，不过本题用不到 &#125; cout&lt;&lt;dis[n]&lt;&lt;endl; &#125; return 0; &#125; 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;vector&lt;int &gt; v[20000005];int dis[1000005];int main()&#123; int n , m,x,y,w; while(cin&gt;&gt;n&gt;&gt;m) &#123; for(int i=0;i&lt;10005;++i) dis[i] = 1e9; for(int i=0;i&lt;n;++i) &#123; cin&gt;&gt;x&gt;&gt;y&gt;&gt;w; v[i].push_back(x); v[i].push_back(y); v[i].push_back(w); &#125; dis[0] = 0; dis[1] = 0; for(int i=1;i&lt;n;++i) &#123; for(int j=0;j&lt;m;++j) &#123; if(dis[v[j][0]]+v[j][2]&lt;dis[v[j][1]]) &#123; dis[v[j][1]] = dis[v[j][0]]+v[j][2]; &#125; &#125; &#125; for(int i =2;i&lt;=n;++i) &#123; cout&lt;&lt;dis[i]&lt;&lt;" "; &#125; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Data-Structure</category>
      </categories>
      <tags>
        <tag>min_path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假（补）-6]]></title>
    <url>%2FAngelNI.github.io%2Fpriority-queue%2F</url>
    <content type="text"><![CDATA[非常希望在不远的明天，我的晚安可以亲口说，可以先亲一口再说。 优先队列优先队列是什么呢？优先队列其实是一种特殊的队列，对队列的元素按照一定的先后顺序，队列自动排序，这就是优先队列。 话不多说直接上代码。 int ，double等123456789101112131415161718192021#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;int main()&#123; priority_queue&lt;int &gt; q; q.push(4); q.push(10); q.push(6); q.push(1); q.push(15); while(!q.empty()) &#123; int a = q.top(); cout&lt;&lt;a&lt;&lt;" "; q.pop(); &#125; return 0;&#125; // 结果为 15 10 6 4 1 我们发现对int的类型的数据默认从大到小排序，如果从小到大呢？这就需要我们重新定义优先队列的优先顺序，好像叫重载运算符。 好，我们现在开始重载”&lt;”小于运算符。运用结构体重载。 输入 ： 5 4 3 2 1 输出 ：1 2 3 4 5 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;queue&gt;using namespace std;struct node&#123; int x; friend bool operator &lt; (node a,node b)//friend 友元函数 &#123; return a.x &gt; b.x; &#125;&#125;;int main()&#123; priority_queue&lt;node&gt; p; node a; for(int i=5;i&gt;=1;i--) &#123; a.x =i; p.push(a); &#125; while(!p.empty()) &#123; int y = p.top().x; cout&lt;&lt;y&lt;&lt;" "; p.pop(); &#125; return 0;&#125; 以上就是优先队列对int的类型的队列优先级重载。 Array如果对数组使用优先队列就比较简单了。 12priority_queue&lt;int ,vector&lt; int &gt; , less&lt; int &gt; &gt; m;priority_queue&lt; int ,vector&lt; int &gt; , greater&lt; int &gt; &gt; n; 以上就是对数组使用的优先队列，简单吧，就几行代码。 注意：这里有一个坑，一定要注意呦。”&gt;&gt;”编译器会把他识别为右移运算符，两个”&gt;”号之间要有空格！！！ 好了，上样例。 12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;queue&gt;#include&lt;cstdio&gt;using namespace std;int a[5] = &#123;10,2,69,100,-5&#125;;int main()&#123; priority_queue&lt;int ,vector&lt;int &gt;,less&lt;int &gt; &gt; n; priority_queue&lt;int ,vector&lt;int &gt;,greater&lt;int &gt; &gt; m; for(int i =0;i&lt;5;++i) &#123; n.push(a[i]); m.push(a[i]); &#125; while(!n.empty()) &#123; cout&lt;&lt;n.top()&lt;&lt;" ";n.pop(); cout&lt;&lt;endl; &#125; while(!m.empty()) &#123; cout&lt;&lt;m.top()&lt;&lt;" "; m.pop(); cout&lt;&lt;endl; &#125; return 0;&#125; 运行之后不难发现，less&lt; int &gt; 是从大到小排列。greater&lt; int &gt;是从小到大排列。 我目前就自学这么多，还有许多更高级的用法，后续默默的补上&gt;&gt;&gt;&gt;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>priority_queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用二叉树计算表达式值]]></title>
    <url>%2FAngelNI.github.io%2Ftree-calculate%2F</url>
    <content type="text"><![CDATA[有时候，灵感+努力+伙伴的箴言就是成功。 二叉树实现简单表达式求值这是我们的数据结构作业，因为之前用双栈实现过（双栈实现计算器），再写起来就轻松多了。二叉树实现表达式求值实际上是一个后序遍历二叉树的过程，根据规则左右根，找到左结点，右结点，和根节点，进行运算就可以了，好了下面就直接上代码了。 注：此程序能够实现10以内的加减乘除（结果无所谓），记得要以#结尾哦。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;stack&gt;#include&lt;stdlib.h&gt;using namespace std;//定义树节点 struct TNode&#123; char cha; struct TNode *lchild,*rchild;&#125;;//定义树根 最顶树根 TNode * Tree;char compare(char a, char b)&#123; int i, j; char pre[7][7] = &#123; //定义运算符之间的优先级 &#123;'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;'&#125;, &#123;'&gt;','&gt;','&lt;','&lt;','&lt;','&gt;','&gt;'&#125;, &#123;'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;'&#125;, &#123;'&gt;','&gt;','&gt;','&gt;','&lt;','&gt;','&gt;'&#125;, &#123;'&lt;','&lt;','&lt;','&lt;','&lt;','=','0'&#125;, &#123;'&gt;','&gt;','&gt;','&gt;','0','&gt;','&gt;'&#125;, &#123;'&lt;','&lt;','&lt;','&lt;','&lt;','0','='&#125;, &#125;; switch(a) &#123; case '+': i = 0; break; case '-': i = 1; break; case '*': i = 2; break; case '/': i = 3; break; case '(': i = 4; break; case ')': i = 5; break; case '#': i = 6; break; &#125; switch(b) &#123; case '+': j = 0; break; case '-': j = 1; break; case '*': j = 2; break; case '/': j = 3; break; case '(': j = 4; break; case ')': j = 5; break; case '#': j = 6; break; default: printf("表达式要以#结尾！！！\n"); exit(1); &#125; return pre[i][j];&#125;//创建树节点 TNode * CreatNode(TNode *T,TNode *l,TNode *r,char ch)&#123; T-&gt;cha = ch; T-&gt;lchild = l; T-&gt;rchild = r; return T;&#125;//读入表达式 void init_EXPT()&#123; stack&lt;TNode *&gt; EXPT; stack&lt;char&gt; OPTR; OPTR.push('#'); char ch; cin&gt;&gt;ch; while(ch!='#'||OPTR.top()!='#') &#123; if(isdigit(ch)) &#123; TNode *T ; T = (TNode *)malloc(sizeof(TNode)); Tree = CreatNode(T,NULL,NULL,ch); EXPT.push(Tree); cin&gt;&gt;ch; &#125; if(!isdigit(ch)) &#123; if(OPTR.empty()) OPTR.push(ch); else &#123; char top; top = OPTR.top(); switch(compare(top,ch)) &#123; case '&lt;': &#123; OPTR.push(ch); cin&gt;&gt;ch; break; &#125; case '&gt;': &#123; TNode * T ,*a,*b; T = (TNode *)malloc(sizeof(TNode)); char theta = OPTR.top();OPTR.pop(); b = EXPT.top();EXPT.pop(); a = EXPT.top();EXPT.pop(); Tree = CreatNode(T,a,b,theta); EXPT.push(Tree); break; &#125; case '=': &#123; OPTR.pop(); cin&gt;&gt;ch; break; &#125; &#125; &#125; &#125; &#125;&#125;//计算表达式 float getvalue(char optr,float a,float b)&#123; float result ; switch(optr) &#123; case '+': &#123; result = (float)a+(float)b; break; &#125; case '-': &#123; result = (float)a-(float)b; break; &#125; case '*': &#123; result = (float)a*(float)b; break; &#125; case '/': &#123; result = (float)a/(float)b; break; &#125; &#125; return result;&#125;float calculate(TNode *T)&#123; float lvalue,rvalue; lvalue = rvalue = 0; if(T-&gt;lchild==NULL&amp;&amp;T-&gt;rchild==NULL) return T-&gt;cha - '0'; else &#123; lvalue = (float)calculate(T-&gt;lchild); rvalue = (float)calculate(T-&gt;rchild); return getvalue(T-&gt;cha,lvalue,rvalue); &#125;&#125;int main() &#123; float result; cout&lt;&lt;"请输入表达式并以'#'结尾(例如：7/(5+2)#)："&lt;&lt;endl; init_EXPT(); result = calculate(Tree); cout&lt;&lt;result&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Data-Structure</category>
      </categories>
      <tags>
        <tag>Binary_tree_calculate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[哈夫曼编码]]></title>
    <url>%2FAngelNI.github.io%2Fhaffman%2F</url>
    <content type="text"><![CDATA[我很笨，又笨又傻。 哈夫曼编码数据结构上的代码实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;string.h&gt;typedef struct&#123;unsigned int weight;unsigned int parent,lchild,rchild;&#125;HTNode,*HuffmanTree;typedef char **HuffmanCode;void Select(HuffmanTree &amp;HT,int n,int &amp;s1,int &amp;s2)&#123; for (int i = 0; i &lt; n; i++) &#123; if (HT[i].parent == 0) &#123; s1=i; break; &#125; &#125; for (int i = 0; i &lt;n; i++) &#123; if ((HT[s1].weight &gt; HT[i].weight) &amp;&amp; (HT[i].parent == 0)) &#123; s1 = i; &#125; &#125; for (int i = 0; i &lt;n; i++) &#123; if ((HT[i].parent == 0)&amp;&amp;i!=s1) &#123; s2 = i; break; &#125; &#125; for (int i = 0; i &lt;n; i++) &#123; if ((HT[s2].weight &gt; HT[i].weight) &amp;&amp; (HT[i].parent == 0) &amp;&amp; (i != s1)) &#123; s2 = i; &#125; &#125; &#125;void HuffmanCoding(HuffmanTree &amp;HT,HuffmanCode &amp;HC,int *w,int n)&#123; int i,m,s1,s2,start; char *cd; unsigned int c, f; if(n&lt;=1) return; m=2*n-1; HT=(HuffmanTree)malloc((m+1)*sizeof(HTNode)); for(i=1;i&lt;=n;i++) &#123; HT[i].weight=w[i-1]; HT[i].parent=0; HT[i].lchild=0; HT[i].rchild=0; &#125; for(i=n+1;i&lt;=m;i++) &#123; HT[i].weight=0; HT[i].parent=0; HT[i].lchild=0; HT[i].rchild=0; &#125; for (i=n+1;i&lt;=m;i++) &#123; Select(HT,i-1,s1,s2); HT[s1].parent=i; HT[s2].parent=i; HT[i].lchild=s1; HT[i].rchild=s2; HT[i].weight=HT[s1].weight+HT[s2].weight; &#125; cd=(char *)malloc(n*sizeof(char)); cd[n-1]='\0'; for(i=1;i&lt;=n;++i) &#123; start=n-1; for (c=i,f=HT[i].parent;f!=0;c=f,f=HT[f].parent) if (HT[f].lchild==c) cd[--start]='0'; else cd[--start]='1'; HC[i]=(char*)malloc((n-start)*sizeof(char)); strcpy(HC[i],&amp;cd[start]); &#125; free(cd);&#125;int main()&#123; int i,n; int *w; HuffmanTree HT; HuffmanCode HC; //汉字编码出了问题。。。。。。。 //printf("锟斤拷锟斤拷锟斤拷权值锟斤拷锟斤拷锟斤拷\n"); scanf("%d",&amp;n); w=(int *)malloc(n*sizeof(int)); //printf("锟斤拷锟斤拷锟斤拷权值锟斤拷\n"); for ( i=0;i&lt;n;i++) scanf("%d",&amp;w[i]); HC=(char **)malloc((n+1)*sizeof(char*)); HT=(HuffmanTree)malloc((2*n+1+1)*sizeof(HTNode)); HuffmanCoding(HT, HC, w, n); for(i=1;i&lt;n+1;i++) &#123; puts(HC[i]); free(HC[i]); &#125; free(HC); free(HT); return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>huffman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[非递归遍历树]]></title>
    <url>%2FAngelNI.github.io%2Ftravel-tree-1%2F</url>
    <content type="text"><![CDATA[先序非递归遍历二叉树，中序非递归遍历二叉树，后序非递归遍历二叉树及双栈法。 先序非递归遍历二叉树先序非递归遍历比较简单，感觉与DFS类似，根据先序遍历的规则根左右，先将根节点压入栈，然后遍历左子树，再遍历左子树的左子树，一头走到NULL，把每次遍历的左子树的根节点依次入栈并把当前结点数据打印出来。最后为NULL，开始回溯，返回到前一结点（也就是当前结点的根节点），开始遍历右子树。依次类推。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stack&gt;#include&lt;iostream&gt; using namespace std;struct TNode&#123; int data; TNode * rchild,*lchild;&#125;;int a[1000],b[1000];int n;//先序+中序构造二叉树TNode * Creat(int *a,int *b,int n)&#123; TNode * T; for(int i =0;i &lt; n ; ++i) &#123; if(a[0]==b[i]) &#123; T = (TNode *)malloc(sizeof(TNode)); T-&gt;data = b[i]; T-&gt;lchild = Creat(a+1,b,i); T-&gt;rchild = Creat(a+i+1,b+i+1,n-i-1); return T; &#125; &#125; return NULL;&#125;//先序非递归遍历void travel_pre(TNode * T)&#123; if(T==NULL) return; stack&lt;TNode *&gt; s; TNode * p = T; while(p!=NULL||!s.empty()) &#123; if(p!=NULL) &#123; s.push(p); cout&lt;&lt;p-&gt;data&lt;&lt;" "; p = p-&gt;lchild; &#125; else &#123; p = s.top(); s.pop(); p = p-&gt;rchild; &#125; &#125; &#125;int main()&#123; TNode * Tree; int n; while(~scanf("%d",&amp;n)) &#123; Tree = NULL; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;a[i]); &#125; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;b[i]); &#125; Tree = Creat(a,b,n); travel_pre(Tree); &#125; return 0;&#125;//测试样例//输入前三行//9//1 2 4 7 3 5 8 9 6 //先序//4 7 2 1 8 5 9 3 6 // 中序//7 4 2 8 9 5 6 3 1 // 后序 中序非递归遍历二叉树仔细看代码你会发现，先序遍历和中序遍历代码差不多，关键在于打印节点数据的位置不一样。中序和先序遍历一样，从左子树一直走到NULL，当前结点为NULL时，开始从栈中弹出栈顶元素，并把栈顶元素的数据打印出来，然后遍历右结点，因为当前结点是叶节点，没有右孩子，所以再把栈顶元素弹出，并打印出来，此时当前结点为最左叶节点的根节点，然后遍历右节点，以此类推最后栈为空，遍历完毕。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stack&gt;#include&lt;iostream&gt; using namespace std;struct TNode&#123; int data; TNode * rchild,*lchild;&#125;;int a[1000],b[1000];int n;//先序+中序构造二叉树TNode * Creat(int *a,int *b,int n)&#123; TNode * T; for(int i =0;i &lt; n ; ++i) &#123; if(a[0]==b[i]) &#123; T = (TNode *)malloc(sizeof(TNode)); T-&gt;data = b[i]; T-&gt;lchild = Creat(a+1,b,i); T-&gt;rchild = Creat(a+i+1,b+i+1,n-i-1); return T; &#125; &#125; return NULL;&#125;//中序遍历非递归void travel_in(TNode * T)&#123; if(T==NULL) return; stack&lt;TNode *&gt; s; TNode * p = T; while(p!=NULL||!s.empty()) &#123; if(p!=NULL) &#123; s.push(p); p = p-&gt;lchild; &#125; else &#123; p = s.top(); cout&lt;&lt;p-&gt;data&lt;&lt;" "; s.pop(); p = p-&gt;rchild; &#125; &#125; &#125;int main()&#123; TNode * Tree; int n; while(~scanf("%d",&amp;n)) &#123; Tree = NULL; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;a[i]); &#125; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;b[i]); &#125; Tree = Creat(a,b,n); travel_in(Tree); &#125; return 0;&#125; 后序非递归遍历二叉树及双栈法单栈法后序非递归遍历和先序中序非递归开始类似，先将左子树的左孩子的的左孩子的….每个节点压入栈。不同的是，后序遍历是走有根，有先后顺序，所以要定义一个结点变量，来记录当前结点是否被访问够。当节点为NULL时，取栈顶元素，如果当前结点的右孩子为空或者被访问过才把当前结点（根节点）打印，并作被访问记录。否则，对当前结点的右孩子遍历。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stack&gt;#include&lt;iostream&gt; using namespace std;struct TNode&#123; int data; TNode * rchild,*lchild;&#125;;int a[1000],b[1000];int n;//先序+中序构建二叉树TNode * Creat(int *a,int *b,int n)&#123; TNode * T; for(int i =0;i &lt; n ; ++i) &#123; if(a[0]==b[i]) &#123; T = (TNode *)malloc(sizeof(TNode)); T-&gt;data = b[i]; T-&gt;lchild = Creat(a+1,b,i); T-&gt;rchild = Creat(a+i+1,b+i+1,n-i-1); return T; &#125; &#125; return NULL;&#125;//后序非递归void travel_post(TNode *T)&#123; stack&lt;TNode *&gt; s; TNode * p = T; TNode *visit = NULL; while(p!=NULL||!s.empty()) &#123; while(p!=NULL) &#123; s.push(p); p = p-&gt;lchild; &#125; p = s.top(); if(p-&gt;rchild==NULL||p-&gt;rchild==visit) &#123; cout&lt;&lt;p-&gt;data&lt;&lt;" "; visit = p; s.pop(); p = NULL; &#125; else &#123; p = p-&gt;rchild; &#125; &#125;&#125;int main()&#123; TNode * Tree; int n; while(~scanf("%d",&amp;n)) &#123; Tree = NULL; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;a[i]); &#125; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;b[i]); &#125; Tree = Creat(a,b,n); travel_post(Tree); &#125; return 0;&#125; 双栈法首先将根节点p入栈1： 步骤一： 将栈1的栈顶元素赋给p，然后将p入栈2；然后先将p左结点入栈1，后将p右结点入栈1，顺序一定不能错。 步骤二：出栈2，就获得后序遍历 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stack&gt;#include&lt;iostream&gt; using namespace std;struct TNode&#123; int data; TNode * rchild,*lchild;&#125;;int a[1000],b[1000];int n;TNode * Creat(int *a,int *b,int n)&#123; TNode * T; for(int i =0;i &lt; n ; ++i) &#123; if(a[0]==b[i]) &#123; T = (TNode *)malloc(sizeof(TNode)); T-&gt;data = b[i]; T-&gt;lchild = Creat(a+1,b,i); T-&gt;rchild = Creat(a+i+1,b+i+1,n-i-1); return T; &#125; &#125; return NULL;&#125;void travel_post(TNode *T)&#123; stack&lt;TNode *&gt; s1; stack&lt;TNode *&gt; s2; TNode * p = T; s1.push(p); while(!s1.empty()) &#123; p = s1.top(); s1.pop(); s2.push(p); if(p-&gt;lchild) s1.push(p-&gt;lchild); if(p-&gt;rchild) s1.push(p-&gt;rchild); &#125; while(!s2.empty()) &#123; cout&lt;&lt;s2.top()-&gt;data&lt;&lt;" "; s2.pop(); &#125;&#125;int main()&#123; TNode * Tree; int n; while(~scanf("%d",&amp;n)) &#123; Tree = NULL; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;a[i]); &#125; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;b[i]); &#125; Tree = Creat(a,b,n); travel_post(Tree); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Data-Structure</category>
      </categories>
      <tags>
        <tag>travel-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树——构造遍历二叉树]]></title>
    <url>%2FAngelNI.github.io%2Ftravel-tree%2F</url>
    <content type="text"><![CDATA[构造二叉树，遍历二叉树，先序+中序构造二叉树后序遍历，中序+后序构造二叉树先序遍历。 构造二叉树利用二叉链表构造二叉树的每一个结点 12345typedef struct TNode&#123; char data; struct TNode *lchild,*rchild;&#125;*Tree; 先序遍历顺序建立二叉链表 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;typedef struct TNode&#123; char data; struct TNode *lchild,*rchild;&#125;TNode,*Tree;void Create(TNode *T)&#123; char ch; scanf("%c",&amp;ch); if(ch=='#') *T=NULL; else &#123; T=(TNode *)malloc(sizeof(TNode)); if(!*T) exit(-1); T-&gt;data=ch; Create(T-&gt;lchild); Create(T-&gt;rchild); &#125;&#125;int main()&#123; TNode *T; printf("输入树(#代表空节点):"); Create(T); //我是省略号//&#125; 遍历二叉树123456789101112131415161718192021222324252627//二叉树的先序遍历//void travel_pre(TNode T)&#123; if(T==NULL) return ; printf("%c ",T-&gt;data); travel_pre(T-&gt;lchild); travel_pre(T-&gt;rchild);&#125;//二叉树的中序遍历//void travel_in(TNode T)&#123; if(T==NULL) return ; travel_in(T-&gt;lchild); printf("%C ",T-&gt;data); travel_in(T-&gt;rchild);&#125;//二叉树的后序遍历//void travel_post(TNode T)&#123; if(T==NULL) return; travel_post(T-&gt;lchild); travel_post(T-&gt;rchild); printf("%c ",T-&gt;data);&#125; 先序+中序构造二叉树根据先序和中序遍历结果还原二叉树基础理论比较好理解，多做几道这些类似的题，也能孰能生巧。关键之处，还是在于代码实现。 这是一道OJ题，请移步HDU1710 因为还原二叉树是一个递归的问题，将复杂地问题简化为一个个小问题，所以就拿三个结点的二叉树举栗。 先序：ABC； 中序：BAC； 我们都知道先序遍历是根左右，而中序遍历是左根右，我们可以通过先序找到根节点，根据中序中根节点的位置，就可以找到根节点的左子树（左孩子），和右子树（右孩子）；根据这个规则就可以还原一颗二叉树了。 例如下面的例子。 不难发现根节点是A，那么中序中的1k就为左子树，k尾就为右子树。同理，先序中pre+1pre+k为左子树，pre+k+1尾为右子树。其他以此类推。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;struct TNode&#123; int data; TNode * lchild,* rchild;&#125;*Tree;int a[1000],b[1000];int n;//代码的核心之处//TNode * Creat(int *a,int *b,int n)&#123; TNode * T; for(int i =0;i &lt; n ; ++i) &#123; if(a[0]==b[i]) &#123; T = (TNode *)malloc(sizeof(TNode)); T-&gt;data = b[i]; T-&gt;lchild = Creat(a+1,b,i); T-&gt;rchild = Creat(a+i+1,b+i+1,n-i-1); return T; &#125; &#125; return NULL;&#125;//后序遍历二叉树void travel_post(TNode *R)&#123; if(R!=NULL) &#123; travel_post(R-&gt;lchild); travel_post(R-&gt;rchild); if(R==Tree) &#123; printf("%d\n",R-&gt;data); &#125; else&#123; printf("%d ",R-&gt;data); &#125; &#125;&#125;int main()&#123; int n; while(~scanf("%d",&amp;n)) &#123; Tree = NULL; //先序 for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;a[i]); &#125; //中序 for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;b[i]); &#125; Tree = Creat(a,b,n); travel_post(Tree); &#125; return 0;&#125; 中序+后序构造二叉树中序+后序构造二叉树和先序+中序构造二叉树类似，关键之处在于，找到每个二叉结点的根，左孩子，右孩子的位置，然后递归就可以了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;struct TNode&#123; int data; TNode *lchild,*rchild;&#125;*Tree;int a[1000],b[1000];int n;//核心区TNode * Creat(int *a,int *b,int n)&#123; TNode * T; T = (TNode *)malloc(sizeof(TNode)); if(n&lt;=0) return NULL; else &#123; T-&gt;data = b[n-1]; int * p; for(p = a;p&lt;a+n;p++) &#123; if(*p==b[n-1]) break; &#125; int t = p-a; T-&gt;lchild = Creat(a,b,t); T-&gt;rchild = Creat(a+t+1,b+t,n-t-1); return T; &#125;&#125;//先序遍历void travel_pre(TNode * R)&#123; if(R!=NULL) &#123; if(R==Tree) printf("%d",R-&gt;data); else printf(" %d",R-&gt;data); travel_pre(R-&gt;lchild); travel_pre(R-&gt;rchild); &#125;&#125;int main()&#123; while(~scanf("%d",&amp;n)) &#123; Tree =NULL; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;a[i]); &#125; for(int i =0;i&lt;n;++i) &#123; scanf("%d",&amp;b[i]); &#125; Tree = Creat(a,b,n); travel_pre(Tree); printf("\n"); &#125; return 0;&#125;]]></content>
      <categories>
        <category>Data-Structure</category>
      </categories>
      <tags>
        <tag>travel-tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异构信息网]]></title>
    <url>%2FAngelNI.github.io%2FHIN%2F</url>
    <content type="text"><![CDATA[攒下所有梦见你的瞬间，够不够换见你一面。 知识图谱定义知识图谱：是结构化的语义知识库，用于迅速描述物理世界中的概念及其相互关系。 知识图谱通过对错综复杂的文档的数据进行有效的加工、处理、整合，转化为简单、清晰的“实体,关系,实体”的三元组，最后聚合大量知识，从而实现知识的快速响应和推理。 知识图谱有自顶向下和自底向上两种构建方式。所谓自顶向下构建是借助百科类网站等结构化数据源，从高质量数据中提取本体和模式信息，加入到知识库中；所谓自底向上构建，则是借助一定的技术手段，从公开采集的数据中提取出资源模式，选择其中置信度较高的新模式，经人工审核之后，加入到知识库中。 异构信息网(HIN)信息网络(Information Network)信息网络是带有对象类型映射ϕ: V → A和链接映射ψ: E → R的有向图G=(V,E)。每个对象v∈V属于某一个特定对象类型φ（v）∈A，且每个链接e∈E属于关系类型集合R：ψ（e）∈R中的特定关系类型。 如果两个链接属于相同的关系类型，这两个链接共享相同的起始对象类型以及结束对象类。 异构/同构信息网络(Heterogeneous/homogeneous information Network)如果|A| &gt; 1 或者 |R| &gt; 1 ，则该信息网络为异构信息网络，或简称为异构网络，否则为同构网络。 比如下面的例子： 网络模式(Network schema)异构信息网络（G = (V, E)with ϕ(v) ∈ A 并且 ψ(e) ∈ R）的network schema TG = (A, R)，要指定objects和links的类型约束，就是这种约束使得异构网络变为半结构化。 定义为：TG=(A,R)，是信息网络 G=(V, E)的一种 meta模板，这个信息网络有一个object类型映射函数 ϕ:V→A 和 link 类型映射函数ψ:E→R。信息网络G是一个定义在object类型A上的有向图，并且边是R 中的relation。 元路径(Meta path)Meta Path P定义在 network schema TG=(A,R)上，具体形式为 元图(Meta graph)相比于元路径，元图能够捕捉更复杂地关系 网络模式(Network schema)的子图]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>HIN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markov-Chain]]></title>
    <url>%2FAngelNI.github.io%2FMarkov-Chain%2F</url>
    <content type="text"><![CDATA[世界让我遍体鳞伤，但伤口长出的却是翅膀。 马尔可夫链（Markov Chain）马尔可夫链（Markov Chain），又称为离散时间马尔可夫链，可以定义为一个随机过程Y，在某时间t上的任何一个点的值仅仅依赖于在时间t-1上的值。这就表示了我们的随机过程在时间t上具有状态x的概率，如果给出它之前所有的状态，那么就相当于在仅给出它在时间t-1的状态的时候，在时间t上具有状态x的概率。 如果可能的状态集S是有限的，那么，我们可以提供马尔可夫链的可视化表示结果，如下图所示： 上图中的每个圆圈都代表了一个状态，在这种情况下S={A, B, C}，而箭头则表示过程从一个状态跳到另一个状态的概率。我们可以在一个称为“转移矩阵”P中收集所有的这些概率数据，如下图所示： 那么，就有: 然后，在每个时间点上，我们可以描述过程的（无条件的）概率分布，这将是一个向量，其分量数等于S的维数。每个分量表示我们的过程取值等于给定状态的无条件概率。也就是: 关于上式中变量μ的比较有趣的性质是，它会通过以下等式的关系与转移矩阵相关联: 因此，一旦我们有了向量的已知初始值（这是可以理解的，因为我们是从一个可观察的状态开始的，因此将有一个包含多个0的向量，但在初始状态的位置上只有一个0），这样就可以计算过程在任何时间点上的分布了。 与此同时，我们的向量有一个特定的值，以使下面这个等式成立： 如果存在如上所述的一个值，我们将相应的变量μ称为过程的不变分布。 在讨论马尔可夫链蒙特卡罗（MCMC）方法的时候，不变分布是一个关键的概念。它包括一类从概率分布中抽样的算法，这个概率分布构造了一个马尔可夫链，而这个马尔可夫链则希望把这个分布作为它的不变分布。 事实上，蒙特卡罗方法的目标是要从不易抽样的分布中找到抽样的方法。要绕过这个问题，我们已有了一些方法，如拒绝抽样和重要性抽样等等，它们使用了一个更简单的函数，称为“proposal” 让我们模拟一个马尔可夫链，现在，考虑一个变量，今天的状态可能只取决于昨天的状态，这个变量有可能指的是天气。所以让我们考虑下面的马尔可夫链： 我们可以用以前的方法来解释上图。也就是说，如果今天是晴天，则明天也是晴天的概率是50%，而下雨的概率是15%，是多云天气的概率是35%。 另外，也有一个初始值，比如说“多云”，因此我们已经有了y的初始分布，即μ _0=[0,0,1]。 由于我们有一个初始的变量μ和一个转移矩阵，因此就可以在任意时间点t上计算μ的值。因此，有了这些之后，我想根据每个t值的概率分布来创建一个随机过程（具有马尔可夫链的属性，因此可以只依赖于前一个时间段）。 这意味着我得到的随机变量Y将会有一些等于瞬间数量的分量，而每个分量都是根据瞬间的概率分布来实现的过程。为此，我们希望从均匀分布中生成一个随机数，并设置如下规则： 附上代码 1234567891011121314151617181920212223242526import numpy as npp = np.array([[0.5,0.15,0.35], [0.45,0.45,0.1], [0.1,0.3,0.6]])Sunny = 1Rainy = 2Cloudy = 3m = np.zeros(150).reshape(50,3)m[0] = [0,0,1]ndays = 50Y = [0]*ndaysu = np.random.uniform(0,1,50)for i in range(1,ndays): m[i] = m[i-1].dot(p) if u[i]&lt;m[i][0]: Y[i] = 1 elif u[i]&lt;m[i][0]+ m[i][1]: Y[i] = 2 else: Y[1] = 3[np.mean(m[:,0]),np.mean(m[:,1]),np.mean(m[:,2])]#####################output：[0.32391901234567883, 0.28887703703703688, 0.3872039506172838]##################### 最后附上50天的天气情况]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Markov Chain</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Java]]></title>
    <url>%2FAngelNI.github.io%2Fjava%2F</url>
    <content type="text"><![CDATA[就想写个A+B，我容易吗。。。 我真的很想，很舒适的写一个大数A+B.]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PC开启上帝模式]]></title>
    <url>%2FAngelNI.github.io%2Fskill%2F</url>
    <content type="text"><![CDATA[不要让一句在等等错过了最好的机遇。 上帝模式上帝模式，即”God Mode”，或称为“完全控制面板”。是Windows 系统中隐藏的一个简单的文件夹窗口，包含了几乎所有Windows系统的设置，如控制面板的功能、界面个性化、辅助功能选项等方方面面的控制设置，用户只需通过这一个窗口就能实现所有的操控，而不必再去为调整一个小小的系统设置细想半天究竟该在什么地方去打开设置，在这里就告诉大家如何造作~ 方式一：桌面添加上帝模式1.在桌面鼠标右击选择【新建】、【文件夹】。 2.将新建的文件夹重命名为GodMode.{ED7BA470-8E54-465E-825C-99712043E01C}请使用快捷键Ctrl+C复制，然后使用快捷键Ctrl+V粘贴给刚才的文件夹重命名。 3.双击打开这个类似控制面板的图标。温馨提示：Win7系统会有【GodMode】的名字。 4.打开上帝模式界面如下，几乎包含了所有Windows系统的设置。 方式二：鼠标右键添加上帝模式1.鼠标右击【开始菜单】选择【运行】，在运行框中输入 regedit 然后点击【确定】。 2.依次展开路径至： HKEY_CLASSES_ROOT\DesktopBackground\Shell 3.点击【shell】后在右侧窗口鼠标右击选择【新建】选择【项】。 4.将新建的项重命名为【上帝模式】。 5.点击【上帝模式】后双击右侧窗口中的【默认】，在数值数据处输入【上帝模式】点击【确定】。 6.鼠标右击左侧【上帝模式】选择【新建】选择【项】 7.将新建的项命名为【command】。 8.点击【command】后双击右侧窗口中的【默认】，在数值数据处输入 explorer shell:::{ED7BA470-8E54-465E-825C-99712043E01C} 点击【确定】。 9.在桌面空白处鼠标右击，上帝模式选项已经成功添加了。 划重点： 如果需要取消鼠标右键菜单项，只需在注册表中把新建的项删除即可。]]></content>
      <categories>
        <category>sharing</category>
      </categories>
      <tags>
        <tag>Skill</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宝塔+Kodcloud搭建个人网盘]]></title>
    <url>%2FAngelNI.github.io%2Fkodcloud%2F</url>
    <content type="text"><![CDATA[月圆思故人。 KodExplorer可道云简介：KodExplorer可道云，原名芒果云，是基于Web技术的私有云和在线文件管理系统，由上海岱牧网络有限公司开发，发布于2012年6月。致力于为用户提供安全可控、可靠易用、高扩展性的私有云解决方案。用户只需通过简单环境搭建，即可使用KodExplorer快速完成私有云/私有网盘/在线文档管理系统的部署和搭建。可道云提供了类windows经典用户界面，延续了windows平台的用户界面、操作逻辑和使用习惯，支持100余种文件格式的在线预览，解决了文件在线存储与管理、共享和跨平台访问、在线办公影音娱乐等一系列问题，使得用户的私有云产品可以拥有本地操作一样方便、快捷、安全的体验。官网地址：http://www.kodcloud.com 成功安装后就可登陆正常使用了]]></content>
      <categories>
        <category>sharing</category>
      </categories>
      <tags>
        <tag>Kodcloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务器终于备案好了]]></title>
    <url>%2FAngelNI.github.io%2Fsever%2F</url>
    <content type="text"><![CDATA[已成功搭建个人网盘，个人图床，开源OJ平台。 从备案申请到备案成功，等的我好烦人啊，还好是成功备案下来。 这不正赶上周末，当然要好好造作一番了。 宝塔面板+kodexplorer搭建的个人网盘。参考 Chevereto搭建私人图床关于Chevereto的配置可以参考我们翻译的中文文档 青岛大学OJ还在探索中ing]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>serve</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2048 Game]]></title>
    <url>%2FAngelNI.github.io%2Fproblem-1%2F</url>
    <content type="text"><![CDATA[间接性划水，持续性自闭。 2048 Game题目链接 A. 2048 Game time limit per test 1 second memory limit per test 256 megabytes input standard input output standard output You are playing a variation of game 2048. Initially you have a multiset ss of nn integers. Every integer in this multiset is a power of two. You may perform any number (possibly, zero) operations with this multiset. During each operation you choose two equal integers from ss, remove them from ss and insert the number equal to their sum into ss. For example, if s={1,2,1,1,4,2,2}s={1,2,1,1,4,2,2} and you choose integers 22 and 22, then the multiset becomes {1,1,1,4,4,2}{1,1,1,4,4,2}. You win if the number 20482048 belongs to your multiset. For example, if s={1024,512,512,4}s={1024,512,512,4} you can win as follows: choose 512512 and 512512, your multiset turns into {1024,1024,4}{1024,1024,4}. Then choose 10241024 and 10241024, your multiset turns into {2048,4}{2048,4} and you win. You have to determine if you can win this game. You have to answer qq independent queries. Input The first line contains one integer qq (1≤q≤1001≤q≤100) – the number of queries. The first line of each query contains one integer nn (1≤n≤1001≤n≤100) — the number of elements in multiset. The second line of each query contains nn integers s1,s2,…,sns1,s2,…,sn (1≤si≤2291≤si≤229) — the description of the multiset. It is guaranteed that all elements of the multiset are powers of two. Output For each query print YES if it is possible to obtain the number 20482048 in your multiset, and NO otherwise. You may print every letter in any case you want (so, for example, the strings yEs, yes, Yes and YES will all be recognized as positive answer). Example input 12345678910111213641024 512 64 51212048364 512 224096 472048 2 2048 2048 2048 2048 204822048 4096 output 123456YESYESNONOYESYES Note In the first query you can win as follows: choose 512512 and 512512, and ss turns into {1024,64,1024}{1024,64,1024}. Then choose 10241024 and 10241024, and ssturns into {2048,64}{2048,64} and you win. In the second query ss contains 20482048 initially. 这道题和我们玩得游戏2048一样，只要你能够凑出2048，you win！！！ 一开始，没有想那多,就是想直接模拟一下。 AC_112345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;algorithm&gt;using namespace std;int a[1010];bool cmp(int a,int b)&#123; return a&gt;b; &#125; int main()&#123; int n; scanf("%d",&amp;n); while(n--) &#123; int m,flag=0; scanf("%d",&amp;m); for(int i=0;i&lt;m;++i) &#123; scanf("%d",&amp;a[i]); &#125; sort(a,a+m,cmp); int k =2048; int sum=0; for(int i =0;i&lt;m;++i) &#123; if(k&gt;=a[i]&amp;&amp;k%a[i]==0) &#123; sum += a[i]; &#125; if(k == sum) &#123; flag = 1; break; &#125; &#125; if(flag==1) printf("YES\n"); else printf("NO\n"); &#125; return 0; &#125; AC_2之后有人跟我说，这是分治，我也没听懂他在说什么，就去了CSDN，找了教程。 分治：原来就是把问题划分为相互独立的子问题进行处理。（必然联系到递归） 比如，你想找是否有没有2048，此时把2048分成1024 1024，你可以找1024，然后看看集合中有几个1024，是否满足条件。 1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;//int a[100005];map&lt;int,int&gt; mp;int dfs(int x,int n)&#123; if(x&lt;1) return 0; if(mp[x] &gt;= n) return 1; return dfs(x/2,n*2-2*mp[x]);&#125;int main()&#123; int n; cin&gt;&gt;n; while(n--) &#123; mp.clear(); int m; cin&gt;&gt;m; for(int i =0;i&lt;m;++i) &#123; int s; cin&gt;&gt;s; mp[s]++; &#125; int flag = dfs(2048,1); if(flag) printf("YES\n"); else printf("NO\n"); &#125; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活随笔]]></title>
    <url>%2FAngelNI.github.io%2Flife-essay%2F</url>
    <content type="text"><![CDATA[这是你自己的选择，别谢我。 这是你自己的选择，别谢我。”恐怕，这句话很难忘记了~“ 今天排队打卡，排了很长的队伍，堪称壮观，我一开始排在签字的队伍（我带卡了），不过很慢，很慢，旁边的打卡的队伍移动的很快，之后看到原班的同学，见其就插到了他前边，我不好意思的说声谢谢，他说“这是你自己的选择，别谢我。”我想瞬间僵住了，内心愧疚感一发不可收拾，他怎么能说出折磨精辟的话。 不过这真是的，无论是自己选择插队，还是更风别人，终归到底还是你自己的选择。生活就是选择，不断选择，重复选择的过程，最后的结果都是由你自己决定，甜苹果还是烂苹果，都是你自己种下的果~ 记录：10/11/2019]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 操作命令总结]]></title>
    <url>%2FAngelNI.github.io%2Flinux-1%2F</url>
    <content type="text"><![CDATA[前进的时候千万不要忘记自我反思 ，它会让你走的更远。 Linux 命令总结Linux一些介绍1.Linux与windows的区别Linux是一款操作系统。通常开发服务器项目部署都是在Linux操作系统上。 Windows一款操作系统，大多数人使用的操作系统。 2.Linux历史及使用场景Linux 90年代诞生，仿制Unix操作系统。 Linux是免费、开源的 Unix收费、封闭的。 Linux使用场景：服务器操作系统（比如我正在备案中的阿里云），移动设备（安卓手机，平板），路由器（WIFI），交换机，智能家居，JAVA程序开发。 3.Linux版本Linnux版本分为两种：内核版本(https://www.kernel.org/)和发行版本 Linux内核版本：Linux内核运营开发小组。源码一定程度上不是开源的。 Linux发行版本：有各大互联网/软件公司定制。外围的样式功能的代码完全开源。 一个内核版本是有多种多样的发行版本。 Ubuntu：以强大的桌面应用为主，使用的Linux版本就是Ubuntu，自己主要用于Linux学习和深度学习，程序运行。 等等许多~~ 常用命令Linux命令中参数，一般都是无序的。特殊情况下除外 注意：Linux中的命令严格区分大小写的！ 3.1、磁盘管理命令1.ls 列出目录内容ls（list）功能：列出目录内容 2.格式： 123456789ls [参数] [文件或目录]# 参数-a或--all 查询所有文件和文件夹，包含隐藏。注意隐藏文件、特殊目录、. 和 ..-l 查询详细列表 ls -l--&gt;简写：ll-h 友好展示信息 ll -h (d目录，-普通文件, l链接) -t 用文件和目录的更改时间排序。-r 反向排序--help 在线帮助 3.常用 123ls -l --&gt; 此命令非常常用，提供简化版命令 llls -alll /home/ --&gt; 显示指定目录下的内容 4.eg 1234需求：展示某个目录下的内容 ls 目录名所在位置：/root想要查看:/etc目录下的内容命令：ll -h /etc cd 切换目录1.cd(change directory) 功能：切换目录 2.语法 1234567891011# 格式cd [目录]# 常用cd /目录名 ，任意目录切换到指定目录中 /目录名--&gt;Linux的绝对路径 windows绝对路径--&gt;c:/xxxx/xxx.jpg?raw=truecd ../ ，向上一层目录cd ~ ，切换到当前用户 家目录。root用户家目录 /rootcd / ，切换到Linux的 根目录cd - ，切换到上一次访问的目录。 只能两个目录相互切换cd .. ，上一级目录cd ，缺省当前用户目录 Linux绝对：eg：cd /etc/x1 先切换到 /目录，然后在 /目录 中找到子目录 etc，在 etc 中找 子目录x1特点：在任意目录都可以随意切换 Linux相对：eg：cd x1/x2 在当前目录中寻找子目录x1, 在x1中寻找子目录x2特点：必须确定 当前目录 下有子目录x1 pwd 显示当前所在目录 pwd(print working directory) 功能：显示工作目录(当前的所在目录)。返回绝对路径 mkdir常见目录1.mkdir（make directority）功能：创建目录 2.语法 12345# 格式mkdir -p 文件夹名称# 参数-p 父目录不存在情况下先生成父目录 （parents）-v 显示命令执行过程中的详细信息 3.注意 使用mkdir创建带后缀的文件时，创建的是目录，不是文件（创建文件使用touch命令） 4.其他 12345678910# 1需要在/root/t1目录下创建一个t2目录位置：/root命令：相对路径：mkdir t1/t2绝对：mkdir /root/t1/t2# 2需要在/root/t3目录下创建一个t4目录位置：/root条件：t3和t4都不存在命令：mkdir -p t3/t4 rmdir删除空目录 rmdir(remove directory) 功能：删除空目录 指令快捷键1.历史输入使用上、下箭头可以找出上一条指令和下一条指令 2.Tab代码补全使用tab键可以快速输入指令比如：我要输入shutdown指令，这时，我们可以只输入shut然后按下tab键，即可自动把shutdown补全 注意：使用两下Tab补全时，如果匹配的结果有多个，这时候将会把所有匹配的结果展示出来。 3.2、文件浏览(管理)命令日志文件,XML,properties文件 cat 快捷查看当前文件的内容1.cat（catenate）功能：快捷查看当前文件的内容cat适合查看少量信息的文件 2.语法 12# 格式cat 文件名 more 分页显示文件内容1.more功能：分页显示文件内容，还支持直接跳转行等功能2.语法： 1more 文件名 3.操作 1234Enter 向下n行，需要定义。默认为1行空格键 向下滚动一屏 或 Ctrl+FB 返回上一屏 或 Ctrl+Bq 退出more less 分页显示文件内容1.less功能：分页显示文件内容，操作更详细 2.语法： 12345# 格式less -mN 文件名 # 参数-m 显示类似more命令的百分比-N 显示每行的行号 3.操作 12345678910111213Enter 向下n行，需要定义。默认为1行空格键 向下滚动一屏 或 Ctrl+F B 返回上一屏 或 Ctrl+B q 退出more d 前进半页 u 后退半页回车键 前进一行 或 方向键向下 y 后退一行 或 方向键向上 v 进入vim编辑器/字符串 向下搜索?字符串 向上搜索左右方向键 相当于水平滚动条 4.特点： 适用于大量数据的查看 tail 指定文件末尾内容1.用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件 2.语法 12345# 格式tail[必要参数][选择参数][文件]# 参数-n&lt;行数&gt; 显示行数-f 循环读取 3.3、文件操作命令文件1.隐藏文件Linux中以 点. 开头的是隐藏文件，使用ls命令是查看不到的，需使用ls -a 2.目录与文件的区别当我们使用ls命令列出目录中的所有子目录和文件时，如何区分哪些是文件哪些是目录？可以通过详细信息中第一列的信息来区分：以 d 开头的是目录，以 - 开头的是文件 touch创建文件1.功能：创建文件 2.语法： 1touch 绝对路径/相对路径 cp复制1.cp（copy）：复制文件或者复制目录 2.复制文件： 1cp 需要复制的文件 复制的位置 注意：cp可以进行重命名操作 12345678需求：把/root/Demo1.java文件 复制到 /root/t1 目录中位置：/root命令：cp Demo1.java t1 cp /root/Demo1.java /root/t1 需求：把/root/Demo1.java文件 复制到 /root/t1 目录中，改名为ddd.java位置：/root命令：cp Demo1.java t1/ddd.java 3.复制目录 语法： 1234# 格式cp -r 需要复制的目录 复制的位置# 参数-r或--recursive 递归处理，将指定目录下的文件与子目录一并处理 复制目录必须使用-r 1234567需求：把/root/t5目录 复制到 /root/t1目录中位置：/root命令：cp -r t5 t1 cp -r /root/t5 /root/t1 cp ./abc ./xxx #无法复制目录cp -r ./abc ./xxx #复制目录必须使用 -r参数 mv 移动、更名1.mv(move) 功能： 移动 或 更名 现有的文件或目录 2.移动文件： 语法 1234# 格式mv -f 需要移动的文件 移动的位置# 参数-f或--force 若目标文件或目录与现有的文件或目录重复，则直接覆盖现有的文件或目录，不进行询问 eg： 123456789需求：把/root/t5 目录 移动到 /root/t3目录中位置：/root命令：mv t5 t3 需求：把/root/t5 目录 移动到 /root/t3目录中 不询问，直接覆盖位置：/root已知：/root/t3目录中 已经有一个t5目录了命令：mv -f t5 t3 3.文件更名： 格式： 12mv 需要移动的文件 新名字## 必须是在同一目录中进行此操作 eg： 1234文件/目录更名操作：需求：把/root/Demo1.java 改名为 hehe.java位置：/root命令：mv Demo1.java hehe.java rm删除1.rm(remove) 功能：删除文件或目录 2.删除文件： 语法： 1rm 文件名 3.删除目录： 语法： 12345# 格式rm -rf 目录名# 参数-f或--force 强制删除文件或目录，不进行询问-r或-R或--recursive 递归处理，将指定目录下的所有文件及子目录一并处理。删除目录必须使用-r 4.注意 12rm -rf * 删除 当前目录 下所有内容rm –rf /* 删除Linux系统 根目录 下所有内容 5.eg 1234需求：删除/root/t5 目录， 位置：/root已知：t5目录下有子目录或者文件命令：rm -rf t5 find 查找1.find功能：查找文件或目录 2.语法： 1234find 目录名 -name &apos;需要查找的字符串&apos; -name 指定字符串作为寻找文件或目录的范本样式* 表示0~多个任意字符 eg：find t1 -name &apos;*.txt&apos; 3.eg 123需求：查找/root目录下 所有以ins开头的文件或者目录位置：/root命令：find /root -name &apos;ins*&apos; 3.4、文档编辑命令Windows是有记事本Linux也有类似的记事本功能 VIM编辑器 VI 编辑1.操作： 输入 vi 文件名 进入 “命令(一般)模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 vim命令1.操作 输入 vim 文件名 或 vi 文件名 进入 “一般模式” 按下 “i” 从一般模式，进入“插入模式” 按下 “esc” 从“插入模式”退出到“一般模式” 在“一般模式”下，输入 “:wq”，退出编辑 2. 一般(命令)模式: 可以浏览文件内容，可以进行文本快捷操作（单行复制，多行复制，单行删除，多行删除…） 按 i/a/o 可以切换到 插入模式按 : 可以切换到 底行模式 插入模式： 可以编辑文件内容。 按 ESC 可以切回 一般模式 底行模式： 可以进行强制退出不保存操作 q! 可以进行保存并退出操作 wq 3.5、压缩、解压命令【重要】Linux常见压缩包： .tar 打包，大小不会进行压缩 .tar.gz 打包并压缩文件大小 2.压缩：（参数顺序不变） 1234567# 格式tar -zcvf 压缩包名字.tar.gz 需要压缩的内容# 参数-z 是否需要用 gzip 压缩-c 建立一个压缩文件的参数指令（create）--压缩-v 压缩的过程中显示文件（verbose）-f 使用档案名称，在 f 之后要立即接档名（file） eg： 1例如：tar -zcvf hehe.tar.gz * 将当前目录下所有内容进行打包压缩，文件名hehe.tar.gz 3.解压（参数顺序不变） 123456789# 解压到当前目录tar -zxvf 需要解压的压缩包名称 解压到当前目录# 解压到指定目录tar -zxvf 需要解压的压缩包名称 -C 指定压缩路径 解压到指定目录中# 参数-z 是否需要用 gzip 压缩-x 解开一个压缩文件的参数指令（extract）--解压-v 压缩的过程中显示文件（verbose）-f 使用档名，在 f 之后要立即接档名（file） eg： 1234需求：需要把/root/t5/hehe.tar.gz 压缩包 解压到 指定目录中。指定目录/root/t5/t5位置：/root/t5命令：tar -zxvf hehe.tar.gz -C /root/t5/t5tar -zxvf hehe.tar.gz -C t5 3.6、系统命令系统服务服务，是指常期运行，常驻内存中的进程，比如，apache、mysql、ssh等。 服务与端口 每个服务软件一般在运行时都会对应一个端口。查看监听的端口： 1ss –lntp 查看同进程：ps -ef12345需求：查看进程中 和 vim相关的进程命令：ps -ef|grep -i vim -e 此参数的效果和指定&quot;A&quot;参数相同，显示所有程序-f 显示UID,PPIP,C与STIME栏位 强制杀死某个进程：kill -9 pid号123456需求：查看进程 和 vim相关的进程有哪些，并将vim进程杀死命令：ps -ef|grep -i vim Kill -9 pid号 -l &lt;信息编号&gt; 若不加&lt;信息编号&gt;选项，则-l参数会列出全部的信息名称kill 9 表示强制终止 查看网络配置：ifconfig 显示网络设备 测试和目标的连通性：ping 主机名或ip地址 测试与目标主机的连通性 会持续不断一直测试，直到ctrl+c Linux centos重启命令：reboot Linux centos关机命令：halt]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu_基础应用篇]]></title>
    <url>%2FAngelNI.github.io%2Fubuntu-beauty%2F</url>
    <content type="text"><![CDATA[【转载】分享给那些喜欢Linux ，喜欢Ubuntu的小伙伴。 此文章为转载文章，转载请著名出处 @http://blog.csdn.net/gatieme非常感谢原作者的分享和AderStep对这些美味食物的整理。 链接 链接 安装Ubuntu后必须要做的几件事(一)–基础应用篇 安装Ubuntu后必须要做的几件事（二）–开发工具篇 终端的乐趣–Linux下有趣的终端命令或者工具 Ubuntu使用apt-file解决库或者文件缺失依赖 Ubuntu切换默认sh为bash或者dash Linux下几款C++程序中的内存泄露检查工具 解决ubuntu无法调整和保存屏幕亮度的问题 Ubuntu安装Microsoft Windows Fonts微软字体库 解决Windows与Ubuntu双系统时间同步问题 Ubuntu安装图片处理工具GIMP及其插件 21款最佳Linux命令行终端工具 两台Linux系统之间传输文件的几种方法 使用gdb调试程序完全教程 linux下man手册的安装和使用 Linux下查看并下载命令源码包（根据命令/应用程序逆向获取并且安装其所属源码包） 如何参与linux内核开发 linux 如何显示一个文件的某几行(中间几行) Git中的AutoCRLF与SafeCRLF换行符问题 linux环境中英文切换配置以及乱码问题 linux下使用ccat让你的cat高亮显示 怎么判断你的linux系统是不是运行在虚拟机器上面 Linux下管理用户的命令大全 Linux软连接和硬链接 Linux性能测试工具-UnixBench–安装以及结果分析 CodeBlocks最全官方配色方案 C/C++log日志库比较 Centos5.x/Linux下升级python到python2.7版本教程 几款xshell绝佳配色方案 VS2012插件推荐 linux下的终端利器—-tmux Ubuntu下Sublime Text 3解决无法输入中文的方法 使用trash-cli避免误删文件–为rm增加回收站功能 Ubuntu安装Python的包管理工具Pip Ubuntu安装配置串口通讯工具minicom&amp;&amp;cutecom Ubuntu编译安装llvm-clang 搜索引擎收录大全 Ubuntu安装深度音乐&amp;&amp;深度影音 Vimium-Geek是这样上网的[Chrome–插件] 几款好的markdown编辑器 Windows&amp;&amp;Linux双系统引导项修复问题汇总 安装CentOS时误将将引导项写入U盘后的修复 Linux操作系统中，.zip、.tar、.tar.gz、.tar.bz2、.tar.xz、.jar、*.7z等格式的压缩与解压 Chrome浏览器护眼插件 Google搜索技巧终极收集 世界上最神奇的网站收录–不是最无聊就是最有意思 Python模块之命令行解析工具-argparse GNOME下设置应用程序图标 git 删除右键菜单项 个性化您的Ubuntu Linux终端 Python判断当前操作系统类型以及os/sys/platform模块简介 Python实现设置终端显示颜色、粗体、下划线等效果 Python程序在Windows终端乱码解决方法 发现的更强大的vim配置信息 Ubuntu禁止mysql开机启动 Ubuntu下使用sysv-rc-conf管理服务 使用Vundle管理Vim插件 Vim的安装与配置 push到github时，每次都要输入用户名和密码的问题 Ubuntu安装配置mysql 盘点Linux下的开源云平台&amp;&amp;云存储服务 Ubuntu下安装GTK库 Linux下查看系统信息命令 Ubuntu更新软件源 linux命令行界面（CLI）浏览器 Linux下使用unzip解压缩中文乱码问题 Linux下的下载工具介绍—-aria2 vim 树形目录插件NERDTree安装 urllib2模块之异常处理 Python第三方库 Sublime text 3设置用用空格替换tab键 几款好的C/C++编译器（编译器而非IDE） Sublime Text 3配置Windows下C/C++编译环境 Sublime Text[崇高文本]—-最性感的编辑器（程序员必备） WingIDE安装和破解（Python开发利器） Linux设置nfs共享目录 让你的python程序开机自启动 Linux环境设置 喜欢linux的小伙伴快来，加入这个有趣的生态圈。]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双栈实现计算器]]></title>
    <url>%2FAngelNI.github.io%2Fdata-structure%2F</url>
    <content type="text"><![CDATA[愿我们能与最好的自己相遇。 双栈实现计算器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include&lt;iostream&gt;#include&lt;stack&gt;#include&lt;cstring&gt;using namespace std;stack&lt;int&gt; OPND;stack&lt;char&gt; OPRT;int precede(char x);void operate();int calculate(string s);int main()&#123; string str; printf("\t\t--------------------------------------------\n"); printf("\t\t--------------双栈实现简易计算器------------\n"); printf("\t\t------------------欢迎您使用----------------\n"); printf("\t\t| 计算器 |\n"); printf("\t\t| ---------------- |\n"); printf("\t\t| | | |\n"); printf("\t\t| ---------------- |\n"); printf("\t\t| 1 2 3 + |\n"); printf("\t\t| 4 5 6 - |\n"); printf("\t\t| 7 8 9 * |\n"); printf("\t\t| 0 （ ） / |\n"); printf("\t\t--------------------------------------------\n"); printf("\t\t 请输入一个用#开头和结尾的表达式：\n"); cin&gt;&gt;str; calculate(str); getchar(); getchar(); return 0;&#125;//运算符优先级判断 int precede(char x)&#123; if (x == '+' || x == '-') return 0; else if (x == '*' || x == '/') return 1; else if (x == '(' || x == ')') return -1; else if (x == '#') return -2; &#125;//二元运算 inline void operate(char top) &#123; int a = OPND.top(); OPND.pop(); int b = OPND.top(); OPND.pop(); int c; if (top == '+') &#123; b += a; OPND.push(b); &#125; else if (top == '-') &#123; b -= a; OPND.push(b); &#125; else if (top == '*') &#123; b *= a; OPND.push(b); &#125; else if (top == '/') &#123; b /= a; OPND.push(b); &#125; &#125;//读取表达式 int calculate(string s)&#123; int a,b; char top; for(int i = 0;i&lt;s.size();++i) &#123; //判断是否为数字 if(isdigit(s[i])) &#123; int num = 0; string number; number += s[i]; while(isdigit(s[++i])) &#123; number += s[i]; &#125; for( int j=0;j&lt;number.size();j++) &#123; num = num*10 +number[j] - 48; &#125; OPND.push(num); number.clear(); &#125; //对操作符的操作 if(!isdigit(s[i])) &#123; if(OPRT.empty()) &#123; OPRT.push(s[i]); &#125; else &#123; top = OPRT.top(); if(precede(s[i])&gt;precede(top) || s[i] == '(') &#123; OPRT.push(s[i]); &#125; else &#123; while(precede(s[i])&lt;=precede(top)) &#123; if(top=='#'&amp;&amp;s[i]=='#') &#123; OPRT.pop(); int ans = OPND.top(); cout&lt;&lt;"The answer is :"&lt;&lt;ans&lt;&lt;endl; OPND.pop(); return 0; &#125; else if(top=='('&amp;&amp;s[i]==')') &#123; ++i; &#125; else &#123; operate(top); &#125; OPRT.pop(); top = OPRT.top(); &#125; OPRT.push(s[i]); &#125; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Data-Structure</category>
      </categories>
      <tags>
        <tag>stack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsDelivr+Github建立免费CDN]]></title>
    <url>%2FAngelNI.github.io%2FjsDelivr-Github%2F</url>
    <content type="text"><![CDATA[我喜欢你。 1.CDNCDN的全称是Content Delivery Network，即内容分发网络。CDN是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN的关键技术主要有内容存储和分发技术。——百度百科 放在Github的资源在国内加载速度比较慢，因此需要使用CDN加速来优化网站打开速度，jsDelivr + Github便是免费且好用的CDN，非常适合博客网站使用。 2.步骤方法1.新建github仓库 2.克隆Github仓库到本地点击 Clone or download，一键复制仓库地址 3.上传资源可参考这边博客https://angelni.github.io/AngelNI.github.io/untitled/ 4.发布仓库 自定义发布版本号 5、通过jsDelivr引用资源使用方法：https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名@发布的版本号/文件路径 希望这篇博客对您有帮助~]]></content>
      <categories>
        <category>jsDelivr+Github</category>
      </categories>
      <tags>
        <tag>CDN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My-World]]></title>
    <url>%2FAngelNI.github.io%2FMy-World%2F</url>
    <content type="text"><![CDATA[我叫MC~~ 最近喜欢上玩我的世界，有没有一起的。 光影，不敢开，我怕我的显卡被拎去烤鸡蛋，以至于自己搭的和想象中的有点不一样，emmm，就那么一点点点。]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>MC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[termux]]></title>
    <url>%2FAngelNI.github.io%2Ftermux%2F</url>
    <content type="text"><![CDATA[快到我的碗里来，不，是怀里。 termux分享一个超好用的手机命令行高级终端软件termux，强大的安卓手机渗透工具，没有之一。 termux是一个Android下一个高级的终端模拟器,开源且不需要root,支持apt管理软件包，十分方便安装软件包,完美支持Python,PHP,Ruby,Go,Nodejs,MySQL等。随着智能设备的普及和性能的不断提升，如今的手机、平板等的硬件标准已达到了初级桌面计算机的硬件标准,用心去打造完全可以把手机变成一个强大的工具. 官网 Github项目地址 Google Play下载地址 如果想你学习linux基本操作指令，不想通过费事的虚拟机，那就请选择termux； 如果你想简单而快速链接服务器，轻巧的使用openssh，请毫不犹豫的选择termux； 如果你想成为一个黑客，正愁缺少工具，那就立刻马上选择termux，为您提供nmap端口扫描，hydra密码暴力破解，SQLmap漏洞检测及注入等必备的工具。 在当今智能手机快速发展的今天，手机已经逐渐实现了电脑的许多功能，有没有想过在手机上搭建hexo博客，发表博文，有没有想过用手机去运行AI程序，是不是更不敢想利用手机网络渗透了。这一切都已经在手机上已经实现，你没有听错。在我看来，一个更便捷的世界即将到来，到那时也许连拿笔记本电脑都觉得费事，所有的一切通过手机和ipad就可以实现你想要的效果。 否恩和艾派德的完美组合值得期待。 最后在这里推荐一篇非常好的博文减少termux 的使用教程及我的一些操作截图。 termux使用教程]]></content>
      <categories>
        <category>sharing</category>
      </categories>
      <tags>
        <tag>termux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git远程操作仓库]]></title>
    <url>%2FAngelNI.github.io%2Funtitled%2F</url>
    <content type="text"><![CDATA[如果我在勇敢点，结果会不会比想象中的要好。 Git是一个开源的分布式版本控制系统，分布式相比集中式的最大区别是Git没有“中央服务器”，每位开发者都可以通过克隆（git clone）远程库，在本地机器上存储一个完整的Git仓库，还可以把代码的修改提交到本地库。当然了，本地库修改完成后也可以上传到远程仓库，操作方便。 在学习git的操作方法，总是偶然的上传成功。这次不一样了，向大家介绍每一步的操作流程和成功案例。 git clone + “要克隆的仓库地址链接” 克隆之后对仓库文件进行处理，添加或删除，修改或重写。 进入以克隆的文件夹，并执行 git init初始化 git add * 将所有文件添加到缓存 git pull + “文件储存的绝对路径” git commit -m +”备注” git remote add “备注” +”仓库链接（也是克隆的链接地址）” 最后，git push 静静等待，操作成功。 如果你顺利完成了以上步骤，那么就要恭喜你了，已经成功上传到github仓库。其他储存仓库操作步骤类似。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实现汉诺塔移动可视化]]></title>
    <url>%2FAngelNI.github.io%2Fhanoi%2F</url>
    <content type="text"><![CDATA[想来一趟说走就走的旅行，没有手机，没有联系方式，独身一人，目标——你在的地方。 之前老师在课堂上展示了用C实现汉诺塔的可视化移动过程，觉得挺好玩的，下面就让你看看Python是如何实现的，放图。 好了，下面就是实现的代码了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import turtle class Stack: def __init__(self): self.items = [] def isEmpty(self): return len(self.items) == 0 def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): if not self.isEmpty(): return self.items[len(self.items) - 1] def size(self): return len(self.items)def drawpole_3():#画出汉诺塔的poles t = turtle.Turtle() t.hideturtle() def drawpole_1(k): t.up() t.pensize(10) t.speed(100) t.goto(400*(k-1), 100) t.down() t.goto(400*(k-1), -100) t.goto(400*(k-1)-20, -100) t.goto(400*(k-1)+20, -100) drawpole_1(0)#画出汉诺塔的poles[0] drawpole_1(1)#画出汉诺塔的poles[1] drawpole_1(2)#画出汉诺塔的poles[2]def creat_plates(n):#制造n个盘子 plates=[turtle.Turtle() for i in range(n)] for i in range(n): plates[i].up() plates[i].hideturtle() plates[i].shape("square") plates[i].color("blue") plates[i].shapesize(1,8-i) plates[i].goto(-400,-90+20*i) plates[i].showturtle() return plates def pole_stack():#制造poles的栈 poles=[Stack() for i in range(3)] return poles def moveDisk(plates,poles,fp,tp):#把poles[fp]顶端的盘子plates[mov]从poles[fp]移到poles[tp] mov=poles[fp].peek() plates[mov].goto((fp-1)*400,150) plates[mov].goto((tp-1)*400,150) l=poles[tp].size()#确定移动到底部的高度（恰好放在原来最上面的盘子上面） plates[mov].goto((tp-1)*400,-90+20*l)def moveTower(plates,poles,height,fromPole, toPole, withPole):#递归放盘子 if height &gt;= 1: moveTower(plates,poles,height-1,fromPole,withPole,toPole) moveDisk(plates,poles,fromPole,toPole) poles[toPole].push(poles[fromPole].pop()) moveTower(plates,poles,height-1,withPole,toPole,fromPole)myscreen=turtle.Screen()drawpole_3()n=int(input("请输入汉诺塔的层数并回车:\n"))plates=creat_plates(n)poles=pole_stack()for i in range(n): poles[0].push(i)moveTower(plates,poles,n,0,2,1)myscreen.exitonclick() 就是这样，因为对玩感兴趣，就去实现，明明很简单的目标，你却发现你创造了整个世界。]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假（补）-5]]></title>
    <url>%2FAngelNI.github.io%2Flearn-5%2F</url>
    <content type="text"><![CDATA[遇见你我花光了所有的运气，以至于现在厄运连连。 深度优先搜索（DFS）DFS全称Deep First Search，是一种遍历或搜索树或图的算法。在解决问题上，利用递归调用自身函数（这种说法好像不正确，领悟思想就好了）来实现搜索的目的。把一个事情拆解成若干个小事，来实现最终的问题。 学好DFS，一定要领悟递归函数之美。下面就直接上题来理解了。 1.放苹果POJ1664 Description把M个同样的苹果放在N个同样的盘子里，允许有的盘子空着不放，问共有多少种不同的分法？（用K表示）5，1，1和1，5，1 是同一种分法。 Input 第一行是测试数据的数目t（0 &lt;= t &lt;= 20）。以下每行均包含二个整数M和N，以空格分开。1&lt;=M，N&lt;=10。 Output 对输入的每组数据M和N，用一行输出相应的K。 Sample Input 1217 3 Sample Output 18 1.有空盘子：举个栗子吧。3个苹果放到5个盘子的方法总数和3个苹果放到3个盘子的方法总数是相等的。 2.没有空盘子：没有空盘子，我们可以看成先给每一个盘子放一个苹果，还剩下m-n个苹果。然后问题就变成了把m-n个苹果放到n个盘子里的问题了，也许有人会问，m-n个苹果放到n个盘子也会出现空盘子的情况啊，不是和前面的有空盘子重复了？的确，会出现空盘子的情况，但是，他们并不是真的空盘子，因为他们最开始已经放了一个，他们在这里的空代表着这个盘子只有最开始放的一个苹果。 因此： ​ f(m,n)=f(m,n-1)+f(m-n,n) m&gt;=n ​ f(m,n)=f(m,m) m&lt;n 递归结束条件：结束条件并不是很难发现，当只有一个盘子时明显只有一种方法，另外没有苹果和只有一个苹果的时候也只有一种放法。即f(m,n)=1 n=1,m=0 综上所述： f(m,n)=1 n=1,m=0 f(m,n)=f(m,m) m&lt;n f(m,n)=f(m,n-1)+f(m-n,n) m&gt;=n AC1234567891011121314151617181920212223#include&lt;iostream&gt;using namespace std;int dfs(int m,int n)&#123; if(n==1||m==0) return 1; if(n&gt;m) return dfs(m,m); else return dfs(m,n-1)+dfs(m-n,n);&#125;int main()&#123; int t; cin&gt;&gt;t; while(t--) &#123; int m,n; cin&gt;&gt;m&gt;&gt;n; cout&lt;&lt;dfs(m,n)&lt;&lt;endl; &#125; return 0;&#125; 2.N皇后问题N皇后 Problem Description在N*N的方格棋盘放置了N个皇后，使得它们不相互攻击（即任意2个皇后不允许处在同一排，同一列，也不允许处在与棋盘边框成45角的斜线上。你的任务是，对于给定的N，求出有多少种合法的放置方法。 Input 共有若干行，每行一个正整数N≤10，表示棋盘和皇后的数量；如果N=0，表示结束。 Output 共有若干行，每行一个正整数，表示对应输入行的皇后的不同放置数量。 Sample Input 12341850 Sample Output 12319210 N皇后，比较经典的DFS的题。对每一个位置搜索，并判断位置是否合法，合法则继续向下进行。 因为时间限制，这道题用了打表的方法，记录每种可能下的结果值。具体请看代码。 AC1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//#include&lt;bits/stdc++.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int ans[20],pos[20];int num,N;void dfs(int n)&#123; int flag;//判断标志 if(n == N+1)//结束标志 &#123; num++; return ; &#125; for(int i = 1;i &lt;= N;i++) &#123; pos[n] = i;//将第n行第i列的位置下上旗子，保存位置 flag = 1;//此位置以有棋子 /*判断棋子是否合法*/ for(int j =1;j&lt;n;j++)//只需判断已下过棋子的位置 &#123; if(pos[j] == i || (abs(n-j)) == abs(pos[j] - i))//判断同一列、对角线上是否有 &#123; flag = 0; break; &#125; &#125; //合法则继续下一个 if(flag) dfs(n+1); &#125;&#125;int main()&#123; for(N =1;N&lt;=11;N++) &#123; num = 0; dfs(1); ans[N] = num;//记录结果值 &#125; int t; while(cin&gt;&gt;t&amp;&amp;t!=0) &#123; cout&lt;&lt;ans[t]&lt;&lt;endl; &#125; return 0;&#125; AC2这是另外一个，相比于上一个，代码理解起来就容易多了。分为两个函数，一个是dfs函数，另一个是条件判断函数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;stdio.h&gt;#include&lt;iostream&gt;using namespace std;int n,m,ans=0;int a[20][20],ans[20],o;int check(int x,int y)&#123; for(int i=0;i&lt;x;i++) if(a[i][y]==1) return 0; for(int i=x-1,j=y-1;i&gt;=0&amp;&amp;j&gt;=0;i--,j--) if(a[i][j]==1) return 0; for(int i=x-1,j=y+1;i&gt;=0&amp;&amp;j&lt;o;i--,j++) if(a[i][j]==1) return 0; return 1;&#125;void dfs(int x)&#123; if(x==o) &#123; ans[o]++; return; &#125; for(int i=0;i&lt;o;i++) &#123; if(check(x,i)) &#123; a[x][i]=1; dfs(x+1); a[x][i]=0; &#125; &#125;&#125;int main()&#123; for(o=1;o&lt;=10;o++) &#123; dfs(0); &#125; while(cin&gt;&gt;n&amp;&amp;n!=0) &#123; cout&lt;&lt;ans[n]&lt;&lt;endl; &#125; return 0; &#125; 3.红与黑HDU1312 Problem DescriptionThere is a rectangular room, covered with square tiles. Each tile is colored either red or black. A man is standing on a black tile. From a tile, he can move to one of four adjacent tiles. But he can’t move on red tiles, he can move only on black tiles. Write a program to count the number of black tiles which he can reach by repeating the moves described above. Input The input consists of multiple data sets. A data set starts with a line containing two positive integers W and H; W and H are the numbers of tiles in the x- and y- directions, respectively. W and H are not more than 20. There are H more lines in the data set, each of which includes W characters. Each character represents the color of a tile as follows. ‘.’ - a black tile‘#’ - a red tile‘@’ - a man on a black tile(appears exactly once in a data set) Output For each data set, your program should output a line which contains the number of tiles he can reach from the initial tile (including itself). Sample Input 1234567891011121314151617181920212223242526272829303132333435366 9....#......#..............................#@...#.#..#.11 9.#..........#.#######..#.#.....#..#.#.###.#..#.#..@#.#..#.#####.#..#.......#..#########............11 6..#..#..#....#..#..#....#..#..###..#..#..#@...#..#..#....#..#..#..7 7..#.#....#.#..###.###...@...###.###..#.#....#.#..0 0 Sample Output 12344559613 这是一个搜图的问题，用DFS，恰到好处，只需判断是否满足条件就可以ans++，比较简单的一道，要注意输入哦（因为这wa了好久） AC12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;bits/stdc++.h&gt;using namespace std;char a[25][25];int vis[25][25];int w[4][2]=&#123;1,0,-1,0,0,1,0,-1&#125;;int x,y,xx,yy,xx1,yy1;int ans;void dfs(int x,int y)&#123; vis[x][y] = 1; if(x&lt;0||y&lt;0||x&gt;=xx||y&gt;=yy) return ; for(int i =0;i&lt;4;i++) &#123; int dx = x+w[i][0]; int dy = y+w[i][1]; if(dx&gt;=0&amp;&amp;dy&gt;=0&amp;&amp;dx&lt;xx&amp;&amp;dy&lt;yy&amp;&amp;a[dx][dy]!='#'&amp;&amp;vis[dx][dy]==0) &#123; ans++; dfs(dx,dy); &#125; &#125;&#125;int main()&#123; while(~scanf("%d %d",&amp;yy,&amp;xx)&amp;&amp;xx&amp;&amp;yy) &#123; memset(vis,0,sizeof(vis)); ans = 1; for(int i =0;i&lt;xx;i++) &#123; for(int j =0;j&lt;yy;j++) &#123; cin&gt;&gt;a[i][j]; if(a[i][j]=='@') &#123; xx1 = i; yy1 = j; &#125; &#125; &#125; dfs(xx1,yy1); cout&lt;&lt;ans&lt;&lt;endl; &#125; return 0;&#125; 未完待续……]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Link list achieve Phone_Contacts]]></title>
    <url>%2FAngelNI.github.io%2Fdatastruct-1%2F</url>
    <content type="text"><![CDATA[你是我听过最美的童话。 最近，数据结构可上学习了链表线性表，并且用线性表实现了简单的手机通讯录，并用C语言和python语言都实现了，基本理论是一样的，贵在实践。记录一下~ Pyhthon 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191class Node(): def __init__(self,name,old,telephone,email): self.name = name self.old = old self.telephone = telephone self.email = email self.next = Noneclass phone_list(): def __init__(self): self.head = Node(None,None,None,None) self.len = 0 ## 新建初始化 ## def new_(self): a = input("请输入姓名：") while(len(a) &gt; 4): print("输入错误！请重新输入（姓名长度不得超过4）。") a = input("请输入姓名：") b = input("请输入年龄：") while(1): if int(b)&gt;=1 and int(b)&lt;=100: break print("输入错误！请重新输入（年龄范围：1~100）。") b = eval(input("请输入年龄：")) c = input("请输入电话：") while(len(c) != 11): print("输入错误！请重新输入:") c = input("请输入电话：") d = str(input("请输入邮箱：")) while (1): flag = 0 for i in range(len(d)): if (d[-4:] ==".com") and (d[i] =="@"): if d[i+1] != '.': flag = 1 if flag==1: break print("输入错误！请检查邮箱格式是否正确。") d = input("请输入邮箱：") return a,b,c,d def creat_people(self): p =self.head while 1: a,b,c,d= self.new_() new_peo = Node(a,b,c,d) self.len+=1 p.next = new_peo p = p.next b = eval(input("是否继续添加？\n[1] 是[2] 否\n\n")) if(b==1): continue elif(b==2): break ## 遍历 ## def scan_people(self): if (self.len==0): print("空无一人") return p = self.head while(p.next): print(f"姓名：&#123;p.next.name&#125;,年龄：&#123;p.next.old&#125;,电话：&#123;p.next.telephone&#125;,邮件：&#123;p.next.email&#125;") p = p.next ## 尾插法 插入新的节点 ## def new_people(self): p = self.head while(p.next): p = p.next a,b,c,d = self.new_() n_1 = Node(a,b,c,d) self.len+=1 p.next = n_1 p = p.next def find_people(self): if (self.len==0): print("空无一人") return a = input("请输入你要查询人的名字：") p = self.head while (p.next): if(p.next.name==a): break else: p = p.next print("已找到！！!\n信息如下：\n") print(f"姓名：&#123;p.next.name&#125;,年龄：&#123;p.next.old&#125;,电话：&#123;p.next.telephone&#125;,邮箱：&#123;p.next.email&#125;") def fix_people(self): if self.len ==0: print("空无一人") return a = input("请输入你要修改人的名字：") p = self.head while (p.next): if(p.next.name==a): break else: p = p.next b = eval(input("请输入您要修改选项\n[1]姓名[2]年龄[3]电话[4]邮箱\n")) if(b==1): new_name = input("请输入修改后的姓名\n") p.next.name = new_name elif(b==2): new_old = input("请输入修改后的年龄\n") while(1): if int(new_old)&gt;=1 and int(new_old)&lt;=100: break print("输入错误！请重新输入（年龄范围：1~100）。") new_old = eval(input("请重新输入年龄：")) p.next.old = new_old elif(b==3): new_tele = input("请输入电话：") while(len(new_tele) != 11): print("输入错误！请重新输入:") new_tele = input("请输入电话：") p.next.old = new_tele elif(b==4): new_email = str(input("请输入邮箱：")) while (1): flag = 0 for i in range(len(d)): if (bew_email[-4:] ==".com") and (new_email[i] =="@"): if d[i+1] != '.': flag = 1 if flag==1: break print("输入错误！请检查邮箱格式是否正确。") new_email = input("请输入邮箱：") p.next.old = new_email def del_people(self): if self.len == 0: print("空无一人") return a = input("请输入您要删除人的姓名：") if(self.head.name == a): self.head = self.head.next self.len-=1 p = self.head while(p.next): if(p.next.name == a): p.next = p.next.next self.len-=1 break else: p = p.next if(p.name == a): p=None self.len-=1 def length(self): print(f"此通讯录共有&#123;self.len&#125;人")def main(): PC = phone_list() while True : print("\n\n") print('\t\t\tHPU计算机18实验班通讯录管理程序') print('\t\t\t*\t python 类（ 链表）实现\t *') print("\t\t\t*\t\t\t *") print("\t\t\t*\t功能查询：\t *") print("\t\t\t*\t[1]：新建初始化\t *") print("\t\t\t*\t[2]：新建\t *") print("\t\t\t*\t[3]：查询\t *") print("\t\t\t*\t[4]：删除\t *") print("\t\t\t*\t[5]：显示组员\t *") print("\t\t\t*\t[6]：修改信息\t *") print("\t\t\t*\t[0]：退出\t *") print("\t\t\t*** \t\t ***") a =(input("请输入您的选择：")) if a.isdigit(): a = int(a) if(a&gt;=0 and a&lt;=6): if (a==0): print("谢谢您的使用！！！") break if (a==1): PC.creat_people() if (a==2): PC.new_people() if (a==3): PC.find_people() if (a==4): PC.del_people() if (a==5): PC.scan_people() if (a==6): PC.fix_people() x=eval(input("是否继续？\n【1】继续【2】退出")) if x == 1 : continue if x==2 : breakmain() C 语言实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;typedef struct stu_link&#123; int id; char name[10]; int age; char telephone[20]; char email[20]; int len; struct stu_link *next,*pre;&#125;stu;//定义结构体内变量 stu *head,*tail,*head_1,*tail_1,*head_2,*tail_2;//定义3个链表的头指针和尾指针 stu * creat_stu(stu *tail)//新建联系人 &#123; stu *p; p = (stu *)calloc(sizeof(stu),1); printf("请输入姓名:\n"); getchar(); gets(p-&gt;name); while(strlen(p-&gt;name)&gt;8) &#123; printf("输入错误！\n请重新输入(名字长度小于等于4):"); gets(p-&gt;name); &#125; printf("请输入年龄：\n"); scanf("%d",&amp;p-&gt;age); while(p-&gt;age&gt;100||p-&gt;age&lt;1) &#123; printf("输入错误！\n请重新输入(1-100): "); scanf("%d",&amp;p-&gt;age); &#125; printf("\n电话号码："); getchar(); gets(p-&gt;telephone); while(strlen(p-&gt;telephone)!=11) &#123; printf("输入错误！\n请重新输入:"); gets(p-&gt;telephone); &#125; printf("\n电子邮箱："); getchar(); gets(p-&gt;email); int i=0; while(1) &#123; int flag = 0; int len; for( i=0;i&lt;20;i++) &#123; len = strlen(p-&gt;email); if(p-&gt;email[i]=='@'&amp;&amp;p-&gt;email[len-1]=='m'&amp;&amp;p-&gt;email[len-2]=='o'&amp;&amp;p-&gt;email[len-3]=='c'&amp;&amp;p-&gt;email[len-4]=='.'&amp;&amp;p-&gt;email[len-5]!='@') flag=1; &#125; if(flag==1) break; printf("输入错误!\n请重新输入:"); gets(p-&gt;email); &#125; tail-&gt;next = p; tail = p; return tail;&#125;stu * find_stu(stu *head,stu *tail,char a[10])//查找联系人并打印信息 &#123; stu *p; p = head; if(strcmp(tail-&gt;name,a)==0) return tail; int flag=0; while(p-&gt;next != tail) &#123; if(strcmp(p-&gt;name,a)==0) &#123; flag = 1; return p; &#125; else p = p-&gt;next; &#125; if(!flag) return NULL; &#125; void scan_stu(stu *head,stu *tail)//浏览联系人信息 &#123; stu *p; p = head-&gt;next; while(p != tail) &#123; printf("姓名: %s 年龄: %d 电话：%s 邮箱：%s\n",p-&gt;name,p-&gt;age,p-&gt;telephone,p-&gt;email); p = p-&gt;next; &#125; printf("姓名:%s 年龄: %d 电话：%s 邮箱：%s\n",tail-&gt;name,tail-&gt;age,tail-&gt;telephone,p-&gt;email);&#125;stu * del_stu(stu *head,stu *tail)//删除指定联系人 &#123; stu *p,*q; p = head-&gt;next; printf("请输入要删除人的姓名\n"); char a[10]; scanf("%s",&amp;a); if(strcmp(p-&gt;name,a)==0) &#123; head-&gt;next = p-&gt;next; head-&gt;len--; &#125; else if(strcmp(tail-&gt;name,a)==0) &#123; while(p-&gt;next != tail) p = p-&gt;next; tail = p; free(tail-&gt;next); head-&gt;len--; return tail; &#125; else &#123; while(p!=tail) &#123; if(strcmp(p-&gt;name,a)==0) break; p = p-&gt;next; &#125; q =p-&gt;next; p-&gt;next = p-&gt;next-&gt;next; head-&gt;len--; free(q); &#125; return tail;&#125;void fix_stu(stu *head,stu *tail)//修改联系人信息 &#123; char a[10],aa[10],telephone1[20],email1[20]; int old; stu *p; printf("请输入要修改的姓名：\n"); scanf("%s",&amp;a); p = find_stu(head,tail,a); printf("请输入要修改的信息\n[1]：姓名[2]：年龄[3]：电话[4]：邮箱\n"); int choice; scanf("%d",&amp;choice); switch(choice) &#123; case 1:&#123; printf("请输入修改后的姓名：\n"); getchar(); gets(aa); while(strlen(aa)&gt;8) &#123; printf("输入错误！\n请重新输入(名字长度小于等于4):"); gets(aa); &#125; strcpy(p-&gt;name,aa); break; &#125; case 2:&#123; printf("请输入修改后的年龄：\n"); scanf("%d",&amp;old); while(old&gt;100||old&lt;1) &#123; printf("输入错误！\n请重新输入(1-100): "); scanf("%d",&amp;old); &#125; p-&gt;age = old; break; &#125; case 3:&#123; printf("请输入修改后的电话：\n"); getchar(); gets(telephone1); while(strlen(telephone1)!=11) &#123; printf("输入错误！\n请重新输入:"); gets(telephone1); &#125; strcpy(p-&gt;telephone,telephone1); break; &#125; case 4:&#123; printf("请输入修改后的邮箱：\n"); getchar(); gets(email1); int i=0; while(1) &#123; int flag = 0; int len; for( i=0;i&lt;20;i++) &#123; len = strlen(email1); if(email1[i]=='@'&amp;&amp;email1[len-1]=='m'&amp;&amp;email1[len-2]=='o'&amp;&amp;email1[len-3]=='c'&amp;&amp;email1[len-4]=='.'&amp;&amp;email1[len-5]!='@') flag=1; &#125; if(flag==1) break; printf("输入错误!\n请重新输入:"); gets(email1); &#125; strcpy(p-&gt;email,email1); break; &#125; &#125; printf("修改成功！！！\n"); &#125;int main()&#123; stu *head,*tail,*s,*head_1,*tail_1,*head_2,*tail_2; head = (stu *)calloc(sizeof(stu),1); head-&gt;len=0; tail = head; head_1 = (stu *)calloc(sizeof(stu),1); head_1-&gt;len=0; tail_1 = head_1; head_2 = (stu *)calloc(sizeof(stu),1); head_2-&gt;len=0; tail_2 = head_2; int choice; while(1) &#123; system("cls"); printf("\n\n\n"); printf("\t\t\t\t\t*****HPU计算机18实验班通讯录管理程序*****\n"); printf("\t\t\t\t\t+\t***C语言单向链表实现***\t\t+\n"); printf("\t\t\t\t\t+\t\t\t\t\t+\n"); printf("\t\t\t\t\t+\t\t\t\t\t+\n\t\t\t\t\t*\t 功能列表:\t\t\t+\n"); printf("\t\t\t\t\t+\t==========================\t+\n"); printf("\t\t\t\t\t+\t\t[1]:\t新建\t\t+\n"); printf("\t\t\t\t\t+\t\t[2]:\t查询\t\t+\n"); printf("\t\t\t\t\t+\t\t[3]:\t删除\t\t+\n"); printf("\t\t\t\t\t+\t\t[4]:\t显示组员\t+\n"); printf("\t\t\t\t\t+\t\t[5]:\t修改信息\t+\n"); printf("\t\t\t\t\t+\t\t[6]:\t总人数\t\t+\n"); printf("\t\t\t\t\t+\t\t[0]:\t退出\t\t+\n"); printf("\t\t\t\t\t+++\t========================== +++\n"); printf("\n选择你要的功能：\n"); scanf("%d",&amp;choice); if(choice==0) &#123; printf("谢谢您的使用！！！\n"); break; &#125; switch(choice) &#123; case 1: &#123; int choice1; printf("是否进行分组?\n[1]：分组[2]：不分组\n"); scanf("%d",&amp;choice1); switch(choice1) &#123; case 1:&#123; int choice2; printf("请选择分组：\n[1]：家人[2]：朋友\n"); scanf("%d",&amp;choice2); switch(choice2) &#123; case 1:&#123; tail_1 = creat_stu(tail_1); head_1-&gt;len++; break; &#125; case 2:&#123; tail_2 = creat_stu(tail_2); head_2-&gt;len++; break; &#125; &#125; break; &#125; case 2:&#123; tail = creat_stu(tail); head-&gt;len++; break; &#125; &#125; break; &#125; case 2: &#123; if(head-&gt;len==0&amp;&amp;head_1-&gt;len==0&amp;&amp;head_2-&gt;len==0) &#123; printf("空无一人\n"); break; &#125; char a[10]; int b; printf("请输入要查找人的名字\n"); scanf("%s",&amp;a); printf("请选择您要查找的人位于哪个分组：\n[1]：家人[2]：朋友[3]：未分组"); scanf("%d",&amp;b); if(b==1) &#123; s = find_stu(head_1,tail_1,a); &#125; else if(b==2) &#123; s = find_stu(head_2,tail_2,a); &#125; else if(b==3) &#123; s = find_stu(head,tail,a); &#125; //s = find_stu(head,tail,a); if(s != NULL) printf("姓名：%s 年龄：%d 电话：%s 邮箱：%s\n",s-&gt;name,s-&gt;age,s-&gt;telephone,s-&gt;email); else if(s==NULL) printf("没有此人！\n"); break; &#125; case 3: &#123; if(head-&gt;len==0&amp;&amp;head_1-&gt;len==0&amp;&amp;head_2-&gt;len==0) &#123; printf("空无一人\n"); break; &#125; if(head-&gt;len==0) printf("未分组空无一人\n"); else if(head_1==0) printf("家人分组空无一人\n"); else if(head_2==0) printf("朋友分组空无一人\n"); int b; printf("请选择您要删除的人位于哪个分组：\n[1]：家人[2]：朋友[3]：未分组"); scanf("%d",&amp;b); if(b==1) &#123; del_stu(head_1,tail_1); head_1--; &#125; else if(b==2) &#123; del_stu(head_2,tail_2); head_2--; &#125; else if(b==3) &#123; del_stu(head,tail); head--; &#125; break; &#125; case 4:&#123; if(head-&gt;len==0&amp;&amp;head_1-&gt;len==0&amp;&amp;head_2-&gt;len==0) &#123; printf("空无一人\n"); break; &#125; if(head-&gt;len==0) printf("未分组空无一人\n"); else if(head_1==0) printf("家人分组空无一人\n"); else if(head_2==0) printf("朋友分组空无一人\n"); if(head-&gt;len!=0) scan_stu(head,tail); if(head_1-&gt;len!=0) scan_stu(head_1,tail_1); if(head_2-&gt;len!=0) scan_stu(head_2,tail_2); break; &#125; case 5:&#123; if(head-&gt;len==0&amp;&amp;head_1-&gt;len==0&amp;&amp;head_2-&gt;len==0) &#123; printf("空无一人\n"); break; &#125; if(head-&gt;len==0) printf("未分组空无一人\n"); else if(head_1==0) printf("家人分组空无一人\n"); else if(head_2==0) printf("朋友分组空无一人\n"); int b; printf("请选择您要查找的人位于哪个分组：\n[1]：家人[2]：朋友[3]：未分组\n"); scanf("%d",&amp;b); if(b==1) fix_stu(head_1,tail_1); else if(b==2) fix_stu(head_2,tail_2); else if(b==3) fix_stu(head,tail); break; &#125; case 6:&#123; printf("此通讯录共有%d人\n",head-&gt;len+head_2-&gt;len+head_1-&gt;len); break; &#125; &#125; printf("ENTER键继续（可能不止两次优~~）"); getchar(); getchar(); &#125; return 0; &#125; 路漫漫其修远兮，代码还要一行一行敲！？！]]></content>
      <categories>
        <category>Data-Structure</category>
      </categories>
      <tags>
        <tag>Linked list</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假（补）-4]]></title>
    <url>%2FAngelNI.github.io%2Flearn-4%2F</url>
    <content type="text"><![CDATA[想和你一起聊我的秘密，可发现你就是我的秘密。 DP（动态规划）动态规划算法是通过拆分问题，定义问题状态和状态之间的关系，使得问题能够以递推（或者说分治）的方式去解决。动态规划算法的基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。 题的类型不同，但都是在基础上的动态规划的模板上进行改进。那么接下来就从几道简单的动态规划题型入手吧。 1.矩阵取数原题链接 一个N*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。 例如：3 * 3的方格。 1 3 3 2 1 3 2 2 1 输入 12第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000) 输出 1输出能够获得的最大价值。 输入样例 123431 3 32 1 32 2 1 输出样例 111 我们来用DP的思想来解决这个问题x 设矩阵是 . 假设我们已经知道了最大路径，并且经过（x, y）这个位置，为了从起点到终点得到的和最大，那 么从起点到 (x , y) 经过的数的和也一定要最大。这几乎是显然的。这是理解这一题的重点。走到 (x, y) 的上一步，可能是 （x-1, y） 或者（x, y-1）. 按照我门上面得出的结论，我们可以这样说： 如果从起点达到(x,y)的最优路径要经过(x – 1,y)或者(x,y – 1)则，从起点到达(x – 1,y)或者(x,y – 1)的 路径一定也必须是最优的。所以只需要比较 到达(x – 1,y)或者(x,y – 1)的最优路径哪一个更加优。为了方便表示，我们用： 来表示起点到 （x，y）的最优路径长度。 所以,起点到 （x，y）的最优路径可以表示成： f（x,y） = max( f(x-1,y) , f(x,y-1) )+ A [ x ] [ y ]到了这里肯定会有疑问了，这怎么感觉和上面的贪心策略差不多？？其实不，这里是理解DP的重点。根据上面的这个递推公式，我门可以准确的推导出从起点到所有点 的最优解。是整体的最优。而贪心策略只是在局部做选择，是局部的最优。 AC12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[600][600]; int main()&#123; int n ; cin&gt;&gt;n; for(int i =0;i&lt;n;i++) for(int j =0;j&lt;n;j++) cin&gt;&gt;a[i][j]; for(int i =1;i&lt;n;i++) &#123; a[i][0]+=a[i-1][0]; a[0][i]+=a[0][i-1]; &#125; for(int i =1;i&lt;n;i++) for(int j =1;j&lt;n;j++) a[i][j]+=max(a[i-1][j],a[i][j-1]); cout&lt;&lt;a[n-1][n-1]&lt;&lt;endl; return 0; &#125; 2.数字三角形原题链接 Description 7 3 8 8 1 0 2 7 4 4 4 5 2 6 5 Figure 1 shows a number triangle. Write a program that calculates the highest sum of numbers passed on a route that starts at the top and ends somewhere on the base. Each step can go either diagonally down to the left or diagonally down to the right. Input Your program is to read from standard input. The first line contains one integer N: the number of rows in the triangle. The following N lines describe the data of the triangle. The number of rows in the triangle is &gt; 1 but &lt;= 100. The numbers in the triangle, all integers, are between 0 and 99. Output Your program is to write to standard output. The highest sum is written as an integer. Sample Input 123456573 88 1 0 2 7 4 44 5 2 6 5 Sample Output 130 DP12345678910111213141516171819202122232425262728293031#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#include&lt;stdio.h&gt; int n;int a[200][200];int DP(int i,int j)&#123; if(i==n) return a[i][j]; else &#123; int x = DP(i+1,j); int y = DP(i+1,j+1); return max(x,y)+a[i][j]; &#125; &#125; int main()&#123; while(cin&gt;&gt;n) &#123; scanf("%d",&amp;n); for(int i =1;i&lt;=n;i++) for(int j =1;j&lt;=i;j++) scanf("%d",&amp;a[i][j]); printf("%d",DP(1,1)); &#125; return 0; &#125; 非递归解决方案12345678910111213141516171819202122#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[600][600]; int main()&#123; int n ; cin&gt;&gt;n; for(int i =0;i&lt;n;i++) for(int j =0;j&lt;n;j++) cin&gt;&gt;a[i][j]; for(int i =1;i&lt;n;i++) &#123; a[i][0]+=a[i-1][0]; a[0][i]+=a[0][i-1]; &#125; for(int i =1;i&lt;n;i++) for(int j =1;j&lt;n;j++) a[i][j]+=max(a[i-1][j],a[i][j-1]); cout&lt;&lt;a[n-1][n-1]&lt;&lt;endl; return 0; &#125; 这个DP思想是对的，并且答案也是对的，但当你submit时，TE了。因为有节点重复相加了，可以用记忆化搜索，解决重复相加问题。 记忆化搜索123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int t;int a[101][101],ans[101][101];int dfs(int i ,int j)&#123; if(i==t) return a[i][j]; if(ans[i][j]) return ans[i][j]; int x =dfs(i+1,j); int y = dfs(i+1,j+1); return ans[i][j]= max(x,y)+a[i][j];&#125;int main()&#123; cin&gt;&gt;t; for(int i=1;i&lt;=t;i++) for(int j =1;j&lt;=i;j++) cin&gt;&gt;a[i][j]; cout&lt;&lt;dfs(1,1); return 0;&#125; 3.最大序列和原题链接 Problem Description Given a sequence a[1],a[2],a[3]……a[n], your job is to calculate the max sum of a sub-sequence. For example, given (6,-1,5,4,-7), the max sum in this sequence is 6 + (-1) + 5 + 4 = 14. Input The first line of the input contains an integer T(1&lt;=T&lt;=20) which means the number of test cases. Then T lines follow, each line starts with a number N(1&lt;=N&lt;=100000), then N integers followed(all the integers are between -1000 and 1000). Output For each test case, you should output two lines. The first line is “Case #:”, # means the number of the test case. The second line contains three integers, the Max Sum in the sequence, the start position of the sub-sequence, the end position of the sub-sequence. If there are more than one result, output the first one. Output a blank line between two cases. Sample Input 12325 6 -1 5 4 -77 0 6 -1 1 -6 7 -5 Sample Output 12345Case 1:14 1 4Case 2:7 1 6 AC1234567891011121314151617181920212223242526272829303132333435363738#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;int a[100100];int main()&#123; int t; cin&gt;&gt;t; int l =0; while(t--) &#123; int n ; cin&gt;&gt;n; for(int i=1;i&lt;=n;i++) cin&gt;&gt;a[i]; int p=1,start=1,end=1; int maxsum=a[1]; for(int i=2;i&lt;=n;i++) &#123; if(a[i-1]+a[i]&gt;=a[i]) &#123; a[i] = a[i]+a[i-1]; &#125; else p =i; if(a[i]&gt;maxsum) &#123; maxsum=a[i]; start=p; end=i; &#125; &#125; printf("Case %d:\n%d %d %d\n",++l,maxsum,start,end); if(t) cout&lt;&lt;"\n"; &#125; return 0;&#125; 4.最长递增子序列原题链接 给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的） 例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。 输入 12第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9) 输出 1输出最长递增子序列的长度。 输入样例 1234567898516824510 输出样例 15 AC1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int a[50001],dp[50001];int main()&#123; int n,ans=0; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; for(int i=0;i&lt;n;i++) &#123; dp[i]=1; for(int j=0;j&lt;i;j++) &#123; if(a[i]&gt;a[j]) dp[i]=max(dp[i],dp[j]+1); &#125; ans=max(ans,dp[i]); &#125; cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; 提交后发现TE了，这是一个时间复杂度为O(n**2)的程序。 下面是一个时间复杂度为O(nlogn) 123456789101112131415161718192021222324#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;cstring&gt;using namespace std;int a[50001];int f[50001];int main()&#123; int n,maxn; cin&gt;&gt;n; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; int len=1; memset(f,0,sizeof(f));//创建一个新数组存放最长上升序列 f[0]=a[0]; for(int i=1;i&lt;n;i++) &#123; int pos=lower_bound(f,f+len,a[i])-f;//二分查找i+1个数中最长上升序列，a[i]的位置 f[pos]=a[i]; len=max(len,pos+1);//最长上升序列的数量 &#125; cout&lt;&lt;len&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假（补）-3]]></title>
    <url>%2FAngelNI.github.io%2FLearn-3%2F</url>
    <content type="text"><![CDATA[不疯不魔，难以成佛。 学完了vector，接下来就开始学习其他容器了。这些都是C++ STL中的比较好用的方法，让你的编程变得简单。 迭代器iterator在这几天的使用来看，自认为迭代器是为了访问容器的元素。 123初始化： &lt; 容器类型 &gt;&lt; 数据类型 &gt; :: iterator &lt;名称&gt;例如：vector&lt;int&gt;::iterator iter; //这就定义了一个可以访问vector int型数据的 名为iter的迭代器 还有如下的迭代器初始化方法： 正向迭代器：容器类型：：iterator 名称 常量迭代器：容器类型：：const_iterator 名称 反向迭代器：容器类型：：reverse_iterator 名称 常量反向迭代器： 容器类型：：const_reverse_iterator 名称 下面就以一个实例来学习迭代器的使用方法。 123456789101112131415#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;int main()&#123; int a[10]=&#123;1,2,3,4,5,6,7,8,9,0&#125;; vector&lt;int&gt; ve(a,a+10); vector&lt;int&gt;::iterator it; //正向迭代器与反向迭代器 for(it = ve.begin();it!=ve.end();++it)//听说 ++i 比 i++执行速度快 cout&lt;&lt;(*ve)&lt;&lt;endl; for(it = ve.rbegin();it!=ve.rend();++it)//听说 ++i 比 i++执行速度快 cout&lt;&lt;(*ve)&lt;&lt;endl; return 0;&#125; 还有操作迭代器的三个函数 包含于头文件&lt; algorithm &gt; advance(p,n) 向前移动 n 个元素 distance(p,q) 计算两个迭代器的长度，在同一个容器内 iter_swap(p,q) 用于交换两个迭代器p，q 指向的值 集合set头文件&lt; set &gt; 其实，只要掌握了一个容器的操作方法，其他容器的方法都可以类比。 值得注意一点的是：集合内的容器不能重复，并且他会默认从小到大排序。 1234567891011#include&lt;set&gt;set&lt;int&gt; st;st.insert() //插入元素st.begin() // 返回第一个元素的迭代器st.end() //返回最后一个元素之后的迭代器，不是最后一个迭代器stclear() //清空所有元素st.count() //判断元素是否存在，返回bool类型st.empty() //判断是否为空 ，空则truest.erase() //删除集合中元素st.find() //返回一个被查找到的元素的迭代器，没有则返回end（），find(开始地址，尾地址，查找元素)st.size() //集合的大小 栈stack头文件&lt; stack &gt; 1234567//初始化stack&lt;int&gt; a;a.push() // 压入栈a.pop() //移除最顶端元素a.top() //访问最顶端元素a.size() //栈的大小a.empty() //判断是否为空 队列queue头文件&lt; queue &gt; 123456queue&lt;int &gt; q;q.push() //加入对列q.front() //队首元素q.pop（） //移除队首元素q.empty() //判断是否为空q.size() //队列大小 字典map头文件&lt; map &gt; 12345678910111213map&lt;int,int&gt; mp;mp.clear() //清空mpmp.size() //mp大小mp.empty() //判断是否为空mp.count(key) //判断key是否存在map&lt;int,int &gt;::iterator it;mp[0] =4;mp[1] = 2;mp[2] = 3;it = mp.find(1) //key，返回一个地址（*it）.first() //返回所指地址的key值（*it）.second() //返回所指地址的value值mp.insert(pair&lt;int,int&gt;(4,5)) //插入键值对]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假（补）-2]]></title>
    <url>%2FAngelNI.github.io%2Flearn-2%2F</url>
    <content type="text"><![CDATA[围在城里的人想逃出来，城外的人想冲进去。–《围城》 有时候多学一点总没错，在你生活中一个不经意间就用上了。 VECTORvector类为内置数组提供了一种替代的表示，通常建议使用vector。（但仍有许多程序环境必须使用内置数组），vector 是C++中的一个容器类型，vector类是随标准C++引入的标准库的一部分。 使用vector必须包含相关的头文件 #include vector初始化 1234567891011121314151. vector&lt;int&gt; ve(10); //定义已知长度的Vector，初始值默认为02. vector&lt;int&gt; ve(10,2); //定义已知长度，并且初值为2的数组3. int a[4] = &#123;1,2,3,4&#125;; vector&lt; int &gt; ve( a , a+4); //将静态数组拷贝至不定数组4. vector&lt;int&gt; ve(&amp;a[1] , &amp;a[3] ) //将a[1],a[2]拷贝到不定数组，其实是一个地址的传递5. vector &lt;int&gt; a(10,2); vector&lt;int &gt; b(a); //vector 被另一个vector初始化 vector&lt;int &gt; c; c = b; //vector 被赋值给另一个vector、 vector操作12345678910111213#include&lt;vector&gt;vector&lt;int&gt; ve;ve.erase(ve.begin()+2) //删除第二个元素ve.insert(ve.begin()+2 , 1 ) //在第二个位置插入1ve.erase(ve.begin()+1,ve.begin()+4) //删除第1,2,3位置上的元素ve.size() //返回数组的大小ve.clear() //清空数组ve.back() //返回最后一个元素ve.front() //返回第一个元素ve[i] //返回第i个素ve.empty() //判断不定数组是否为空，空：true，非空：falseve.pop_back() //删除最后一个元素ve.push_back() //在最后插入一个元素 vector二维数组（输入，输出）123456789101112131415161718192021222324252627282930#include&lt;vector&gt;#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;int main()&#123; vector&lt;vector&lt;int&gt; &gt; a; vector&lt;int&gt; b; int temp; int i,j; for(i =0;i&lt;5;i++) &#123; b.clear(); for(j =0;j&lt;5;j++) &#123; cin&gt;&gt;temp; b.push_back(temp); &#125; a.push_back(b); &#125; for(i=0;i&lt;5;i++) &#123; for(j=0;j&lt;5;j++) &#123; cout&lt;&lt;a[i][j]&lt;&lt;" "; &#125; cout&lt;&lt;"\n"; &#125; return 0; &#125; vector字符串数组123456789101112vector&lt;string&gt; text; string word; int a=5; while((a--)&amp;&amp;cin&gt;&gt;word )//// &amp;&amp; 短路问题 &#123; text.push_back(word); &#125; for(int i=0;i&lt;text.size();i++) &#123; cout&lt;&lt;text[i]&lt;&lt;" "; &#125; 动态空间申请malloc12345678910111213141516171819#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int *p; int i; p = (int *)malloc(sizeof(int)*5); for(i=0;i&lt;5;i++) &#123; cin&gt;&gt;p[i]; &#125; for(i=0;i&lt;5;i++) cout&lt;&lt;p[i]&lt;&lt;endl; free(p); return 0; &#125; calloc12345678910111213141516171819#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int *p; int i; p = (int *)calloc(sizeof(int),5); for(i=0;i&lt;5;i++) &#123; cin&gt;&gt;p[i]; &#125; for(i=0;i&lt;5;i++) cout&lt;&lt;p[i]&lt;&lt;endl; free(p); return 0; &#125; malloc 与 calloc 在使用方法上基本上是差不多的。malloc它允许从空间内存池中分配内存,malloc()的参数是一个指定所需字节数的整数。colloc与malloc类似,但是主要的区别是存储在已分配的内存空间中的值默认为0,使用malloc时,已分配的内存中可以是任意的值. colloc需要两个参数,第一个是需要分配内存的变量的个数,第二个是每个变量的大小. 二维空间申请12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;using namespace std;int main()&#123; int ** p; int i,j; p = (int **)calloc(sizeof(int*),5); for(i =0;i&lt;5;i++) &#123; p[i] = (int *)calloc(sizeof(int),5); &#125; for(i=0;i&lt;5;i++) for(j =0;j&lt;5;j++) cin&gt;&gt;p[i][j]; for(i=0;i&lt;5;i++) for(j=0;j&lt;5;j++) cout&lt;&lt;p[i][j]&lt;&lt;endl; for (int i= 0; i &lt; 5; i++) &#123; free(p[i]); &#125; free(p); return 0; &#125; 二维空间与一维空间主要的不同是：二维数组由一维数组组成，申请的空间要分别对每个一维空间申请。释放空间时也是如此，先释放每个一维空间，最后在释放二维空间。 C++ 动态空间申请12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; //一维空间申请 int m=9; int *p= new int[m]; for(int i=0;i&lt;9;i++) &#123; cin&gt;&gt;p[i]; &#125; for(int i=0;i&lt;9;i++) cout&lt;&lt;p[i]&lt;&lt;endl; delete []p; //二维空间申请方法一 int n=4,m=4; int tem =0; int **p = new int*[m]; for(int i=0;i&lt;m;i++) &#123; p[i] = new int[n]; &#125; for(int i=0;i&lt;m;i++) &#123; for(int j=0;j&lt;n;j++) &#123; p[i][j]=tem; tem++; &#125; &#125; for(int i=0;i&lt;m;i++) for(int j=0;j&lt;n;j++) cout&lt;&lt;p[i][j]&lt;&lt;endl; for(int i=0;i&lt;m;i++) delete []p[i]; delete []p; //二维空间申请方法二 int (*q)[3] = new int[3][3]; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) cin&gt;&gt;q[i][j]; for(int i=0;i&lt;3;i++) for(int j=0;j&lt;3;j++) cout&lt;&lt;q[i][j]&lt;&lt;setw(3); delete []q; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[暑假（补）-1]]></title>
    <url>%2FAngelNI.github.io%2Flearn-1%2F</url>
    <content type="text"><![CDATA[乱花渐欲迷人眼，浅草才能建马蹄。最爱湖东行不足，绿杨阴里白沙堤。自己领会去吧！！！ 我是打酱油的啊，记住，打酱油的。 写个板子，过个水题，好让我签个到。 1.sort()（1） 数组1234567891011121314#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;bool cmp(stu a,stu b)&#123; return a &lt; b ; //从小到大； return a &gt; b ;//从大到小； &#125;int main()&#123; int a[10]=&#123;1,5,6,8,10,22,-5,99,100,-5&#125; sort(a,a+10); return 0; &#125; （2）结构体1234567891011121314151617181920212223242526272829#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;struct stu&#123; int id; char name[20]; char sex[10];&#125;student[10];bool cmp(stu a,stu b)&#123; return a.id &lt; b.id ; //从小到大； return a.id &gt; b.id ;//从大到小； &#125;int main()&#123; student[0].id = 10; student[1].id = 8; student[2].id = 1; student[3].id = 9; sort(student,student+4,cmp); for(int i=0;i&lt;4;i++) &#123; printf("%d\n",student[i].id); &#125; printf("%d",student[0].id); return 0; &#125; （3）数据类型排序123456789101112131415161718#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;//#include&lt;functional&gt; using namespace std;int main()&#123; int a[10]=&#123;1,10,8,11,20,0,-9,85,21,3&#125;; char b[10] = &#123;'b','a','z','e','t','s','p','f','o','h'&#125;; sort(a,a+10,less&lt;int&gt;()); sort(a,a+10,greater&lt;int&gt;()); sort(b,b+10,greater&lt;char&gt;()); for(int i=0;i&lt;10;i++) cout&lt;&lt;a[i]&lt;&lt;endl; for(int i=0;i&lt;10;i++) cout&lt;&lt;b[i]&lt;&lt;endl; return 0; &#125; 2.GCDGCD是求最大公约数，有两种方法：1.自己构建函数。2.头文件中的__gcd()函数. 1234567891011121314151617#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt; using namespace std;/*int gcd(int a,int b)&#123; return b ? gcd(b,a%b) : a;&#125;*/int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;__gcd(a,b)&lt;&lt;endl; return 0; &#125; 3.LCMLCM求最小公倍数，其实掌握了GCD，就简单的多了。 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int gcd(int a,int b)&#123; return b ? gcd(b,a%b) : a ; &#125; int main()&#123; int a,b; cin&gt;&gt;a&gt;&gt;b; cout&lt;&lt;(a*b)/gcd(a,b)&lt;&lt;endl; cout&lt;&lt;(a*b)/__gcd(a,b)&lt;&lt;endl; return 0; &#125; 4.素数打表素数打表根据比埃拉托斯特尼筛法，如果感兴趣，可以去找度娘。 123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;//#include&lt;cstring&gt;//#include&lt;string.h&gt;using namespace std;int main()&#123; int prim[1016]; memset(prim,0,sizeof(int)*1016); prim[1]=1; for(int i=2;i*i&lt;1016;i++) &#123; if(!prim[i]) for(int j=i*i;j&lt;1016;j+=i) prim[j]=1; &#125; for(int i=1;i&lt;1016;i++) &#123; cout&lt;&lt;i&lt;&lt;'\t'; cout&lt;&lt;prim[i]&lt;&lt;endl; &#125; int count = 0; for(int i=1;i&lt;1016;i++) &#123; if(prim[i]==0) count++; &#125; cout&lt;&lt;count&lt;&lt;endl; return 0;&#125; 5.快速幂取模快速幂取模，为了解决大数取模问题吧。 123456789101112131415161718192021#include&lt;stdio.h&gt;typedef long long ll;#define MOD 1000000007ll pow_mod(ll a,ll n)&#123; ll res =1; while(n) &#123; if(n&amp;1) res =res* a%MOD; a=a*a%MOD; n&gt;&gt;=1; &#125; return res;&#125;int main()&#123; int a = 4; int b = 6; printf("%d",pow_mod(a,b)); return 0; &#125;]]></content>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[matplotlib 常用图绘制]]></title>
    <url>%2FAngelNI.github.io%2Fmatplotlib%2F</url>
    <content type="text"><![CDATA[我的冷漠里藏着一半的害羞，一半的自卑。 通过做图表来分析数据实在是一个非常棒的方法，由于我偶尔忘记语法，还得翻之前的笔记，难受。下面就画了些常用的图，记一记，记一记。 1.折线图12345678910111213141516171819202122import matplotlibimport matplotlib.pyplot as plt%matplotlib inlinex1 = [1,2,3] y1 = [5,7,4]x2 = [1,2,3] y2 =[10,14,12]matplotlib.rcParams['font.sans-serif'] = ['SimHei']#中文显示问题f=plt.figure(figsize=(12,10))#调整图像大小plt.plot(x1,y1,label='First Line')plt.plot(x2, y2, label='Second Line')plt.xlabel("Plot Number",fontsize = 20)#x轴 标签及调整字体大小plt.ylabel("Important var",fontsize = 20)#y轴 标签及调整字体大小plt.title("标题", fontsize = 20)#标题plt.legend()#显示图例plt.xlim(0,4)#调整x轴大小plt.ylim(0,15)#调整y轴大小plt.grid()#添加格线plt.show() 2.柱状图1234567891011121314151617181920212223matplotlib.rcParams['font.sans-serif'] = ['SimHei']label_list = ["AUC","MAP","MRR","Prec","Rec","F1","NDGC","Call"]num_list_1 = [ 0.8395789534863245,0.03947255032401116,0.4421931735657211,0.18845315904139434,0.061183509516103594, 0.07578339296217934, 0.20391161229968288, 0.5533769063180828]num_list_2 = [0.8099706571182651, 0.07124258816665524,0.5007884899720522,0.29520697167755994,0.051690038913594256,0.07702843749844428, 0.30278346199328815,0.664488017429194]x = range(len(num_list_1))#f=plt.figure(figsize=(12,10))rects_1 = plt.bar( x,height = num_list_1,width = 0.4,alpha = 0.8,color = "red",label = "MBPR")rects_2 = plt.bar([i+0.4 for i in x],height = num_list_2,width = 0.4,alpha = 0.8,color = "blue",label = "BPR")#柱状图对比plt.ylim(0,1)plt.ylabel("指标")plt.xticks([index + 0.2 for index in x], label_list)#自定义x 轴含义plt.xlabel("模型")plt.title("MBPR、BPR对比图")plt.legend()plt.show() 3.散点图1234x = [1,2,3,4,5,6]y = [1,2,3,4,5,6]#f = plt.figure(figsize=(12,10))plt.scatter(x,y,color="r") 4.饼图123456#f=plt.figure(figsize=(12,10))slices = [7,2,2,13]activities = ['sleeping','eating','working','playing'] cols = ['c','m','r','b']plt.pie( slices,labels=activities,colors=cols,startangle=90,shadow= True ,explode=(0,0.3,0,0),autopct='%1.1f%%')# autopct='%1.1f%%' 百分比 5.箱式图12345import seaborn as sns#f=plt.figure(figsize=(12,10))sns.set_style("whitegrid")data = np.random.normal(size=(20, 6)) + np.arange(6) / 2sns.boxplot(data=data) 6.热度图12345678910%matplotlib inlineimport matplotlib.pyplot as pltimport numpy as np; np.random.seed(0)import seaborn as sns;sns.set()uniform_data = np.random.rand(3, 3)#print (uniform_data)heatmap = sns.heatmap(uniform_data) 7.子图123456789101112131415161718192021222324252627import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-10, 10, 100)y =2*np.cos(x)**5 + 3*np.sin(x)**3#定义画布和子图数量fig,axes=plt.subplots(2,3,figsize=(20,18),facecolor='#ccddef')#添加整个画布的标题fig.suptitle('我是最大的标题',fontsize=20)#利用text属性添加副标题fig.text(0.45,0.9,'这是副标题')#折线图axes[0][0].plot(x,y)#柱状图axes[0][1].bar(x,y)#直方图axes[0][2].hist(y,bins=30)#散点图axes[1][0].scatter(x,y)#条形图axes[1][1].barh(x,y)#饼图axes[1][2].pie([1,2,3,4,5],labels=['A级','B级','C级','D级','E级'])#axes[1,2].boxplot() 需要合适的数据，就不画了#设置子图的xy轴范围，子图标题，标签背景颜色等，也可单独使用ax1.set_xlim()进行设置。部分属性不能直接使用set设置ax1.set(xlim=[-10,12],ylim=[-6,4],title='This is TU1',xlabel='xlabel',ylabel='ylabel',facecolor='#ffeedd')]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活随笔]]></title>
    <url>%2FAngelNI.github.io%2FEssay%2F</url>
    <content type="text"><![CDATA[不妨先做出点成绩，然后再去强调你的感受，否则，生命中只有唧唧歪歪，怎么看都是矫情。 可以确切的说这个暑假是颇丰的一个暑假，学习了机器学习的知识，提升了自己的代码编程能力，增强了自己的动手能力，还有与同伴交流研讨，这些都是难忘的。更重要的是对身心的锻炼，在这个炎热的夏天，38摄氏度是常事，顶着高温。学习也是比较枯燥的，自己上网学习机器学习的内容，做笔记，枯燥的环境有人离开，也有人留下来，真的是对身心的一个极大的挑战。这让我想起，天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行拂乱其所为，所以动心忍性，曾益其所不能。虽说蜀道之难难于上青天，但风雨过后的彩虹却有人见证过。也许我们缺少的是恒心吧，但在学习的道路上，没有了毅力怎能攀登知识的顶峰，不用知识武装自己怎么能克服人生的艰难。虽然在你看来只是一些空话，但是只有经历过才会懂得，恒心，毅力是必不可少的，更多的时候用言语表达只是证明，你说过，只是空话，只有实践，只有自己眼睛瞅着前方的目标，手里做着小事情才能证明你自己。不止说过，做过才最重要啊。这是我一暑假的体会吧，这才是这个暑假的宝贵的精神财富吧。]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仰望，仰望？]]></title>
    <url>%2FAngelNI.github.io%2FLooking-at-the-stars%2F</url>
    <content type="text"><![CDATA[Live a good life meet slowly. 临近开学的前几天，跑去郑州去玩 天气不算太热，下着稀稀疏疏小雨， 坐火车到了郑州，坐地铁去了郑大， 行走在郑大的校园，看着别样的风景， 新生军训的大队伍，举伞疾走零星的小哥哥小姐姐， 如花绽放的喷泉水，雨中静默含苞的粉荷花绿藕叶， 低吼着，等待着 雨中矗立的钟楼，远远遥望的图书馆 换上新衣的院楼，人来人往的校门口 庄严，稳重，高调，朴素 仰望，仰望吗？ 只有那些从不仰望星空的人，才不会掉进坑中 只有那些从不掉进坑中的人，就只会居高自乐 虫儿告诉我，今晚的星星好亮， 哈哈哈， 我被骗进坑里了]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keras-learn-note(3)]]></title>
    <url>%2FAngelNI.github.io%2FKeras-note-3%2F</url>
    <content type="text"><![CDATA[May you be faithful to yourself, live earnestly and laugh freel. Keras 实现矩阵分解推荐系统算法简介这里简单介绍下推荐系统中最为主要的协同过滤算法，大致分为如下几类： 基于用户的协同过滤（给用户推荐与他相似的人购买的物品） 基于商品的协同过滤（给用户推荐和他之前喜欢的物品相似的物品） 基于模型的协同过滤：关联算法，聚类算法，分类算法，回归算法，矩阵分解，神经网络,图模型以及隐语义模型都属于这个范畴。 之前用了python来写矩阵分解，现在换种写法，用keras来实现矩阵分解。 导入数据123456import pandas as pdimport numpy as nprating = pd.read_csv('data/ratings.csv',sep=',')num_user = np.max(rating['userId'])num_movie = np.max(rating['movieId'])print(num_user,num_movie,len(rating)) 123#计算用户电影组合的R矩阵填充率R = len(rating)/(num_user*num_movie)print(f"矩阵填充率:&#123;R&#125;") 矩阵的填充率为：0.000853805025622708 搭建模型12345678910111213141516171819from keras import Modelimport keras.backend as Kfrom keras.layers import Embedding ,Reshape,Input,DotK.clear_session()def Recomand_model(num_user,num_movie,k): input_user = Input(shape=[None,],dtype='int32') model_user = Embedding(num_user+1,k,input_length = 1)(input_user) model_user = Reshape((k,))(model_user) input_moive = Input(shape=[None,],dtype="int32") model_moive = Embedding(num_movie+1,k,input_length = 1)(input_moive) model_moive = Reshape((k,))(model_moive) out = Dot(1)([model_user,model_moive]) model = Model(input=[input_user,input_moive],outputs = out) model.compile(loss = 'mse',optimizer = 'Adam') model.summary() return model 1model =Recomand_model(num_user,num_movie,100) 注 model.summary()输出模型各层的参数状况 model.layers.Reshape() :将输出调整为特定的形状 数据处理1234train_u = rating['userId'].valuestrain_i = rating['movieId'].valuestrain_x = [train_u,train_i]train_y = rating["rating"].values 训练模型1model.fit(train_x,train_y,batch_size = 100,epochs = 10) 预测1model.predict([[1],[2]]) 1array([[ 3.76612234]], dtype=float32)]]></content>
      <categories>
        <category>Keras-note</category>
      </categories>
      <tags>
        <tag>Keras-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stanford-Machine-Learning-camp]]></title>
    <url>%2FAngelNI.github.io%2FStanford-Machine-Learning-camp%2F</url>
    <content type="text"><![CDATA[曾经沧海难为水，却见巫山不是云。 Stanford-Machine-Learning-camp课程资料 课程主页 课程笔记 课程视频 环境配置Anaconda 作业介绍 比赛环境推荐使用Linux或者Mac系统，以下环境搭建方法皆适用: Docker环境配置 本地环境配置 重要一些的资源： Dr.Wu 博客71篇(机器学习、深度学习、强化学习、对抗网络) Dr.Wu 本人知乎 深度学习经典论文 深度学习斯坦福教程 廖雪峰python3教程 github教程 莫烦机器学习教程 深度学习经典论文 机器学习代码修行100天 吴恩达机器学习新书：machine learning yearning 本人博客(机器学习基础算法专题) 本人博客(深度学习专题) 自上而下的学习路线: 软件工程师的机器学习 1. 前言这门课的宗旨就是：*“手把手推导机器学习理论，行对行练习徒手代码过程” *吴恩达在斯坦福的机器学习课，是很多人最初入门机器学习的课，10年有余，目前仍然是最经典的机器学习课程之一。当时因为这门课太火爆，吴恩达不得不弄了个超大的网络课程来授课，结果一不小心从斯坦福火遍全球，而后来的事情大家都知道了。吴恩达这些年，从谷歌大脑项目到创立Coursera再到百度首席科学家再再到最新开设了深度学习deeplearning.ai，辗转多年依然对CS229不离不弃。 个人认为：吴恩达的机器学习课程在机器学习入门的贡献相当于牛顿、莱布尼茨对于微积分的贡献。区别在于，吴恩达影响了10年，牛顿影响了200年。(个人观点) 本课程提供了一个广泛的介绍机器学习、数据挖掘、统计模式识别的课程。主题包括： （一）监督学习（参数/非参数算法，支持向量机，核函数，神经网络）。 （二）无监督学习（聚类，降维，推荐系统，深入学习推荐）。 （三）在机器学习的最佳实践（偏差/方差理论；在机器学习和人工智能创新过程）。本课程还将使用大量的案例研究，您还将学习如何运用学习算法构建智能机器人（感知，控制），文本的理解（Web搜索，反垃圾邮件），计算机视觉，医疗信息，音频，数据挖掘，和其他领域。 本课程相对以前的机器学习视频cs229(2008)，这个视频更加清晰，而且每课都有课件，推荐学习。 2.数学知识复习1.线性代数2.概率论3.凸函数优化4.随机梯度下降算法 中文资料： 机器学习中的数学基本知识 统计学习方法 大学数学课本（从故纸堆里翻出来^_^） 3.编程工具斯坦福资料： Python复习 4. 中文书籍推荐： 《机器学习》周志华 《统计学习方法》李航 《机器学习课》邹博 5. 学习安排本课程需要11周共18节课，每周具体时间划分为4个部分: 1部分安排周一到周二 2部分安排在周四到周五 3部分安排在周日 4部分作业是本周任何时候空余时间 周日晚上提交作业运行截图 周三、周六休息^_^ 6.作业提交指南： 训练营的作业自检系统已经正式上线啦！只需将作业发送到训练营公共邮箱即可，知识星球以打卡为主，不用提交作业。以下为注意事项:&lt;1&gt; 训练营代码公共邮箱：cs229@163.com&lt;2&gt; 查询自己成绩:&lt;3&gt; 将每周作业压缩成zip文件，文件名为“学号+作业编号”，例如：”CS229-010037-01.zip”&lt;4&gt; 注意不要改变作业中的《方法名》《类名》不然会检测失败！！ 7.学习安排week 1学习组队比赛观摩 作业 Week1：:制定自己的学习计划 week 2第一节： 引言(Introduction)课件：lecture1笔记：lecture1-note1视频： 1.1欢迎:Welcome to Machine Learning 1.2机器学习是什么？:Welcome 1.3监督学习:What is Machine Learning 1.4无监督学习:Supervised Learning 第二节： 单变量线性回归(Linear Regression with One Variable)课件：lecture2笔记：lecture2-note2视频： 2.1模型表示:Unsupervised Learning 2.2代价函数:Model Representation 2.3代价函数的直观理解I:Cost Function 2.4代价函数的直观理解II:Cost Function - Intuition I 2.5梯度下降:Cost Function - Intuition II 2.6梯度下降的直观理解:Gradient Descent 2.7梯度下降的线性回归:Gradient Descent Intuition 2.8接下来的内容:GradientDescentForLinearRegression 作业 Week2：:1.环境配置2.开学习博客和github week 3第三节： 线性代数回顾(Linear Algebra Review)课件：lecture3笔记：lecture3-note3视频： 3.1矩阵和向量:Matrices and Vectors 3.2加法和标量乘法:Addition and Scalar Multiplication 3.3矩阵向量乘法:Matrix Vector Multiplication 3.4矩阵乘法:Matrix Matrix Multiplication 3.5矩阵乘法的性质:Matrix Multiplication Properties 3.6逆、转置:Inverse and Transpose 第四节： 多变量线性回归(Linear Regression with Multiple Variables)课件：lecture4笔记：lecture4-note4视频： 4.1多维特征:Multiple Features 4.2多变量梯度下降:Gradient Descent for Multiple Variables 4.3梯度下降法实践1-特征缩放:Gradient Descent in Practice I - Feature Scaling 4.4梯度下降法实践2-学习率:Gradient Descent in Practice II - Learning Rate 4.5特征和多项式回归:Features and Polynomial Regression 4.6正规方程:Normal Equation 4.7正规方程及不可逆性（选修）:Normal Equation Noninvertibility (Optional)作业 Week3：: 作业链接1.线性回归 Linear Regression2.多远线性回归 Linear Regression with multiple variables Week 4第五节：Octave教程(Octave Tutorial 选修)（有Python基础可以忽略）课件：lecture5笔记：lecture5-note5视频： 5.1基本操作:Working on and Submitting Programming Exercises 5.2移动数据:Basic Operations 5.3计算数据:Moving Data Around 5.4绘图数据:Computing on Data 5.5控制语句：for，while，if语句:Plotting Data 5.6向量化88:Control Statements 5.7工作和提交的编程练习:Vectorization 第六节：逻辑回归(Logistic Regression)课件：lecture6笔记：lecture6-note6视频： 6.1分类问题:Classification 6.2假说表示:Hypothesis Representation 6.3判定边界:Decision Boundary 6.4代价函数:Cost Function 6.5简化的成本函数和梯度下降:Simplified Cost Function and Gradient Descent 6.6高级优化:Advanced Optimization 6.7多类别分类：一对多:Multiclass Classification_ One-vs-all 作业 Week4：: 作业链接 逻辑回归 Logistic Regression 带有正则项的逻辑回归 Logistic Regression with Regularization Week 5第七节：正则化(Regularization)课件：lecture7笔记：lecture7-note7视频： 7.1过拟合的问题:The Problem of Overfitting 7.2代价函数:Cost Function 7.3正则化线性回归:Regularized Linear Regression 7.4正则化的逻辑回归模型:Regularized Logistic Regression 第八节：神经网络：表述(Neural Networks: Representation)课件：lecture8笔记：lecture8-note8视频： 8.1非线性假设:Non-linear Hypotheses 8.2神经元和大脑:Neurons and the Brain 8.3模型表示1:Model Representation I 8.4模型表示2:Model Representation II 8.5样本和直观理解1:Examples and Intuitions I 8.6样本和直观理解II:Examples and Intuitions II 8.7多类分类:Multiclass Classification作业 Week5：: 作业链接 多元分类 Multiclass Classification 神经网络预测函数 Neural Networks Prediction fuction Week 6第九节1：神经网络的学习(Neural Networks: Learning1)课件：lecture9笔记：lecture9-note9视频： 9.1代价函数:Cost Function 9.2反向传播算法:Backpropagation Algorithm 9.3反向传播算法的直观理解:Backpropagation Intuition 第九节2：神经网络的学习(Neural Networks: Learning2)课件：lecture9笔记：lecture9-note9视频： 9.4实现注意：展开参数:Implementation Note_ Unrolling Parameters 9.5梯度检验:Gradient Checking 9.6随机初始化:Random Initialization 9.7综合起来:Putting It Together 9.8自主驾驶:Autonomous Driving 作业 Week6：: 作业链接 神经网络实现 Neural Networks Learning Week 7第十节：应用机器学习的建议(Advice for Applying Machine Learning)课件：lecture10笔记：lecture10-note10视频： 10.1决定下一步做什么:Deciding What to Try Next 10.2评估一个假设:Evaluating a Hypothesis 10.3模型选择和交叉验证集:Model Selection and Train_Validation_Test Sets 10.4诊断偏差和方差:Diagnosing Bias vs. Variance 10.5正则化和偏差/方差:Regularization and Bias_Variance 10.6学习曲线:Learning Curves 10.7决定下一步做什么:Deciding What to Do Next Revisited第十一节： 机器学习系统的设计(Machine Learning System Design)课件：lecture11笔记：lecture11-note11视频： 11.1首先要做什么:Prioritizing What to Work On 11.2误差分析:Error Analysis 11.3类偏斜的误差度量:Error Metrics for Skewed Classes 11.4查准率和查全率之间的权衡:Trading Off Precision and Recall 11.5机器学习的数据:Data For Machine Learning作业 Week7：: 作业链接 正则线性回归 Regularized Linear Regression 偏移和方差 Bias vs. Variance Week 8第十二节：支持向量机(Support Vector Machines)课件：lecture12笔记：lecture12-note12视频： 12.1优化目标:Optimization Objective 12.2大边界的直观理解:Large Margin Intuition 12.3数学背后的大边界分类（选修）:Mathematics Behind Large Margin Classification (Optional) 12.4核函数1:Kernels I 12.5核函数2:Kernels II 12.6使用支持向量机:Using An SVM 第十三节：聚类(Clustering)课件：lecture13笔记：lecture13-note13视频： 13.1无监督学习：简介:Unsupervised Learning_ Introduction 13.2K-均值算法:K-Means Algorithm 13.3优化目标:Optimization Objective 13.4随机初始化:Random Initialization 13.5选择聚类数:Choosing the Number of Clusters作业 Week8：: 作业链接 SVM实现 垃圾邮件分类 Spam email Classifier Week 9第十四节：降维(Dimensionality Reduction)课件：lecture14笔记：lecture14-note14视频： 14.1动机一：数据压缩:Motivation I_ Data Compression 14.2动机二：数据可视化:Motivation II_ Visualization 14.3主成分分析问题:Principal Component Analysis Problem Formulation 14.4主成分分析算法:Principal Component Analysis Algorithm 14.5选择主成分的数量:Choosing the Number of Principal Components 14.6重建的压缩表示:Reconstruction from Compressed Representation 14.7主成分分析法的应用建议:Advice for Applying PCA 第十五节：异常检测(Anomaly Detection)课件：lecture15笔记：lecture15-note15视频： 15.1问题的动机:Problem Motivation 15.2高斯分布:Gaussian Distribution 15.3算法:Algorithm 15.4开发和评价一个异常检测系统:Developing and Evaluating an Anomaly Detection System 15.5异常检测与监督学习对比:Anomaly Detection vs. Supervised Learning 15.6选择特征:Choosing What Features to Use 15.7多元高斯分布（选修）:Multivariate Gaussian Distribution (Optional) 15.8使用多元高斯分布进行异常检测（选修）:Anomaly Detection using the Multivariate Gaussian Distribution (Optiona作业 Week9：: 作业链接 K-means 聚类算法 Clustering PCA 主成分析 Principal Component Analysis Week 10第十六节：推荐系统(Recommender Systems)课件：lecture16笔记：lecture16-note16视频： 16.1问题形式化:Problem Formulation 16.2基于内容的推荐系统:Content Based Recommendations 16.3协同过滤:Collaborative Filtering 16.4协同过滤算法:Collaborative Filtering Algorithm 16.5向量化：低秩矩阵分解:Vectorization_ Low Rank Matrix Factorization 16.6推行工作上的细节：均值归一化:Implementational Detail_ Mean Normalization 第十七节：大规模机器学习(Large Scale Machine Learning)课件：lecture17笔记：lecture17-note17)视频： 17.1大型数据集的学习:Learning With Large Datasets 17.2随机梯度下降法:Stochastic Gradient Descent 17.3小批量梯度下降:Mini-Batch Gradient Descent 17.4随机梯度下降收敛:Stochastic Gradient Descent Convergence 17.5在线学习:Online Learning 17.6映射化简和数据并行:Map Reduce and Data Parallelism 作业 Week10：: 作业链接 异常检测 Anomaly Detection Week 11第十八节1： 应用实例：图片文字识别(Application Example: Photo OCR)课件：lecture18笔记：lecture18-note18视频： 18.1问题描述和流程图:Problem Description and Pipeline 18.2滑动窗口:Sliding Windows第十八节2： 应用实例：图片文字识别(Application Example: Photo OCR)课件：lecture18笔记：lecture1-note18)视频： 18.3获取大量数据和人工数据:Getting Lots of Data and Artificial Data 18.4上限分析：哪部分管道的接下去做:Ceiling Analysis_ What Part of the Pipeline to Work on Next 作业 Week11：: 作业链接2.推荐系统实现 Recommender Systems*课程比赛：比赛介绍: * Week 12第十九节：总结(Conclusion)视频：19.1总结和致谢:Summary and Thank You*课程比赛：比赛: * Kaggle 比赛： 泰坦尼克 Titanic]]></content>
      <categories>
        <category>Machine-learn</category>
      </categories>
      <tags>
        <tag>Machine-learn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keras-learn-note(2)]]></title>
    <url>%2FAngelNI.github.io%2FKeras-note-2%2F</url>
    <content type="text"><![CDATA[要么出众，要么出局，乾坤未定，你我都是黑马。 1 Keras后端😉Keras是一个模型级的库，提供了快速构建深度学习网络的模块。Keras并不处理如张量乘法、卷积等底层操作。这些操作依赖于某种特定的、优化良好的张量操作库。Keras依赖于处理张量的库就称为“后端引擎”。Keras提供了三种后端引擎Theano/Tensorflow/CNTK，并将其函数统一封装，使得用户可以以同一个接口调用不同后端引擎的函数 Theano是一个开源的符号主义张量操作框架，由蒙特利尔大学LISA/MILA实验室开发。 TensorFlow是一个符号主义的张量操作框架，由Google开发。 CNTK是一个由微软开发的商业级工具包。 1.1 切换后端如果你至少运行过一次Keras，你将在下面的目录下找到Keras的配置文件： c:/user/.keras/keras.json 如果该目录下没有该文件，你可以手动创建一个 文件的默认配置如下： 123456&#123; &quot;image_data_format&quot;: &quot;channels_last&quot;, &quot;epsilon&quot;: 1e-07, &quot;floatx&quot;: &quot;float32&quot;, &quot;backend&quot;: &quot;tensorflow&quot;&#125; 将backend字段的值改写为你需要使用的后端：theano或tensorflow或者CNTK，即可完成后端的切换 2 第一个模型：全连接网络🤩12345678910111213141516171819202122232425262728293031import tensorflow as tffrom keras.layers import Input, Densefrom keras.models import Model# this returns a tensorinputs = Input(shape=(784,))# a layer instance is callable on a tensor, and returns a tensorx = Dense(64, activation='relu')(inputs)x = Dense(64, activation='relu')(x)predictions = Dense(10, activation=softmax)(x)# this creates a model that includes# the Input layer and three Dense layersmodel = Model(input=inputs, output=predictions)model.compile(optimizer='rmsprop', loss='categorical_crossentropy', metrics=['accuracy'])model.fit(data, labels) # starts trainingdef softmax(x, axis=-1): """Softmax of a tensor. # Arguments x: A tensor or variable. axis: The dimension softmax would be performed on. The default is -1 which indicates the last dimension. # Returns A tensor. """ return tf.nn.softmax(x, dim=axis) 2.1 函数介绍2.1.1 Inputnput(shape=None,batch_shape=None,name=None,dtype=K.floatx(),sparse=False,tensor=None) shape: 形状元组（整型） batch_shape: 形状元组（整型） name: 对于该层是可选的名字字符串 dtype: 预期的输入数据类型 sparse: 特定的布尔值，占位符是否为sparse tensor: 可选的存在的向量包装到Input层，如果设置了，该层将不会创建一个占位张量。 返回值：一个张量 2.1.2 Densekeras.layers.core.Dense(output_dim, init=’glorot_uniform’, activation=’linear’, weights=None, W_regularizer=None, b_regularizer=None, activity_regularizer=None, W_constraint=None, b_constraint=None, bias=True, input_dim=None) Dense层就是全链接层 output_dim：大于0的整数，代表该层的输出维度。模型中非首层的全连接层其输入维度可以自动推断，因此非首层的全连接定义时不需要指定输入维度。 init：初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的Theano函数。该参数仅在不传递weights参数时才有意义。 activation：激活函数， weights：权值，为numpy array的list。该list应含有一个形如（input_dim,output_dim）的权重矩阵和一个形如(output_dim,)的偏置向量 W_regularizer：施加在权重上的正则项，为WeightRegularizer对象 b_regularizer：施加在偏置向量上的正则项，为WeightRegularizer对象 activity_regularizer：施加在输出上的正则项，为ActivityRegularizer对象 W_constraints：施加在权重上的约束项，为Constraints对象 b_constraints：施加在偏置上的约束项，为Constraints对象 bias：布尔值，是否包含偏置向量（即层对输入做线性变换还是仿射变换） input_dim：整数，输入数据的维度。当Dense层作为网络的第一层时，必须指定该参数或input_shape参数。 2.1.3 Model函数式模型 常用Model属性 model.layers：组成模型图的各个层 model.inputs：模型的输入张量列表 model.outputs：模型的输出张量列表 2.1.4 Model模型方法compile compile(self, optimizer, loss, metrics=None, loss_weights=None, sample_weight_mode=None, weighted_metrics=None, target_tensors=None) loss=’目标函数’ optimizer：优化器 metrics=[‘accuracy’])metrics: 列表，包含评估模型在训练和测试时的性能的指标 其他，我这个菜鸡用的的比较少，这里不一一列举 fit fit(self, x=None, y=None, batch_size=None, epochs=1, verbose=1, callbacks=None, validation_split=0.0, validation_data=None, shuffle=True, class_weight=None, sample_weight=None, initial_epoch=0, steps_per_epoch=None, validation_steps=None) model.fit（）向模型中输入训练集，验证集，迭代次数 fit()用于使用给定输入训练模型. evaluate evaluate(self, x, y, batch_size=32, verbose=1, sample_weight=None) model.evaluate():就像他的名字一样，主要对模型进行评估 Keras中model.evaluate（）返回的是 损失值和你选定的指标值（例如，精度accuracy） predict predict(self, x, batch_size=32, verbose=0) predict()用于实际预测.它为输入样本生成输出预测. Embedding Embedding(input_dim, output_dim, embeddings_initializer=’uniform’, embeddings_regularizer=None, activity_regularizer=None, embeddings_constraint=None, mask_zero=False, input_length=None) 嵌入层将正整数（下标）转换为具有固定大小的向量，如[[4],[20]]-&gt;[[0.25,0.1],[0.6,-0.2]] Embedding层只能作为模型的第一层 input_dim：大或等于0的整数，字典长度，即输入数据最大下标+1 output_dim：大于0的整数，代表全连接嵌入的维度 embeddings_initializer: 嵌入矩阵的初始化方法，为预定义初始化方法名的字符串，或用于初始化权重的初始化器。参考initializers embeddings_regularizer: 嵌入矩阵的正则项，为Regularizer对象 embeddings_constraint: 嵌入矩阵的约束项，为Constraints对象 mask_zero：布尔值，确定是否将输入中的‘0’看作是应该被忽略的‘填充’（padding）值，该参数在使用递归层处理变长输入时有用。设置为True的话，模型中后续的层必须都支持masking，否则会抛出异常。如果该值为True，则下标0在字典中不可用，input_dim应设置为|vocabulary| + 1。 input_length：当输入序列的长度固定时，该值为其长度。如果要在该层后接Flatten层，然后接Dense层，则必须指定该参数，否则Dense层的输出维度无法自动推断。 3 Keras 实现手写数字识别🤪下载数据.外网，要翻墙，下载速度快赶上蜗牛了 12345import kerasfrom keras.datasets import mnistimport matplotlib.pyplot as plt %matplotlib inline(train_images,train_labels),(test_images,test_labels) = mnist.load_data() 查看一下数据集大小 123456print("shape og train images is ",train_images.shape)print("shape of train label is ",train_labels.shape)print("train labels is ",train_labels)print('shape of test images is ',test_labels.shape)print('shape of test labels is ',test_labels.shape)print("test labels is ",test_labels) 想不想看看手写数字长啥样？？几行代码轻松搞定。 12345plt.figure()plt.imshow(train_images[0])plt.colorbar()plt.grid(False)plt.show() 为什么会有颜色呢？让我们变为灰度图片再看看 12345678910train_images= train_images / 255.0test_images= test_images / 255.0plt.figure(figsize=(10,10))for i in range(25): plt.subplot(5,5,i+1) plt.xticks([]) plt.yticks([]) plt.grid(False) plt.imshow(train_images[i], cmap=plt.cm.binary)plt.show() 好了数据大小也有了，手写数字也看了，接下来就让我们建立神经网络模型了。 建立模型 123456789101112def softmax(x, axis=-1): """Softmax of a tensor. # Arguments x: A tensor or variable. axis: The dimension softmax would be performed on. The default is -1 which indicates the last dimension. # Returns A tensor. """ return tf.nn.softmax(x, dim=axis) 12345678# 设计网络from keras import modelsfrom keras.layers import Denseimport tensorflow as tfnetwork = models.Sequential()network.add(Dense(512,activation = "relu",input_shape=(28*28,)))network.add(Dense(10,activation = softmax)) 训练模型 12345678910111213141516#编译网络network.compile( optimizer = 'rmsprop',loss='categorical_crossentropy',metrics = ['accuracy'])#数据处理train_images = train_images.reshape((60000,28*28))train_images = train_images.astype('float32')/255test_images = test_images.reshape((10000,28*28))test_images = test_images.astype('float32')/255#处理标签from keras.utils import to_categoricaltrain_labels = to_categorical(train_labels)test_labels = to_categorical(test_labels)#训练模型network.fit(train_images,train_labels,epochs = 5,batch_size = 10) 测试模型 123test_loss,test_acc = network.evaluate(test_images,test_labels)print(f'test_loss : &#123;test_loss&#125;')print(f'test_acc :&#123;test_acc&#125;') 4.总结💪以上就简单的实现了用keras实现手写数据的识别，代码简短，但老记不住，忘记该用啥，该怎么拼写😅😅😅，理论基础还是要背牢的，还要多多使用啊，熟能生巧]]></content>
      <categories>
        <category>Keras-note</category>
      </categories>
      <tags>
        <tag>Keras-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Keras-learn-note(1)]]></title>
    <url>%2FAngelNI.github.io%2FKeras-note-1%2F</url>
    <content type="text"><![CDATA[越努力，越幸运。 一些基本概念在开始学习Keras之前，一些基础知识是必备的，关于深度学习的基本概念和技术，在使用Keras之前大体了解一下基础知识，这将减少你学习中的困惑。 1.符号计算Keras的底层库使用Theano或TensorFlow，这两个库也称为Keras的后端。无论是Theano还是TensorFlow，都是一个“符号式”的库。 因此，这也使得Keras的编程与传统的Python代码有所差别。笼统的说，符号主义的计算首先定义各种变量，然后建立一个“计算图”，计算图规定了各个变量之间的计算关系。建立好的计算图需要编译以确定其内部细节，然而，此时的计算图还是一个“空壳子”，里面没有任何实际的数据，只有当你把需要运算的输入放进去后，才能在整个模型中形成数据流，从而形成输出值。 就像用管道搭建供水系统，当你在拼水管的时候，里面是没有水的。只有所有的管子都接完了，才能送水。 Keras的模型搭建形式就是这种方法，在你搭建Keras模型完毕后，你的模型就是一个空壳子，只有实际生成可调用的函数后（K.function），输入数据，才会形成真正的数据流。 2.张量张量是什么，一上来我也一脸懵逼，看了解释之后，嗯嗯。 张量可以看作是向量、矩阵的自然推广，用张量来表示广泛的数据类型。 规模最小的张量是0阶张量，即标量，也就是一个数。 当我们把一些数有序的排列起来，就形成了1阶张量，也就是一个向量 如果我们继续把一组向量有序的排列起来，就形成了2阶张量，也就是一个矩阵 把矩阵摞起来，就是3阶张量，我们可以称为一个立方体，具有3个颜色通道的彩色图片就是一个这样的立方体 把立方体摞起来，好吧这次我们真的没有给它起别名了，就叫4阶张量了，不要去试图想像4阶张量是什么样子，它就是个数学上的概念。 张量的阶数有时候也称为维度，或者轴，轴这个词翻译自英文axis。譬如一个矩阵[[1,2],[3,4]]，是一个2阶张量，有两个维度或轴，沿着第0个轴（为了与python的计数方式一致，本文档维度和轴从0算起）你看到的是[1,2]，[3,4]两个向量，沿着第1个轴你看到的是[1,3]，[2,4]两个向量。 要理解“沿着某个轴”是什么意思，不妨看下下面的代码： 12345678import numpy as npa = np.array([[1,2],[3,4]])sum0 = np.sum(a, axis=0)sum1 = np.sum(a, axis=1)print(sum0)print(sum1) 如果从坐标系的角度看二维矩阵，所谓的0轴就是沿y轴负方向，1轴沿x轴正方向。 3.data_format这是一个无可奈何的问题，在如何表示一组彩色图片的问题上，Theano和TensorFlow发生了分歧，’th’模式，也即Theano模式会把100张RGB三通道的16×32（高为16宽为32）彩色图表示为下面这种形式（100,3,16,32），Caffe采取的也是这种方式。第0个维度是样本维，代表样本的数目，第1个维度是通道维，代表颜色通道数。后面两个就是高和宽了。这种theano风格的数据组织方法，称为“channels_first”，即通道维靠前。 而TensorFlow，的表达形式是（100,16,32,3），即把通道维放在了最后，这种数据组织方式称为“channels_last”。 Keras默认的数据组织形式在~/.keras/keras.json中规定，可查看该文件的image_data_format一项查看，也可在代码中通过K.image_data_format()函数返回，请在网络的训练和测试中保持维度顺序一致。 4.函数式模型函数式模型，这个词很新鲜，好像是官方文档自己创造的。 在Keras 0.x中，模型其实有两种，一种叫Sequential，称为序贯模型，也就是单输入单输出，一条路通到底，层与层之间只有相邻关系，跨层连接统统没有。这种模型编译速度快，操作上也比较简单。第二种模型称为Graph，即图模型，这个模型支持多输入多输出，层与层之间想怎么连怎么连，但是编译速度慢。可以看到，Sequential其实是Graph的一个特殊情况。 在Keras1和Keras2中，图模型被移除，而增加了了“functional model API”，这个东西，更加强调了Sequential是特殊情况这一点。一般的模型就称为Model，然后如果你要用简单的Sequential，OK，那还有一个快捷方式Sequential。 由于functional model API在使用时利用的是“函数式编程”的风格，我们这里将其译为函数式模型。总而言之，只要这个东西接收一个或一些张量作为输入，然后输出的也是一个或一些张量，那不管它是什么鬼，统统都称作“模型”。 5.batch深度学习的优化算法，说白了就是梯度下降。每次的参数更新有两种方式。（我也不知道这个词为神魔出现在这里） 第一种，遍历全部数据集算一次损失函数，然后算函数对各个参数的梯度，更新梯度。这种方法每更新一次参数都要把数据集里的所有样本都看一遍，计算量开销大，计算速度慢，不支持在线学习，这称为Batch gradient descent，批梯度下降。 另一种，每看一个数据就算一下损失函数，然后求梯度更新参数，这个称为随机梯度下降，stochastic gradient descent。这个方法速度比较快，但是收敛性能不太好，可能在最优点附近晃来晃去，hit不到最优点。两次参数的更新也有可能互相抵消掉，造成目标函数震荡的比较剧烈。 为了克服两种方法的缺点，现在一般采用的是一种折中手段，mini-batch gradient decent，小批的梯度下降，这种方法把数据分为若干个批，按批来更新参数，这样，一个批中的一组数据共同决定了本次梯度的方向，下降起来就不容易跑偏，减少了随机性。另一方面因为批的样本数与整个数据集相比小了很多，计算量也不是很大。 基本上现在的梯度下降都是基于mini-batch的，所以Keras的模块中经常会出现batch_size，就是指这个。 顺便说一句，Keras中用的优化器SGD是stochastic gradient descent的缩写，但不代表是一个样本就更新一回，还是基于mini-batch的。 6.epochs这个词不想多说。epochs就是训练过程中数据将被“轮”多少次。]]></content>
      <categories>
        <category>Keras-note</category>
      </categories>
      <tags>
        <tag>Keras-note</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubutu系统文件结构]]></title>
    <url>%2FAngelNI.github.io%2FUbutu_system_file_tree%2F</url>
    <content type="text"><![CDATA[可能我不是最优秀的，但我在努力做你眼中最棒的。 1.文件系统类型windows中常见的磁盘格式有fat16、fat32和ntfs。windows是一个封闭的系统。无法打开ext3或者mac 日志式。 在ubuntu中其文件系统广泛使用ext3(ext4是ext3的扩展)的文件格式，从而实现了将整个硬盘的写入动作完整的记录在磁盘的某个区域上。而且在ubuntu中可以实现主动挂载windows的文件系统，并以只读的方式访问磁盘中windows系统上的文件。 在ubuntu中磁盘文件系统、网络文件系统都可以非常方便的使用，而屏蔽了网络和本地之间的差异。在ubuntu中所有的文件都是基于目录的方式存储的。一切都是目录，一切都是文件。 2.文件系统结构/是一切目录的起点，如大树的主干。其它的所有目录都是基于树干的枝条或者枝叶。在ubuntu中硬件设备如光驱、软驱、usb设备都将挂载到这颗繁茂的枝干之下，作为文件来管理。 /bin: bin是Binary的缩写。存放系统中最常用的可执行文件（二进制）。 /boot: 这里存放的是linux内核和系统启动文件，包括Grub、lilo启动器程序。 /dev: dev是Device(设备)的缩写。该目录存放的是Linux的外部设备，如硬盘、分区、键盘、鼠标、usb等。 /etc: 这个目录用来存放所有的系统管理所需要的配置文件和子目录，如passwd、hostname等。 /home: 用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。 /lib: 存放共享的库文件，包含许多被/bin和/sbin中程序使用的库文件。 /lost+found: 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些零散文件。 /media: ubuntu系统自动挂载的光驱、usb设备，存放临时读入的文件。 /mnt: 作为被挂载的文件系统得挂载点。 /opt: 作为可选文件和程序的存放目录，主要被第三方开发者用来简易安装和卸载他们的软件。 /proc: 这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这里存放所有标志为文件的进程，比较cpuinfo存放cpu当前工作状态的数据。 /root: 该目录为系统管理员，也称作超级权限者的用户主目录。 /sbin: s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序，如系统管理、目录查询等关键命令文件。 / srv: 存放系统所提供的服务数据。 /sys: 系统设备和文件层次结构，并向用户程序提供详细的内核数据信息。 /tmp: 这个目录是用来存放一些临时文件的，所有用户对此目录都有读写权限。 /usr: 存放与系统用户有关的文件和目录。 /usr /usr 目录具体来说： /usr/X11R6: 存放X-Windows的目录； /usr/games: 存放着XteamLinux自带的小游戏； /usr/bin: 用户和管理员的标准命令； /usr/sbin: 存放root超级用户使用的管理程序； /usr/doc: Linux技术文档； /usr/include: 用来存放Linux下开发和编译应用程序所需要的头文件，for c 或者c++； /usr/lib: 应用程序和程序包的连接库； /usr/local: 系统管理员安装的应用程序目录； /usr/man: 帮助文档所在的目录； /usr/src: Linux开放的源代码； /var: /var: 长度可变的文件，尤其是些记录数据，如日志文件和打印机文件。 /var/cache: 应用程序缓存目录； /var/crash: 系统错误信息； /var/games: 游戏数据； /var/log: 日志文件； /var/mail: 电子邮件； /var/tmp: 临时文件目录； 注: ubuntu严格区分大小写和空格，所以Sun和sun是两个不同的文件。 3.推荐一个好用的工具，查看文件的树状目录结构，而且不同类型的文件夹和文件都用不同的颜色标记： sudo apt-get install tree 好东西啊，多美的名字，就叫tree，哈哈，安装好了之后，只要从命令行执行tree命令就可以了： 效果很好： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980dr@dr-Vostro-270:~/workspace/HandlerTest$ tree.├── AndroidManifest.xml├── assets├── bin│ ├── AndroidManifest.xml│ ├── classes│ │ └── com│ │ └── example│ │ └── handlertest│ │ ├── BuildConfig.class│ │ ├── MainActivity$1.class│ │ ├── MainActivity$2.class│ │ ├── MainActivity.class│ │ ├── MainActivity$MyHandler.class│ │ ├── R$attr.class│ │ ├── R.class│ │ ├── R$dimen.class│ │ ├── R$drawable.class│ │ ├── R$id.class│ │ ├── R$layout.class│ │ ├── R$menu.class│ │ ├── R$string.class│ │ └── R$style.class│ ├── classes.dex│ ├── dexedLibs│ │ └── android-support-v4-2ab8acc90e083e9b9a1d83a94491612c.jar│ ├── HandlerTest.apk│ ├── res│ │ ├── drawable-hdpi│ │ │ └── ic_launcher.png│ │ ├── drawable-mdpi│ │ │ └── ic_launcher.png│ │ ├── drawable-xhdpi│ │ │ └── ic_launcher.png│ │ └── drawable-xxhdpi│ │ └── ic_launcher.png│ └── resources.ap_├── gen│ └── com│ └── example│ └── handlertest│ ├── BuildConfig.java│ └── R.java├── ic_launcher-web.png├── libs│ └── android-support-v4.jar├── proguard-project.txt├── project.properties├── res│ ├── drawable-hdpi│ │ └── ic_launcher.png│ ├── drawable-ldpi│ ├── drawable-mdpi│ │ └── ic_launcher.png│ ├── drawable-xhdpi│ │ └── ic_launcher.png│ ├── drawable-xxhdpi│ │ └── ic_launcher.png│ ├── layout│ │ └── activity_main.xml│ ├── menu│ │ └── main.xml│ ├── values│ │ ├── dimens.xml│ │ ├── strings.xml│ │ └── styles.xml│ ├── values-sw600dp│ │ └── dimens.xml│ ├── values-sw720dp-land│ │ └── dimens.xml│ ├── values-v11│ │ └── styles.xml│ └── values-v14│ └── styles.xml└── src └── com └── example └── handlertest └── MainActivity.java]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python command]]></title>
    <url>%2FAngelNI.github.io%2FPip-command%2F</url>
    <content type="text"><![CDATA[不是 ,有钱才善良，而是善良才富足。 pip升级pip show pippython -m pip install –upgrade pip 列出已安装的包 pip list pip安装包pip install 安装包名 pip查看是否已安装pip show [–files] 安装包名 pip检查哪些包需要更新pip list –outdated pip升级包pip install –upgrade 要升级的包名 pip卸载包pip uninstall 要卸载的包名 pip搜索包 pip search SomePackage pip参数解释 12345678910111213141516171819202122232425262728293031323334353637383940pip --helpUsage: pip &lt;command&gt; [options]Commands: install Install packages. download Download packages. uninstall Uninstall packages. freeze Output installed packages in requirements format. list List installed packages. show Show information about installed packages. check Verify installed packages have compatible dependencies. config Manage local and global configuration. search Search PyPI for packages. wheel Build wheels from your requirements. hash Compute hashes of package archives. completion A helper command used for command completion. help Show help for commands.General Options: -h, --help Show help. --isolated Run pip in an isolated mode, ignoring environment variables and user configuration. -v, --verbose Give more output. Option is additive, and can be used up to 3 times. -V, --version Show version and exit. -q, --quiet Give less output. Option is additive, and can be used up to 3 times (corresponding to WARNING, ERROR, and CRITICAL logging levels). --log &lt;path&gt; Path to a verbose appending log. --proxy &lt;proxy&gt; Specify a proxy in the form [user:passwd@]proxy.server:port. --retries &lt;retries&gt; Maximum number of retries each connection should attempt (default 5 times). --timeout &lt;sec&gt; Set the socket timeout (default 15 seconds). --exists-action &lt;action&gt; Default action when a path already exists: (s)witch, (i)gnore, (w)ipe, (b)ackup, (a)bort. --trusted-host &lt;hostname&gt; Mark this host as trusted, even though it does not have valid or any HTTPS. --cert &lt;path&gt; Path to alternate CA bundle. --client-cert &lt;path&gt; Path to SSL client certificate, a single file containing the private key and the certificate in PEM format. --cache-dir &lt;dir&gt; Store the cache data in &lt;dir&gt;. --no-cache-dir Disable the cache. --disable-pip-version-check Don&apos;t periodically check PyPI to determine whether a new version of pip is available for download. Implied with --no-index. --no-color Suppress colored output 将pip源更换到国内镜像 123456常用的国内镜像包括：（1）阿里云 http://mirrors.aliyun.com/pypi/simple/（2）豆瓣http://pypi.douban.com/simple/（3）清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/（4）中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/（5）华中科技大学http://pypi.hustunique.com/ (1) 临时使用：可以在使用pip的时候，加上参数-i和镜像地址(如https://pypi.tuna.tsinghua.edu.cn/simple)。例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pandas，这样就会从清华镜像安装pandas库。 (2) 永久修改，一劳永逸： windows下，直接在user目录中创建一个pip目录，如：C:\Users\xx\pip，然后新建文件pip.ini，即 %HOMEPATH%\pip\pip.ini，在pip.ini文件中输入以下内容（以豆瓣镜像为例）： 1234[global]index-url = http://pypi.douban.com/simple[install]trusted-host = pypi.douban.com]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python command</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Network App Recommend]]></title>
    <url>%2FAngelNI.github.io%2FNetwork-App-Recommend%2F</url>
    <content type="text"><![CDATA[你知道吗，有些人，会以各种你情愿或不情愿的方式，留在你的记忆里，比如我。 Hosting PlatformGithub Gitlab Coding Bitbucket Bitballon 这五个比较常用的托管平台，当然了，这里，Github是全球最大的托管平台，我的博客也是在上面托管。但由于对国内限速，很是难受。其他的四个是我最近发现比较好用的，推荐给大家。 Cloud storageGoole云端硬盘 百度网盘 坚果云 Goole云端硬盘是我比较好用的，能关联许多应用，并且我的Colab的代码在上面，执行代码直接调用就可以了。百度网盘，是我第一个使用储存App，但是在下载上限速，非常_，不过幸好有百度云不限速的破解软件。坚果云，正尝试着去用。至于，其他的云储存，没怎末用过，要是用比较好的，留言推荐给我哦。 Search磁力猫 秘迹搜索 微软bing 鸠摩搜索 除了我们常用的百度谷歌搜狐等搜索引擎外，还有很多好玩的搜索。磁力猫是一个资源搜索引擎，在全网范围内搜索你想要的资源。秘迹搜索，是一个不追踪你位置的良心搜索。微软bing，嗯嗯。鸠摩搜索，是一个搜书的引擎，如果你喜欢看书，可是试试啊。 O JHDU POJ 51 Nod 牛客 洛谷 …… 对于一个计算机爱好者，ACM是最好的检验编程能力的平台，但不是每个人都可以参加ACM比赛的，现在有许多在线的OJ平台来练习你的算法编程能力，有好多，就不一一列举了。]]></content>
      <categories>
        <category>sharing</category>
      </categories>
      <tags>
        <tag>recommend</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appreciation of Novels(2)]]></title>
    <url>%2FAngelNI.github.io%2FAppreciation-of-Novels-2%2F</url>
    <content type="text"><![CDATA[“不要忘记你曾经是怎样的小孩”，“不要忘记你曾希望变成怎样的大人”。 1.她对他很满意。走吧。好。他起身买单，腿却一拐一拐的。难怪他才华横溢，事业有成，却还是单身。趁着他买单，她赶紧悄悄走了。又是一年，她又遇到了他，他正牵着孩子的手，走的飞快。你的腿？她有些诧异。腿？我的腿怎么了？他更诧异。后来，她才知道他的腿，那天只是坐麻了而已。 2.失明后他脾气暴躁。妈妈呵斥道，你这样自暴自弃，从今后我只喊你起床吃饭睡觉，不再管你。果然，从那以后妈妈每天只跟他说这三句话。这让他很愧疚，也渐渐平静下来配合治疗。一年后，他终于复明了，却没看到妈妈。家人告诉他：妈妈一年前就去世了，去世之前录下那三句话，不想影响你的治疗… 3.她花了一周的晚上给他织好了这条围巾，从小娇生惯养，这是她的第一条围巾，她幻想着他惊喜的表情。在他生日的那个晚上，她刚幸福地把围巾给他围上，他却厌倦地取了下来“我不喜欢围巾”！心，瞬间冰凉！爸爸来了，以为是给自己的，自顾地围上，满脸都是幸福的笑容。她转过身来，泪流满面… 4.世界突然爆发一种健忘流行病。我和你都不幸被传染，并且越来越严重。第一天，我们都忘记带钥匙出门，于是只能半夜叫锁匠；第二天，一起做饭结果做出了咖喱牛排，其实我爱吃的是咖喱饭，而你爱菲力牛排；第三天，商场拒绝我的付款，因为我在信用卡的回执上，不管怎么回忆，都只签得出你的名字。 5.“今晚要开会，不用等我了.”“哦，知道了。”挂掉电话，她看着精心准备的一桌子菜发呆.总是忙，连我生日都忘了。门铃响了，“保安，有人看到你家阳台进了窃贼.”“啊?”她惊讶的看着保安鱼贯而入，很快听见阳台传来熟悉的声音：“谁是小偷?我是这房子的业主！喂干什么！别弄坏我蛋糕…” 6.他这一辈子都是默默无闻的在拍戏，演的永远是他的敌人，出镜率不高，并不出名。但他每天最开心的事情就是在公司看到他被粉丝里三层外三层的围住要求签名、合影，他总是微笑着站在一边静静等待，等他摆脱了粉丝走到自己身边对他说：走吧，迟到了导演会骂。据说，他叫奥特曼，他叫小怪兽。 7.儿子怀揣四万块冲进病房，对弥留的老父激动地大喊：“爸！我终于借到钱了！你可以动手术了！！”父亲嘴唇濡动。儿子问：“妈，爸在说什么？咱快叫医生啊！” 母逼近丈夫的脸颊，倾听片刻，对儿子泣道，“你爸想求你个事。你小时候，他常抱你，现在他要走了，你能不能抱一抱他？” 8.情人节，老年痴呆的外公失踪。晚间，医院来电说有位衣服上缝这个电话的老人站在某病房里不肯离去。去接外公时妈妈一进病房便哭了，外婆就是在这间病房去世的。当我看到傻傻的外公手里那支不知从哪里拣来的玫瑰时，忽然想到几年前情人节，我问外公咋不送外婆玫瑰时，外公说傻老太太衬不上玫瑰。 9.她车祸去世后，他思念万分，利用时光机回到过去，阻止惨剧发生。机器出了差错，比预定时间早了几分钟。他拿出钥匙开门，听见卧室传出她的娇喘和男人的声音。她手机响了，他记得这是他打来的。“我得走了，我男人催我呢。”他听着，惹羞成怒，出门偷了一辆车，看着急匆匆的她，一脚踩下油门… 10.这是他从医30年来第一起医疗事故，其实这种手术他做过不知道多少了.当患者死在手术台上的时候，他才意识到自己犯了多大的错误，这把曾经的“神刀”就此成为历史.回家后他异常疲惫，倒在沙发上一言不发.妻子很兴奋的冲出来，“女儿有救了，有个刚死的捐了肾。”“哦。”他握刀的手依旧在抖。 11.他在大街上遇见她，她带着孩子.他问：你还好吗。“挺好的，你呢。”“我也挺好的”，他摸摸小孩儿的头，软软的自来卷，“孩子真可爱，多大了？”“3岁.” 他沉默了一下，“原来我们分手那年你就结婚了.”她没说话，看着他的光头，他攥了下手里的化疗单“我那头自来卷太难打理，剃了.” 12.外人眼里，他们是可爱的龙凤胎。事实上，哥哥是克隆人，他不过是她的备用器官库，他这一生注定为她而活。十六岁那年，妹妹心脏出问题，这意味着哥哥的生命到了尽头。可她不愿意他替她去死，偷跑出去，晕死街头，他背她回来。等她醒来，他不在了，看到一张纸条：“放心，克隆人没有喜悲。” 13.为了庆祝分手后他的第一个生日，她低价卖掉了他往年送给她的每一样生日礼物。然后拿着卖来的钱她去了蛋糕房为他订了一份四层的大蛋糕，和一百根白色的生日蜡烛。他生日那天，随蛋糕一起寄给他的生日贺卡上她用红色的墨水一笔一划地写着：祝你孤独，并且长命百岁。 14.退休在家后，老伴最爱从早到晚数落我又老又胖好吃懒做。今早起床我突然咳嗽并吐出一口鲜血，他看到后整个上午没有说出一句话，闷闷地抽着烟。中午拉我去了医院，最后得知那是我牙龈发炎口腔出的血，他立马就站在医院怒骂我：“你这个没用的胖老太婆…”只是还没骂完，他眼眶里已满是泪水…]]></content>
      <categories>
        <category>literature</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NCF Data Processing]]></title>
    <url>%2FAngelNI.github.io%2FNCF-Data-Processing%2F</url>
    <content type="text"><![CDATA[左眼永远见不到右眼，只能陪她一起哭泣。 NCF数据处理是对论文neural_collaborative_filtering作者所提出的神经网络协同过滤源代码的运行结果，不过在源代码的基础上做了一些更改，运行环境是 python3.6，keras1.2.2，tensorflow1.3.0 ，电脑本地运行约7个小时。 数据处理前言 GMF batch_size=256, dataset=’ml-1m’, epochs=100, learner=’adam’, lr=0.001, num_factors=8, num_neg=4, out=1, path=’Data/‘, regs=’[0,0]’, verbose=1 MLP batch_size=256, dataset=’ml-1m’, epochs=100, layers=’[64,32,16,8]’, learner=’adam’, lr=0.001, num_neg=4, out=1, path=’Data/‘, reg_layers=’[0,0,0,0]’, verbose=1 NeuMF batch_size=256, dataset=’ml-1m’, epochs=100, layers=’[64,32,16,8]’, learner=’adam’, lr=0.001, mf_pretrain=’’, mlp_pretrain=’’, num_factors=8, num_neg=4, out=1, path=’Data/‘, reg_layers=’[0,0,0,0]’, reg_mf=0, verbose=1 #user=6040, #item=3706, #train=994169, #test=6040 评估 leave-one-out 命中率（HR） 归一化折扣累积增益（NDCG） 读取数据123456import pandas as pdimport matplotlib.pyplot as plt%matplotlib inlineGMF = pd.read_table('GMF.txt',header=None, encoding='gb2312', sep=',')MLP = pd.read_table('MLP.txt',header=None, encoding='gb2312', sep=',')NeuMF = pd.read_table('NEUMF.txt',header=None, encoding='gb2312', sep=',') 查看数据 获取数据获取HR数据123456789GMF_HR = []MLP_HR = []NeuMF_HR = []for i in GMF[0]: GMF_HR.append(eval(i[-6:]))for i in MLP[0]: MLP_HR.append(eval(i[-6:]))for i in NeuMF[0]: NeuMF_HR.append(eval(i[-6:])) 获取NDGC123456789GMF_NDGC= []MLP_NDGC = []NeuMF_NDGC = []for i in GMF[1]: GMF_NDGC.append(eval(i[-6:]))for i in MLP[1]: MLP_NDGC.append(eval(i[-6:]))for i in NeuMF[1]: NeuMF_NDGC.append(eval(i[-6:])) 获取loss123456789GMF_loss= []MLP_loss = []NeuMF_loss = []for i in GMF[2]: GMF_loss.append(eval(i[-14:-8]))for i in MLP[2]: MLP_loss.append(eval(i[-14:-8]))for i in NeuMF[2]: NeuMF_loss.append(eval(i[-14:-8])) 图表表示HR对比123456789101112131415f=plt.figure(figsize=(12,10))plt.rcParams['font.sans-serif'] = ['SimHei']plt.title("GMF-MLP-NeuMF HR 对比图",fontsize = 20)plt.xlabel("Iteration",fontsize = 20)plt.ylabel("HR",fontsize = 20)plt.plot(range(100),GMF_HR,label = "GMF")#,linestyle='--')plt.plot(range(100),MLP_HR,label = "MLP")#,linestyle='-.')plt.plot(range(100),NeuMF_HR,label ="NeuMF")plt.scatter(98,0.6437,marker='^',color = 'black')plt.scatter(29,0.6763,marker='^',color = 'black')plt.scatter(35,0.6848,marker='^',color = 'black')plt.legend()plt.grid(c="w")plt.show() NDGC 对比1234567891011121314f=plt.figure(figsize=(12,10))plt.rcParams['font.sans-serif'] = ['SimHei']plt.title("GMF-MLP-NeuMF NDGC 对比图",fontsize = 20)plt.xlabel("Iteration",fontsize = 20)plt.ylabel("NDGC",fontsize = 20)plt.plot(range(100),GMF_NDGC,label = "GMF")plt.plot(range(100),MLP_NDGC,label = "MLP")plt.plot(range(100),NeuMF_NDGC,label ="NeuMF")plt.scatter(98,0.3749,marker='^',color = 'black')plt.scatter(29,0.3988,marker='^',color = 'black')plt.scatter(35,0.4095,marker='^',color = 'black')plt.legend()plt.grid(c="w")plt.show() LOSS 对比1234567891011f=plt.figure(figsize=(12,10))plt.rcParams['font.sans-serif'] = ['SimHei']plt.title("GMF-MLP-NeuMF loss 对比图",fontsize = 20)plt.xlabel("Iteration",fontsize = 20)plt.ylabel("Loss",fontsize = 20)plt.plot(range(100),GMF_loss,label = "GMF")plt.plot(range(100),MLP_loss,label = "MLP")plt.plot(range(100),NeuMF_loss,label ="NeuMF")plt.legend()plt.grid(c ="w")plt.show()]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradient Descent]]></title>
    <url>%2FAngelNI.github.io%2FGradient-Descent%2F</url>
    <content type="text"><![CDATA[最美的等待是，我们——未来可期。 场景引入梯度下降法的基本思想可以类比为一个下山的过程。假设这样一个场景：一个人被困在山上，需要从山上下来(i.e. 找到山的最低点，也就是山谷)。但此时山上的浓雾很大，导致可视度很低。因此，下山的路径就无法确定，他必须利用自己周围的信息去找到下山的路径。这个时候，他就可以利用梯度下降算法来帮助自己下山。具体来说就是，以他当前的所处的位置为基准，寻找这个位置最陡峭的地方，然后朝着山的高度下降的地方走，同理，如果我们的目标是上山，也就是爬到山顶，那么此时应该是朝着最陡峭的方向往上走。然后每走一段距离，都反复采用同一个方法，最后就能成功的抵达山谷。 我们同时可以假设这座山最陡峭的地方是无法通过肉眼立马观察出来的，而是需要一个复杂的工具来测量，同时，这个人此时正好拥有测量出最陡峭方向的能力。所以，此人每走一段距离，都需要一段时间来测量所在位置最陡峭的方向，这是比较耗时的。那么为了在太阳下山之前到达山底，就要尽可能的减少测量方向的次数。这是一个两难的选择，如果测量的频繁，可以保证下山的方向是绝对正确的，但又非常耗时，如果测量的过少，又有偏离轨道的风险。所以需要找到一个合适的测量方向的频率，来确保下山的方向不错误，同时又不至于耗时太多！ Gradient Descent相关概念1.步长或学习效率(learning rare)：步长决定在梯度下降过程中，每一步沿梯度负方向前进的距离。 2.假设函数(hppothesis function)：也就是我们的模型学习到的函数 记为 h_θ(x) = θ0x0+θ1+x1+θ2x2+…=θTX 3.损失函数(loss function): 损失函数是用来评估模型h_θ(x)的好坏，通常用损失函数来度量拟合的程度，线性回归中损失函数通常为label和假设函数输出的差的平方。自己理解为（实际值-真实值）的平方。 损失函数梯度下降的基本过程就和下山的场景很类似。 首先，我们有一个可微分的函数。这个函数就代表着一座山。我们的目标就是找到这个函数的最小值，也就是山底。根据之前的场景假设，最快的下山的方式就是找到当前位置最陡峭的方向，然后沿着此方向向下走，对应到函数中，就是找到给定点的梯度 ，然后朝着梯度相反的方向，就能让函数值下降的最快！因为梯度的方向就是函数之变化最快的方向(在后面会详细解释) 所以，我们重复利用这个方法，反复求取梯度，最后就能到达局部的最小值，这就类似于我们下山的过程。而求取梯度就确定了最陡峭的方向，也就是场景中测量方向的手段。那么为什么梯度的方向就是最陡峭的方向呢？接下来，我们从微分开始讲起 微分看待微分的意义，可以有不同的角度，最常用的两种是： 函数图像中，某点的切线的斜率 函数的变化率 几个微分的例子： 梯度梯度实际上就是多变量微分的一般化。 下面这个例子： 算法过程1.先决条件：确认优化模型的假设函数h_θ(x)和损失函数J_(θ) 2.参数的初始化: 初始化假设函数的参数θ(注：θ是一个向量），算法中止距离ϵ以及步长α 3.确定当前位置的损失函数的梯度，对于θ_j,梯度如下 4.确定是否所有的θ_j,梯度下降的距离都小于ϵ，如果小于则算法中止，当前为最后结果，否则，则重复步骤（3） 5.更新所有的θ，对于θ_j（其更新的表达式如下 梯度下降的形式BGD、SGD、以及MBGD三种算法中文名分别为 批量梯度下降（Batch gradient descent） 批量梯度下降法（Batch Gradient Descent，简称BGD）是梯度下降法最原始的形式，它的具体思路是在更新每一参数时都使用所有的样本来进行更新 优点：全局最优解；易于并行实现； 缺点：当样本数目很多时，训练过程会很慢。 随机梯度下降（Stochastic gradient descent） 随机梯度下降是通过每个样本来迭代更新一次， 如果样本量很大的情况（例如几十万），那么可能只用其中几万条或者几千条的样本，就已经将theta迭代到最优解了，对比上面的批量梯度下降，迭代一次需要用到十几万训练样本，一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。 优点：训练速度快； 缺点：准确度下降，并不是全局最优；不易于并行实现。 小批量梯度下降（Mini-batch gradient descent） 有上述的两种梯度下降法可以看出，其各自均有优缺点，那么能不能在两种方法的性能之间取得一个折衷呢？即，算法的训练过程比较快，而且也要保证最终参数训练的准确率，而这正是小批量梯度下降法（Mini-batch Gradient Descent，简称MBGD）的初衷。MBGD在每次更新参数时使用b个样本（b一般为10） 不过都叫梯度下降算法，可见他们的核心是没有变的，变化的只是取训练集的方式，而梯度下降最核心的就是对函数求偏导，这个是在高等数学里有的。 Practice1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import numpy as npfrom scipy import statsimport matplotlib.pyplot as plt#构造训练数据 h（x）x = np.arange(0.,10.,0.2)m = len(x)x0=np.full(m,1.0)train_data = np.vstack([x0,x]).T #通过矩阵变化得到测试集【x0，x1】y = 4*x+1+np.random.randn(m)#构造“标准”答案def BGD(alpha,loops,epsilon): ''' alpha:步长 loops:循环次数 epsilon:收敛精度 ''' count=0#loop次数 thata = np.random.randn(2)#随机thata向量初始的值也就是起点位置 err = np.zeros(2)#上次thata的值，初始化为0的向量 finish=0#完成标志位 result = [] while count&lt;loops: count+=1 #所有训练数据的期望更新一次thata sum = np.zeros(2)#初始化thata更次年总和 for i in range(m): cost = (np.dot(thata,train_data[i])-y[i])*train_data[i] sum+=cost thata = thata-alpha*sum result.append(np.linalg.norm(thata-err)) if np.linalg.norm(thata-err)&lt;epsilon:#判断是否收敛 finish = 1 break else: err=thata#没有则将当前thata向量赋值给err，作为下次判断参数 print (f'SGD结果:\tloop——counts： [%d]\tthata[%f,%f]'%(count,thata[0],thata[1])) return thata,resultif __name__=='__main__': result=[] thata,result=BGD(0.00009,10000,1e-4) slope,intercept,r_value,p_value,slope_std_error=stats.linregress(x,y) print(f'Stata结果:\tintercept(截距)：[%s]\tslope(斜率)：[%s]'%(intercept,slope)) for i in range(len(result)): plt.scatter(i,result[i]) #plt.plot(x,y,'k+') #plt.plot(x,thata[1]*x+thata[0],'r') plt.show() 结果如下]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Gradient Descent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K-means]]></title>
    <url>%2FAngelNI.github.io%2FK-means%2F</url>
    <content type="text"><![CDATA[天空在高又怎样，抬起脚尖就可以离太阳就更近一点。 聚类对于”监督学习”(supervised learning)，其训练样本是带有标记信息的，并且监督学习的目的是：对带有标记的数据集进行模型学习，从而便于对新的样本进行分类。而在“无监督学习”(unsupervised learning)中，训练样本的标记信息是未知的，目标是通过对无标记训练样本的学习来揭示数据的内在性质及规律，为进一步的数据分析提供基础。对于无监督学习，应用最广的便是”聚类”(clustering)。 聚类是一种无监督的学习，它将相似的对象归到同一簇中。聚类的方法几乎可以应用所有对象，簇内的对象越相似，聚类的效果就越好。K-means算法中的k表示的是聚类为k个簇，means代表取每一个聚类中数据值的均值作为该簇的中心，或者称为质心，即用每一个的类的质心对该簇进行描述。 聚类和分类最大的不同在于，分类的目标是事先已知的，而聚类则不一样，聚类事先不知道目标变量是什么，类别没有像分类那样被预先定义出来，所以，聚类有时也叫无监督学习。 聚类分析试图将相似的对象归入同一簇，将不相似的对象归为不同簇，那么，显然需要一种合适的相似度计算方法，我们已知的有很多相似度的计算方法，比如欧氏距离，余弦距离，汉明距离等。事实上，我们应该根据具体的应用来选取合适的相似度计算方法。 “聚类算法”试图将数据集中的样本划分为若干个通常是不相交的子集，每个子集称为一个“簇”(cluster)，通过这样的划分，每个簇可能对应于一些潜在的概念或类别。 图解 上图是未做标记的样本集，通过他们的分布，我们很容易对上图中的样本做出以下几种划分。 当需要将其划分为两个簇时，即 k=2 时： 当需要将其划分为四个簇时，即 k=4 时： 聚类方法 1.K-means 2.DBSCAN聚类 3.DBSCAN笑脸聚类 k-means (无监督)概念理解kmeans算法又名k均值算法。其算法思想大致为：先从样本集中随机选取 k 个样本作为簇中心，并计算所有样本与这 k 个“簇中心”的距离，对于每一个样本，将其划分到与其距离最近的“簇中心”所在的簇中，对于新的簇计算各个簇的新的“簇中心”。 根据以上描述，我们大致可以猜测到实现kmeans算法的主要三点： （1）簇个数 k 的选择 （2）各个样本点到“簇中心”的距离 （3）根据新划分的簇，更新“簇中心” 前提准备（1）K值的选择 k 的选择一般是按照实际需求进行决定，或在实现算法时直接给定 k 值。 （2）距离的度量 距离的度量的方法有以下几种 1.有序性距离度量 1234（1）闵科夫斯基距离（2）欧式距离（3）曼哈顿距离（4）皮尔逊系数 2.无序属性距离度量 3.混合属性距离度量 算法步骤1、为中心向量c1, c2, …, ck初始化k个种子 2、分组: 12（1）将样本分配给距离其最近的中心向量（2）由这些样本构造不相交（ non-overlapping ）的聚类 3、确定中心: 用各个聚类的中心向量作为新的中心 4、重复分组和确定中心的步骤，直至算法收敛。 3、算法 k-means算法 输入：簇的数目k和包含n个对象的数据库。 输出：k个簇，使平方误差准则最小。 算法步骤： 123451.为每个聚类确定一个初始聚类中心，这样就有K 个初始聚类中心。2.将样本集中的样本按照最小距离原则分配到最邻近聚类3.使用每个聚类中的样本均值作为新的聚类中心。4.重复步骤2.3直到聚类中心不再变化。5.结束，得到K个聚类 伪代码 为避免运行时间过长，通常设置一个最大运行轮数或最小调整幅度阈值，若达到最大轮数或调整幅度小于阈值，则停止运行。 K-means算法分析1、k-means算法的性能分析 主要优点： 是解决聚类问题的一种经典算法，简单、快速。 对处理大数据集，该算法是相对可伸缩和高效率的。因为它的复杂度是0 (n k t ) , 其中, n 是所有对象的数目, k 是簇的数目, t 是迭代的次数。通常k &lt; &lt;n 且t &lt; &lt;n 。 当结果簇是密集的，而簇与簇之间区别明显时, 它的效果较好。 主要缺点 (1)、在簇的平均值可被定义的情况下才能使用，这对于处理符号属性的数据不适用。 (2)、在 K-means 算法中 K 是事先给定的，这个 K 值的选定是非常难以估计的。很多时候，事先并不知道给定的数据集应该分成多少个类别才最合适； (3)、在 K-means 算法中，首先需要根据初始聚类中心来确定一个初始划分，然后对初始划分进行优化。这个初始聚类中心的选择对聚类结果有较大的影响，一旦初始值选择的不好，可能无法得到有效的聚类结果； (4)、该算法需要不断地进行样本分类调整，不断地计算调整后的新的聚类中心，因此当数据量非常大时，算法的时间开销是非常大的； (5)、若簇中含有异常点，将导致均值偏离严重（即:对噪声和孤立点数据敏感）； (6)、不适用于发现非凸形状的簇或者大小差别很大的簇。 K-Means算法对于不同的初始值，可能会导致不同结果。解决方法： 121.多设置一些不同的初值，对比最后的运算结果）一直到结果趋于稳定结束，比较耗时和浪费资源2.很多时候，事先并不知道给定的数据集应该分成多少个类别才最合适。这也是 K-means 算法的一个不足。有的算法是通过类的自动合并和分裂，得到较为合理的类型数目 K. 2、k-means算法的改进方法——k-prototype算法 k-Prototype算法：可以对离散与数值属性两种混合的数据进行聚类，在k-prototype中定义了一个对数值与离散属性都计算的相异性度量标准。 K-Prototype算法是结合K-Means与K-modes算法，针对混合属性的，解决2个核心问题如下： 123451.度量具有混合属性的方法是，数值属性采用K-means方法得到P1，分类属性采用K-modes方法P2，那么D=P1+a*P2，a是权重，如果觉得分类属性重要，则增加a，否则减少a，a=0时即只有数值属性2.更新一个簇的中心的方法，方法是结合K-Means与K-modes的更新方法。3、k-means算法的改进方法——k-中心点算法 k-中心点算法：k -means算法对于孤立点是敏感的。为了解决这个问题，不采用簇中的平均值作为参照点，可以选用簇中位置最中心的对象，即中心点作为参照点。这样划分方法仍然是基于最小化所有对象与其参照点之间的相异度之和的原则来执行的。 实例 由上可以看出，第一次迭代后，总体平均误差值52.25~25.65，显著减小。由于在两次迭代中，簇中心不变，所以停止迭代过程，算法停止。 12345678910111213data = [ [0,2], [0,0], [1,0], [5,0], [5,2]]import numpy as npimport matplotlib.pyplot as plt%matplotlib inlinefor i in range(len(data)): plt.scatter(data[i][0],data[i][1],color='r')plt.show() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162data_n= np.mat(data)def center(data ,k): dim = np.shape(data)[1] cen_M = np.mat(np.zeros((k,dim))) for i in range(dim): minJ = min(data[:,i]) rangeJ = float(max(data[:,i])-minJ) #print() #print('\n') #print(minJ) cen_M[:,i] = np.mat(minJ + rangeJ * np.random.rand(k,1)) #print(data) return cen_M#center(data_n,k)def kmeans(data,k): m = np.shape(data)[0]#列的大小 classassment = np.mat(np.zeros((m,2))) centerpoint = center(data,k) Flag = True conut = 0 while Flag: Flag = False for i in range(m): mindis=np.inf ; minindex=-1 for j in range(k): disJ = np.linalg.norm(np.array(centerpoint[j,:])-np.array(data[i,:])) if disJ &lt; mindis: mindis = disJ; minindex = j; if classassment[i,0] !=minindex: Flag = True classassment[i,:] = minindex,mindis**2 #print(classassment) for cent in range(k): ptsInClust = data[np.nonzero(classassment[:,0].A==cent)[0]]#get all the point in this cluster centerpoint[cent,:] = np.mean(ptsInClust, axis=0)#get all the point in this cluster return centerpoint,classassment centerpoint,classassment=kmeans(data_n,k) def showCluster(dataSet, k, centroids, clusterAssment): ''' 数据可视化,只能画二维的图（若是三维的坐标图则直接返回1） ''' numSamples, dim = dataSet.shape mark = ['or', 'ob', 'og', 'ok','oy','om','oc', '^r', '+r', 'sr', 'dr', '&lt;r', 'pr'] # draw all samples for i in range(numSamples): markIndex = int(clusterAssment[i, 0]) plt.plot(dataSet[i, 0], dataSet[i, 1], mark[markIndex]) mark = ['Pr', 'Pb', 'Pg', 'Pk','Py','Pm','Pc','^b', '+b', 'sb', 'db', '&lt;b', 'pb'] # draw the centroids for i in range(k): plt.plot(centroids[i, 0], centroids[i, 1], mark[i], markersize = 12) plt.show()showCluster(data_n,2,centerpoint,classassment)print(data_n) knn k-means 对比]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>K-means</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matrix Factorization For Recommendation System]]></title>
    <url>%2FAngelNI.github.io%2FMF%2F</url>
    <content type="text"><![CDATA[云是雨的梦，雨是云的前生。 Concept矩阵分解是将矩阵分解为数个矩阵的乘积，用矩阵分解做协同过滤是广泛使用的方法 常见的有三种： 1.三角分解法 2.QR分解法 3.奇异值分解法 Matrix Decomposition Method奇异值分解SVD原始的SVD又名奇异值分解，如果是用户评分矩阵，首先需要对缺失值进行简单的不全，比如用全局平均，然后用SVD进行分解 其中，R为原始的评分矩阵，维度是mn，U和V分贝是一个km和kn的正交矩阵，S为kk的对角矩阵，对角线上的每一个元素都是矩阵的奇异值。这种纯数学的方法计算量特别大，实际应用中的数据根本处理不了。Simon Funk的Funk-SVD方法解决了这个问题，思想很简单：直接通过训练集的观察值利用最小化RMSE学习P、Q矩阵，这就是机器学习的思想了。 SVD++SVD矩阵分解非常成功，有很多的迭代的方法，最有名的就是SVD++了。提SVD++之前，我们先看一个简单的BiasSVD： u 为训练集中所有记录的平均全局数 b_u 为用户的偏置项，表示用户的评分偏好 b_i 为物品的偏置项，表示物品的本身质量 如果将用户历史行为对用户评分预测影响考虑进来就是SVD++算法： SVD++的核心思想是把基于领域的itemCF算法用矩阵分解的方法实现，转换的方法是这样的： Others1.FM 2.隐式反馈矩阵分解 3.基于特征的矩阵分解 MF For Recommendation System对于推荐系统来说存在两大场景即评分预测（rating prediction）与Top-N推荐（item recommendation，item ranking）。评分预测场景主要用于评价网站，比如用户给自己看过的电影评多少分（MovieLens），或者用户给自己看过的书籍评价多少分（Douban）。其中矩阵分解技术主要应用于该场景。Top-N推荐场景主要用于购物网站或者一般拿不到显式评分信息的网站，即通过用户的隐式反馈信息来给用户推荐一个可能感兴趣的列表以供其参考。 有如下R（5，4）的打分矩阵：（“-”表示用户没有打分），其中打分矩阵R（n，m）是n行和m列，n表示user个数，m表示iten个数 那么，如何根据目前的矩阵R（5,4）如何对未打分的商品进行评分的预测（如何得到分值为0的用户的打分值）？ ——矩阵分解的思想可以解决这个问题，其实这种思想可以看作是有监督的机器学习问题（回归问题）。 矩阵R可以近似表示为P与Q的乘积：R（n,m）≈ P(n,K)*Q(K,m) 矩阵分解的过程中，将原始的评分矩阵分解成两个矩阵和的乘积： 矩阵P(n,K)表示n个user和K个特征之间的关系矩阵，这K个特征是一个中间变量，矩阵Q(K,m)的转置是矩阵Q(m,K)，矩阵Q(m,K)表示m个item和K个特征之间的关系矩阵，这里的K值是自己控制的，可以使用交叉验证的方法获得最佳的K值。为了得到近似的R(n,m)，必须求出矩阵P和Q，如何求它们呢？ 步骤 1.首先令 2.损失函数： 使用原始的评分矩阵与重新构建的评分矩阵之间的误差的平方作为损失函数。 如果R（i，j）已知，则R（i，j）的误差平方和为 最终，需要求解所有的非“-”项的损失之和最小值： 3.使用梯度下降法获得修正的p和q分量： 根据梯度方向更新变量 4.不停迭代直至算法最终收敛（直到sum（e^2）&lt;=阈值 加入正则项 1.第一步同上 2.在通常求解过程中，为了能够有较好的泛化能力，会在损失函数中加入正则项对参数进行约束 也就是 3.使用梯度下降法获得修正的p和q 4.不停迭代直至算法最终收敛（直到sum（e^2）&lt;=阈值 【预测】利用上述的过程，我们可以得到矩阵，这样便可以为用户 i 对商品 j 进行打分 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#导包import numpy as npimport matplotlib.pyplot as plt%matplotlib inline#参数设置alph = 0.00049step = 9000beta = 0.05K = 3# MFdef MF(r,p,q,alph,step,beta): result = [] count = 0 while(count&lt;step): count+=1 for i in range(len(r)): for j in range(len(r)): #构建损失函数 if r[i][j]&gt;0: eij = r[i][j] - np.dot(p[i,:],q[:,j]) for k in range(K): pd_p = -2*eij*q[k][j]+beta * p[i][k] pd_q = -2*eij*p[i][k]+beta * q[k][j] p[i][k] -= alph*pd_p q[k][j] -= alph*pd_q e = 0 for i in range(len(r)): for j in range(len(r)): if r[i][j]&gt;0 : eij = r[i][j] - np.dot(p[i,:],q[:,j]) e += eij**2 for n in range(K): e += (beta/2)*(p[i][k]**2+q[k][j]**2) result.append(e) # print(e) return p , q , result #原始矩阵r = [ [1,0,3,0,4], [0,2,1,4,0], [1,0,0,2,3], [2,0,1,0,0], [0,0,2,0,0]]r = np.array(r)print(f"输入矩阵为\n&#123;r&#125;")p = np.random.rand(5,K)q = np.random.rand(K,5)new_p,new_q,result = MF(r,p,q,alph,step,beta)print(f'输出矩阵为\n&#123;np.dot(new_p,new_q)&#125;' )plt.plot(range(len(result)),result) 最后结果如图]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>MF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gobang？]]></title>
    <url>%2FAngelNI.github.io%2FGobang%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[时间带着明显的恶意，缓缓在我的身上流逝 向大家介绍一款游戏，就是五子棋。 什么，五子棋？？？ 没错，就是高大上的五子棋，这是一个基于神经网络用Python写的小游戏五子棋，经过大量的训练，已经很优秀了呢！！！不知道你敢不敢与他战斗啊. Introduce to you a game, that is gobang.What, Gobang???Yes, it’s Gobang in Gaoda. It’s a small game written by Python based on neural network. After a lot of training, it’s already excellent!!! I wonder if you dare to fight him. Github项目地址]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gobang？]]></title>
    <url>%2FAngelNI.github.io%2F%E4%BA%94%E5%AD%90%E6%A3%8B%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[时间带着明显的恶意，缓缓在我的身上流逝 向大家介绍一款游戏，就是五子棋。 什么，五子棋？？？ 没错，就是高大上的五子棋，这是一个基于神经网络用Python写的小游戏五子棋，经过大量的训练，已经很优秀了呢！！！不知道你敢不敢与他战斗啊. Introduce to you a game, that is gobang.What, Gobang???Yes, it’s Gobang in Gaoda. It’s a small game written by Python based on neural network. After a lot of training, it’s already excellent!!! I wonder if you dare to fight him. Github项目地址]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CNN--tensorflow--code-learning]]></title>
    <url>%2FAngelNI.github.io%2FCNN--tensorflow-code-learn%2F</url>
    <content type="text"><![CDATA[不知道未来如何变化，总有人相信童话。 这是以tensorflow为框架，写的关于MNIST数据识别的卷积神经网络的python代码，这个代码是自己一点一点把别人的代码打印到Calab，修改，运行，再修改，再运行，我是代码的生产者，也是代码的搬运工，哈哈~ 发到博客上，也很方便看，啊哈哈哈。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import tensorflow as tf import tensorflow.examples.tutorials.mnist.input_data as input_datamnist = input_data.read_data_sets("MNIST_data/", one_hot=True) #下载并加载mnist数据x = tf.placeholder(tf.float32, [None, 784]) #输入的数据占位符y_actual = tf.placeholder(tf.float32, shape=[None, 10]) #输入的标签占位符#定义一个函数，用于初始化所有的权值 Wdef weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial)#定义一个函数，用于初始化所有的偏置项 bdef bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial) #定义一个函数，用于构建卷积层def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')#定义一个函数，用于构建池化层def max_pool(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],strides=[1, 2, 2, 1], padding='SAME')#定义一个函数，用于初始化所有的权值 Wdef weight_variable(shape): initial = tf.truncated_normal(shape, stddev=0.1) return tf.Variable(initial)#定义一个函数，用于初始化所有的偏置项 bdef bias_variable(shape): initial = tf.constant(0.1, shape=shape) return tf.Variable(initial) #定义一个函数，用于构建卷积层def conv2d(x, W): return tf.nn.conv2d(x, W, strides=[1, 1, 1, 1], padding='SAME')#定义一个函数，用于构建池化层def max_pool(x): return tf.nn.max_pool(x, ksize=[1, 2, 2, 1],strides=[1, 2, 2, 1], padding='SAME')#构建网络x_image = tf.reshape(x, [-1,28,28,1]) #转换输入数据shape,以便于用于网络中W_conv1 = weight_variable([5, 5, 1, 32]) b_conv1 = bias_variable([32]) h_conv1 = tf.nn.relu(conv2d(x_image, W_conv1) + b_conv1) #第一个卷积层h_pool1 = max_pool(h_conv1) #第一个池化层W_conv2 = weight_variable([5, 5, 32, 64])b_conv2 = bias_variable([64])h_conv2 = tf.nn.relu(conv2d(h_pool1, W_conv2) + b_conv2) #第二个卷积层h_pool2 = max_pool(h_conv2) #第二个池化层W_fc1 = weight_variable([7 * 7 * 64, 1024])b_fc1 = bias_variable([1024])h_pool2_flat = tf.reshape(h_pool2, [-1, 7*7*64]) #reshape成向量h_fc1 = tf.nn.relu(tf.matmul(h_pool2_flat, W_fc1) + b_fc1) #第一个全连接层keep_prob = tf.placeholder("float") h_fc1_drop = tf.nn.dropout(h_fc1, keep_prob) #dropout层W_fc2 = weight_variable([1024, 10])b_fc2 = bias_variable([10])y_predict=tf.nn.softmax(tf.matmul(h_fc1_drop, W_fc2) + b_fc2) #softmax层cross_entropy = -tf.reduce_sum(y_actual*tf.log(y_predict)) #交叉熵train_step = tf.train.GradientDescentOptimizer(1e-3).minimize(cross_entropy) #梯度下降法correct_prediction = tf.equal(tf.argmax(y_predict,1), tf.argmax(y_actual,1)) accuracy = tf.reduce_mean(tf.cast(correct_prediction, "float")) #精确度计算sess=tf.InteractiveSession() sess.run(tf.initialize_all_variables())for i in range(20000): batch = mnist.train.next_batch(50) if i%100 == 0: #训练100次，验证一次 train_acc = accuracy.eval(feed_dict=&#123;x:batch[0], y_actual: batch[1], keep_prob: 1.0&#125;) print('step %d, training accuracy %g'%(i,train_acc)) train_step.run(feed_dict=&#123;x: batch[0], y_actual: batch[1], keep_prob: 0.5&#125;)test_acc=accuracy.eval(feed_dict=&#123;x: mnist.test.images, y_actual: mnist.test.labels, keep_prob: 1.0&#125;)print("test accuracy %g"%test_acc) 博文参考：https://morvanzhou.github.io/tutorials/machine-learning/tensorflow/5-03-CNN1/]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KNN-Self-practice]]></title>
    <url>%2FAngelNI.github.io%2FKNN-Practice%2F</url>
    <content type="text"><![CDATA[有一天我结婚了，你一定要来哦，因为没有新娘，那该有多尴尬. 这是我的自己写的第一个KNN比较简单的练习案例，有关于KNN的介绍请参考我的上篇博文 This is my first simple exercise case of KNN written by myself. For an introduction to KNN, please refer to my last blog post. 我在这里 123456789101112131415161718192021222324252627#导包import numpy as npfrom matplotlib import pyplot as pltimport operator%matplotlib inline#自我创建数据集data=[ [0.8,1.8], [0.9,2.1], [1.0,1.5], [1.2,1.9], [1.3,2.0], [2.5,1.7], [2.8,1.5], [2.5,1.4], [2.7,1.9], [2.6,1.8], [1.9,3.3], [2.0,2.9], [2.2,2.8], [2.1,2.9], [1.8,3.0],]label=['a','a','a','a','a','b','b','b','b','b','c','c','c','c','c']print(label)train_data = np.array(data)print(train_data) 12345678910111213141516171819202122232425262728293031x_1=[]y_1=[]x_2=[]y_2=[]x_3=[]y_3=[]for i in range(5): x_1.append(data[i][0]) y_1.append(data[i][1]) x_2.append(data[i+5][0]) y_2.append(data[i+5][1]) x_3.append(data[i+10][0]) y_3.append(data[i+10][1])x = []y = []for j in range(15): x.append(data[j][0]) y.append(data[j][1])plt.scatter(x,y)print(f'&#123;x_1&#125; \n &#123;y_1&#125;\n&#123;x_2&#125; \n &#123;y_2&#125;\n&#123;x_3&#125;\n &#123;y_3&#125; ')f,ax=plt.subplots(1,1,figsize=(10,10))for i in range (5): ax.scatter(x_1[i],y_1[i],label='skitcat',color='r',marker='o') ax.scatter(x_2[i],y_2[i],label='skitcat',color='b',marker='o') ax.scatter(x_3[i],y_3[i],label='skitcat',color='g',marker='o')test = [[1.5,2.85]]##自定义点，从图中可以看出，很明显属于第三类x_test=1.5y_test=2.85ax.scatter(test[0][0],test[0][1],label='skitcat',color='m',marker = 'x')test = np.array(test) 从图中可以看出，很明显属于第三类 1234#定义距离公式def d_euc(x, y):#欧式距离 d = np.sqrt(np.sum(np.square(x- y))) return d 123456789101112131415161718192021def KNN(train_data,test,label,k): distance=[] for i in train_data: distance.append(d_euc(i,train_data)) distance = np.array(distance) index = distance.argsort() # 获取按距离大小排序后的索引 #print(index) sort_dis = np.sort(distance) count=&#123;&#125; o=0 print(label) for i in index: o=o+1 label_vote=label[i] count[label_vote] = count.get(label_vote,0)+1 ##返回特定的键值，否则返回 0 if o&gt;k: break print(label_vote) print(count) final_outcome=majory_vote(count) return final_outcome 12345#定义决策方案——多数表决法def majory_vote(count): sorted_class_count = sorted( count.items(), key=operator.itemgetter(1), reverse=True) return sorted_class_count 12345label=['a','a','a','a','a','b','b','b','b','b','c','c','c','c','c']test=[3.0,2.0]test = np.array(test)final_label = KNN(train_data,test,label, 6)final_label 最后结果 )) 可以发现最初我们看到的真实结果一样属于c类。]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[KNN——k-Nearest Neighbor]]></title>
    <url>%2FAngelNI.github.io%2FKNN%E2%80%94%E2%80%94k-Nearest-Neighbor%2F</url>
    <content type="text"><![CDATA[海绵宝宝：“派大星，你为什么叫派大星” 派大星：“因为我是上帝拍下来保护你的大星星” 一、Concept1.1Language DescriptionK最近邻(k-Nearest Neighbor，KNN)分类算法，是一个理论上比较成熟的方法，也是最简单的机器学习算法之一。该方法的思路是：如果一个样本在特征空间中的k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别，则该样本也属于这个类别。即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例（也就是所说的K个邻居）， 这K个实例的多数属于某个类，就把该输入实例分类到这个类中。 KNN 算法的核心思想和最近邻算法思想相似，都是通过寻找和未知样本相似的类别进行分类。但 NN 算法中只依赖 1 个样本进行决策，在分类时过于绝对，会造成分类效果差的情况，为解决 NN 算法的缺陷，KNN 算法采用 K 个相邻样本的方式共同决策未知样本的类别,这样在决策中容错率相对于 NN 算法就要高很多，分类效果也会更好。 1.2 graphic例子：要区分“猫”和“狗”，通过“claws”和“sound”两个feature来判断的话，圆形和三角形是已知分类的了，那么这个“star”代表的是哪一类呢？ k＝3时，这三条线链接的点就是最近的三个点，那么圆形多一些，所以这个star就是属于猫。 二、Algorithmic Description1.pseudo code 2.steps 初始化距离为最大值 计算未知样本和每个训练样本的距离dist 得到目前K个最邻近样本中的最大距离maxdist 如果dist小于maxdist，则将该训练样本作为K-最近邻样本 重复步骤2,3,4，直到未知样本和所有训练样本的距离都算完 统计K个最近邻样本中每个类别出现的次数 选择出现频率最大的类别作为未知样本的类别 三、KNN‘s three elements of model1.Distance measure距离度量，说白了就是距离计算公式。 常见的距离计算公式有如下： 1.欧氏距离 2.曼哈顿距离 3.余弦距离 4.皮尔逊系数 5.杰卡德距离 6.闵可夫斯基距离 7.切比雪夫距离 8.汉明距离 9.莱文斯坦距离1.1Euclidean distance欧氏距离是最常见的两点之间或多点之间的距离表示法，又称之为欧几里得度量，它定义于欧几里得空间中，是闵可夫斯基距离=2特殊情形. def d_euc(x, y): d = np.sqrt(np.sum(square(x - y))) return d1.2Manhattan Distance 12345def d_man(x, y): d = np.sum(abs(x - y)) return d 2.Selection of K Value不要小看了这个K值选择问题，因为它对K近邻算法的结果会产生重大影响。 1. 如果选择较小的K值，就相当于用较小的领域中的训练实例进行预测，“学习”近似误差会减小，只有与输入实例较近或相似的训练实例才会对预测结果起作用，与此同时带来的问题是“学习”的估计误差会增大，换句话说，K值的减小就意味着整体模型变得复杂，容易发生过拟合； 2. 如果选择较大的K值，就相当于用较大领域中的训练实例进行预测，其优点是可以减少学习的估计误差，但缺点是学习的近似误差会增大。这时候，与输入实例较远（不相似的）训练实例也会对预测器作用，使预测发生错误，且K值的增大就意味着整体的模型变得简单。 3. K=N，则完全不足取，因为此时无论输入实例是什么，都只是简单的预测它属于在训练实例中最多的累，模型过于简单，忽略了训练实例中大量有用信息。 3.Classification Decision Rules1.多数表决法 多数表决法类似于投票的过程，也就是在 K 个邻居中选择类别最多的种类作为测试样本的类别。 2.加权表决法 根据距离的远近，对近邻的投票进行加权，距离越近则权重越大，通过权重计算结果最大值的类为测试样本的类别。]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>KNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[map函数的简单用法]]></title>
    <url>%2FAngelNI.github.io%2Fmap%E5%87%BD%E6%95%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[你要开心，你要快乐，因为你是大哥，不可以难过。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[My First Neural Network Construction]]></title>
    <url>%2FAngelNI.github.io%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[啊啊啊Ｏ(≧口≦)Ｏ！！！我的第一个神经网络竟然是算出来的。 学习了简单的神经网络模型，今天出于兴趣，自己搭个神经网络的巨简单的模型，不不不，是算出来的。 这篇代码是根据我的上一篇博客点我吧根据推导公式写的，小白技能有限，大佬不要嘲笑啊。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import numpy as npimport matplotlib.pyplot as plt%matplotlib inline#激活函数及导数def sigmoid(x): return 1 / (1 + np.exp(-x))def d_sigmoid(x): return x * (1 - x) def tanh(x): return np.tanh(x)def d_tanh(x): return 1.0 - np.tanh(x) * np.tanh(x)##参数设置alph = 0.5esp = 0.01step = 5000#前向传播def qianxiangchuanbo(init,weight,b): #输入层——&gt;隐含层 neth=[]#神经元输入加权和 outh=[]#神经元输出 #隐含层---&gt;输出层 neto=[]#输出神经元 outo=[]#神经元输出 neth.append(weight[0]*init[0]+weight[1]*init[1]+b[0]) neth.append(weight[2]*init[0]+weight[3]*init[1]+b[0]) outh.append(sigmoid(neth[0])) outh.append(sigmoid(neth[1])) neto.append(weight[4]*outh[0]+weight[5]*outh[1]+b[1]) neto.append(weight[6]*outh[0]+weight[7]*outh[1]+b[1]) outo.append(sigmoid(neto[0])) outo.append(sigmoid(neto[1])) return neth,outh,neto,outodef fanxiangchuanbo(out,outo,outh): new_weight=[] q=[] #输如层——&gt;隐藏层 a1=(-(init[0]-outo[0])*outo[0]*(1-outo[0])) a2=(-(init[1]-outo[1])*outo[1]*(1-outo[1])) q.append(a1) q.append(a2) w1 = q[0]*weight[4]+q[1]*weight[6]*outh[0]*(1-outh[0])*init[0] w2 = q[0]*weight[4]+q[1]*weight[6]*outh[0]*(1-outh[0])*init[1] w3 = q[0]*weight[5]+q[1]*weight[7]*outh[1]*(1-outh[1])*init[0] w4 = q[0]*weight[5]+q[1]*weight[7]*outh[1]*(1-outh[1])*init[1] new_weight.append(w1) new_weight.append(w2) new_weight.append(w3) new_weight.append(w4) #输出层——&gt;隐藏层 w5 = -(out[0]-outo[0])*outo[0]*(1-outo[0])*outh[0] w6 = -(out[0]-outo[0])*outo[0]*(1-outo[0])*outh[1] w7 = -(out[1]-outo[1])*outo[1]*(1-outo[1])*outh[0] w8 = -(out[1]-outo[1])*outo[1]*(1-outo[1])*outh[1] new_weight.append(w5) new_weight.append(w6) new_weight.append(w7) new_weight.append(w8) return new_weight#输入集init = [0.05,0.10]#真实输出集out = [0.01,0.99]#权重weight = [0.15,0.20,0.25,0.30,0.40,0.45,0.50,0.55]#偏置项b=[0.35,0.60]count=0result = []while True: count=count+1 neth,outh,neto,outo = qianxiangchuanbo(init,weight,b) e=(abs(out[0]-outo[0])+abs(out[1]-outo[1])) result.append(e) gd_weight = fanxiangchuanbo(out,outo,outh) for i in range(len(weight)): weight[i]=weight[i]-alph*gd_weight[i] # if e&lt;esp: # break if count &gt; step: breakfor k in range(len(result)): plt.scatter(k,result[k])plt.show()print(weight)print(out)print(outo) 最后的运行结果如图 由于此代码只运行了5000次，可以看出与实际的差距还是很大的，如果感兴趣，你可以试试增大迭代次数，或者控制精度。]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>NN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Artificial Neural Networks——Activation Funcation]]></title>
    <url>%2FAngelNI.github.io%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B9%8B%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[有时候不敢去拥有，因为害怕失去，所以非常努力地去奋斗，让自己累，让自己不去想。 激活函数定义 所谓激活函数（Activation Function），就是在人工神经网络的神经元上运行的函数，负责将神经元的输入映射到输出端。 判定每个神经元的输出 通俗来说，激活函数一般是非线性函数，其作用是能够给神经网络加入一些非线性因素，使得神经网络可以更好地解决较为复杂的问题。 常见的激活函数 1.sigmoid 2.tanh 3.ReLu 4.ELU 5.PReLU 这里简单的对前三个进行介绍 1.sigmoid Sigmoid 函数的取值范围在 (0,1) 之间，单调连续，求导容易，一般用于二分类神经网络的输出层。 sigmoid函数图像如图 sigmoid函数求导 缺点： 123451.Sigmoid 函数饱和区范围广，容易造成梯度消失2.参数矩阵 W 的每个元素都会朝着同一个方向变化，同为正或同为负。这对于神经网络训练是不利的，所有的 W 都朝着同一符号方向变化会减小训练速度，增加模型训练时间。3.Sigmoid 函数包含 exp 指数运算，运算成本也比较大 2.tanh 图像如图 tanh 函数的取值范围在 (-1,1) 之间，单调连续，求导容易。 相比于 Sigmoid 函数，tanh 函数的优点主要有两个： 121.其一，收敛速度更快，如下图所示，tanh 函数线性区斜率较 Sigmoid 更大一些。在此区域内训练速度会更快。2.其二，tanh 函数输出均值为零，也就不存在 Sigmoid 函数中 dW 恒为正或者恒为负，从而影响训练速度的问题。 缺点： 1tanh 函数与 Sigmoid 函数一样，也存在饱和区梯度消失问题。其饱和区甚至比 Sigmoid 还要大一些，但不明显。 3.ReLu 优点： 12345671.没有饱和区，不存在梯度消失问题。2.没有复杂的指数运算，计算简单、效率提高。3.实际收敛速度较快，大约是 Sigmoid/tanh 的 6 倍。4.比 Sigmoid 更符合生物学神经激活机制。 缺点： 121. ReLU 的输出仍然是非零对称的，可能出现 dW 恒为正或者恒为负，从而影响训练速度。2. 当 x&lt;0 时，ReLU 输出总为零。该神经元输出为零，则反向传播时，权重、参数的梯度横为零，造成权重、参数永远不会更新，即造成神经元失效，形成了“死神经元”。 如何选择激活函数1234567891.首选 ReLU，速度快，但是要注意学习速率的调整，2.如果 ReLU 效果欠佳,尝试使用 Leaky ReLU、ELU 或 Maxout 等变种。3.可以尝试使用 tanh。4.Sigmoid 和 tanh 在 RNN（LSTM、注意力机制等）结构中有所应用，作为门控或者概率值。其它情况下，减少 Sigmoid 的使用。5.在浅层神经网络中，选择使用哪种激励函数影响不大。]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>NN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Artificial Neural Networks]]></title>
    <url>%2FAngelNI.github.io%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E2%80%94%E2%80%94%E6%A1%88%E4%BE%8B%E7%AE%80%E5%8D%95%E6%8E%A8%E5%AF%BC%2F</url>
    <content type="text"><![CDATA[现在终于理解我们高中数学老师说的话了，计算不行，说明数学不行，数学不行能力不行，数学好才是真正的好！！！哈哈哈。 这是典型的三层神经网络的基本构成，Layer L1是输入层，Layer L2是隐含层，Layer L3是隐含层，我们现在手里有一堆数据{x1,x2,x3,…,xn},输出也是一堆数据{y1,y2,y3,…,yn},现在要他们在隐含层做某种变换，让你把数据灌进去后得到你期望的输出。 在这里，通过对上图简单的案例进行数学推导,激活函数默认为sigmoid函数（注：神经网络的基础知识可以参考Poll的笔记：[Mechine Learning &amp; Algorithm] 神经网络基础） 一、前向传播1.输入层—-&gt;隐含层计算神经元的输入加权和 计算神经元 h1、h2 的输出 2.隐含层—-&gt;输出层计算输出神经元o1、o2的值 至此，前向传导传播结束。 二、反向传播1.计算总误差 2.隐藏层—–&gt;输出层权值更新 同理可求 权值跟新 3.隐藏层—-&gt;输出层权值更新 权值跟新 权值更新后测试数据，会发现数据误差变小许多 三、栗子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import numpy as np#激励函数与其偏导数def tanh(x): return np.tanh(x)def tanh_derivative(x): return 1.0 - np.tanh(x) * np.tanh(x)def logistic(x): return 1 / (1 + np.exp(-x))def logistic_derivative(x): return logistic(x) * (1 - logistic(x) )#神经网络模型class NeuralNetwork: def __init__(self, layers, activation='tanh'): if activation == 'Logistic': self.activation = logistic self.activation_deriv = logistic_derivative elif activation == 'tanh': self.activation = tanh self.activation_deriv = tanh_derivative self.weights = [] for i in range(1, len(layers)-1): # [0,1) * 2 - 1 =&gt; [-1,1) =&gt; * 0.25 =&gt; [-0.25,0.25) 随机权值 self.weights.append( (2*np.random.random((layers[i-1] + 1, layers[i] + 1 ))-1 ) * 0.25 ) self.weights.append( (2*np.random.random((layers[i] + 1, layers[i+1] ))-1 ) * 0.25 ) # for i in range(0, len(layers)-1): # m = layers[i] # 第i层节点数 # n = layers[i+1] # 第i+1层节点数 # wm = m + 1 # wn = n + 1 # if i == len(layers)-2: # wn = n # weight = np.random.random((wm, wn)) * 2 - 1 # self.weights.append(0.25 * weight) #类比梯度下降 def fit(self, X, y, learning_rate=0.2, epochs = 10000): X = np.atleast_2d(X) # temp = np.ones([X.shape[0], X.shape[1]+1]) # temp[:,0:-1] = X # X = temp X = np.column_stack((X, np.ones(len(X)))) y = np.array(y) for k in range(epochs): i = np.random.randint(X.shape[0]) a = [X[i]] # 正向计算 for l in range(len(self.weights)): a.append(self.activation( np.dot(a[l], self.weights[l])) ) # 反向传播 error = y[i] - a[-1] deltas = [error * self.activation_deriv(a[-1])] # starting backprobagation layerNum = len(a) - 2 for j in range(layerNum, 0, -1): # 倒数第二层开始 deltas.append(deltas[-1].dot(self.weights[j].T) * self.activation_deriv(a[j])) # deltas.append(deltas[-(layerNum+1-j)].dot(self.weights[j].T) * self.activation_deriv(a[j])) deltas.reverse() for i in range(len(self.weights)): layer = np.atleast_2d(a[i]) delta = np.atleast_2d(deltas[i]) self.weights[i] += learning_rate * layer.T.dot(delta) def predict(self, x): x = np.array(x) temp = np.ones(x.shape[0] + 1) temp[0:-1] = x a = temp for l in range(0, len(self.weights)): a = self.activation(np.dot(a, self.weights[l])) return ann = NeuralNetwork([2, 2, 1], 'tanh')x = np.array([[0,0],[0,1],[1,0],[1,1]])y = np.array([0,1,1,0])nn.fit(x, y)for i in [[0,0],[0,1],[1,0],[1,1]]: print (i, nn.predict(i)) 这是我的运行结果]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>NN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordCloud——A Beautiful Cloud of Words]]></title>
    <url>%2FAngelNI.github.io%2FWordCloud%2F</url>
    <content type="text"><![CDATA[I miss you。 词云图 Word nephogramWordcloud 是Python第三方库中用于制作简单分词云图的第三方库，可以根据自己喜欢的颜色，喜欢的形状制作出美丽的词云图。 所谓的词云图，也叫文字云，是对文本中出现频率较高的“关键词”予以视觉化的展现，词云图过滤掉大量的低频低质的文本信息，使得浏览者只要一眼扫过文本就可领略文本的主旨。可以在每次的报告中迅速的找到核心词汇，掌握接下来发展的目的，方向。 实现快速生成词云图建立一个file.txt的文本文件，把你要统计的文章保存的这个文件中，运行如下的代码就可以看到词云图啦 1234567891011121314from os import pathfrom wordcloud import WordCloudimport matplotlib.pyplot as plt# Read the whole text.text = open('file.txt').read()# Generate a word cloud imagewordcloud = WordCloud().generate(text)# Display the generated image:# the matplotlib way:plt.imshow(wordcloud, interpolation='bilinear')plt.axis("off") 效果如图 自定义形状上面的词云图又丑有难看对不对，不要着急，这里可以自定义词云图的形状，自定义颜色。 在这里我的图片是一张心形 12345678910111213141516171819202122from os import pathfrom PIL import Imageimport numpy as npfrom wordcloud import WordCloudimport matplotlib.pyplot as pltd=path.dirname('E:\\study\\jupyter notebook')text=open(path.join(d,"constitution.txt")).read()alice_mask = np.array(Image.open(path.join(d, "2.jpg")))wordcloud=WordCloud(background_color="white",max_words=2000,mask=alice_mask)wordcloud.generate(text)wordcloud.to_file(path.join(d,"3.jpg"))# 步骤4-1：创建一个图表画布plt.figure(10)# 步骤4-2：设置图片plt.imshow(wordcloud, interpolation="bilinear")# 步骤4-3：取消图表x、y轴plt.axis("off")# 显示图片plt.show() 是不是很有趣呀！ 还有很多有趣的东西等你发现呢]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Just do it!]]></title>
    <url>%2FAngelNI.github.io%2FJust-do-it%2F</url>
    <content type="text"><![CDATA[放假了哈，啊哈哈哈啊哈哈~🤣🤣 今天，7月11日，考完了最后一科大学物理，结束了大一一年的学习生活，话说匆匆，也来不及挥手。 大一这一年，自我感觉收获还是蛮多的，参加过青年志愿者志愿活动❤️，去支过教❤️，参加过社团学习，学过硬件的一些东西，在宿舍焊过电路板😱，做过变压器（这个是基础，没啥高大上的），只是，后来没坚持下来，自我解释到毕竟不是学电气专业的😑😑。作为一个计算机专业的，学好编程才对嘛，现在简单的掌握了C语言和Python，入门级别，还有许多要深入。其实，在这个学期，一直想进算法协会ACM，第一次选拔也没如愿，还好在第二次选拔靠运气进了。兴致冲冲的准备好好学习算法，好好打比赛，拿个奖还能炫耀一下（白日做梦中ing🙃🙃），临期末的突转，跑去学AI😵，还好有数据挖掘的基础，入门的机器学习的算法还是能理解，能简单用Python实现 （学习笔记在GitHub我的仓库中有😎）。希望在这个暑期培训中，能有收获🙏🙏，之后的一年中好好学习AI，希望能有个比较好的成果。当然，算法也要学的，AI的老师也是我们下学期的数据结构的老师😮😮，算法，灵魂啊，除了书本知识，会实际实践才是最重要的。大学，自我学习才是最重要的。比如博客我真是一点不懂，只是按照百度上的教程，查找教程，向同学问，开始搭建，一开始，折腾了三四天，才看起来比较像样。还是比较有感触的，从没有到有，今天，我才能在这里 b b😂😂。 大一的一年至此结束了，还有两个月就大二了，好慌好慌真的好慌。 没有暑假，有了第一次，还差第二次吗？]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Learning makes me happy]]></title>
    <url>%2FAngelNI.github.io%2FLearning-makes-me-happy%2F</url>
    <content type="text"><![CDATA[SharingThere are many interesting things waiting to be discovered by us . It’s never too late to learn. Don’t indulge yourself , don’t let yourself regret . 图灵机器人在线聊天这是一个基于图灵机器人和微信公众号相结合推出的微信在线聊天系统。 如果你对这个感兴趣这里有实现的操作 –&gt;&gt; It’s me 百度云下载 It’s me 提取码: ejuh 程序员的暖心话 to who?我们虽然不是浪漫的产生者，但我们可以做浪漫的搬运工。 项目：everywechat 功能：定时给朋友发送天气，提醒，每日一句，也可以智能自动回复好友，基于图灵机器人 项目地址：who is me QQ木马的简单实现，核心编程Finding from D的个人博客 QQ总是被盗怎么办？ 作为一个程序猿，对底层的代码还是了解一下子。只供参考，技术交流，后果自负。 百度云不限速下载器Baidu Netdisk Downloader是一款图形界面的百度网盘不限速下载器，支持 Windows、Linux、Mac。 在线工具，程序员的工具箱光说不能表达，附图一张 我在这呢！ python3 教程这个是最近发现的，里面有很多有关python的教程，还有一些实战项目。 没错又是我 经典技术书籍分享我又来喽]]></content>
      <categories>
        <category>sharing</category>
      </categories>
      <tags>
        <tag>sharing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CET4]]></title>
    <url>%2FAngelNI.github.io%2FCET4%2F</url>
    <content type="text"><![CDATA[COME ON !!! 很高兴有这次机会提前考四级，希望要过呀，好好学英语，下学期六级要过啊。 在这里简单介绍一下四级。 一 、四级题型1.作文（15%） 2.听力（35%） （1）听力对话（15%） （2）听力短文（20%） 3.阅读理解（35%） （1）词汇理解（5%） （2）长篇阅读（10%） （3）仔细阅读（20%） 4.汉译英（15%） 总分 ：710，及格线：425 二、考前准备1.词汇英语单词是学习英语的基础，基础不牢，地动山摇，好好买一本英语四级的词汇书很重要（我买的是新东方的），要背单词哦。现在有很多背单词的APP，比如百词斩，有道词典，我认为不靠谱，看着看着，就看别的了（都懂的吧），还有个人认为纸质的书拿起来有感觉。 2.听力最头疼的就是听力了，占了很大的分值，听力就多听吧。还有就是要知道他可能会考什么，猜。 3.阅读理解做阅读理解，一定要多做题，买一本近几年的四级考试卷子每周一套（整个上半年我们老师是这样要求的），找到自己的做题感觉和方法很重要。 4.翻译多背一些固定搭配，多背一些词组，还有就是单词~ 三、考试时间安排 注意：答题卡分为两张1和2，先写作文，听力，听力结束后开始收答题卡1。 最后要预祝考四级的小伙伴，考的全会，蒙的全对。]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[俄罗斯方块]]></title>
    <url>%2FAngelNI.github.io%2FTetris%2F</url>
    <content type="text"><![CDATA[嘿！小伙伴们，还记得俄罗斯方块吗？想必每个人都玩过这个简单刺激的小游戏吧！ 在这里分享给大家一个在线的俄罗斯方块——&gt;&gt; 大爷！来玩呦 github项目地址 点我呦 百度云源代码下载 点我呦 提取码：wb6q]]></content>
      <categories>
        <category>Game</category>
      </categories>
      <tags>
        <tag>Game</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数取模]]></title>
    <url>%2FAngelNI.github.io%2F%E5%A4%A7%E6%95%B0%E5%8F%96%E6%A8%A1%2F</url>
    <content type="text"><![CDATA[THIS A SAD STORY…… 頑張って 介绍取模想必大家都知道，比如7%5=2，10%3=1，当然了，这还只是简单的取模，适用于不超过计算机整数范围。如果超过了该怎么办呢？ 今天，这里介绍的就是大数取模。 一般取模大数储存对一个相当大的数，C语言里的整形是无法储存的，在这里，我们用字符串储存。 取模方法模仿我们曾学过的竖式乘除法。 对于一个大数 A ，他从高到低的每一位乘以10再对mod取余，最后的结果就是取模的结果。 ` 12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;cstring&gt;using namespace std;#define MOD 100000007long divmod(char *ch,int a)&#123; long s = 0; for(int i=0;ch[i]!='\0';i++) &#123; s=(s*10+ch[i]-'0')%MOD; &#125; return s;&#125;int main()&#123; long a,b; char num[100000]; gets(num); a = strlen(num); b = divmod(num,a); printf("%ld",b); return 0; &#125; ` 快速幂取模对于一般的大数取模，时间复杂度太大，可能会TE了。对于指数型的大数取模问题，，快速幂取模就简单方便多了，在空间和时间上相对于一般取模都做了优化。 方法快速幂取模的方法基于离散数学或数论的一条公式推导引理。 积的取余等于取余的积的取余 在这个定义的基础上对指数型数据进行拆分以及合并，从而实现快速幂取模。 举个栗子求（3^40）mod 6。 (3^40)–&gt;(9^20)–&gt;(18^10) ……这样依次类推 这里指数幂是偶数，如果是奇数先乘在重复上述工作。 再这里有一个简单判断奇偶数的方法。附上代码 123456789101112#include&lt;stdio.h&gt;int main()&#123; int n; while(~scanf("%d",&amp;n))&#123; if(n&amp;1) printf("奇数"); else printf("偶数");&#125; return 0;&#125; 这里简单的运用了位运算。这比一般奇偶的判断高大上多了。活到老学到老。。。 实现12345678910111213long powermode(long a, long b, long mod)&#123; long ans = 1; while (b) &#123; if (b &amp; 1) &#123; ans = (ans * a) % mod; b--; &#125; b /= 2; a = a * a % mod; &#125; return ans;&#125; 补充对于大数取模还有欧拉函数（费马小定理），技巧去摸，这里不多介绍，后续会补上]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约数个数定理]]></title>
    <url>%2FAngelNI.github.io%2F%E7%BA%A6%E6%95%B0%E4%B8%AA%E6%95%B0%E5%AE%9A%E7%90%86%2F</url>
    <content type="text"><![CDATA[自从那时起，它就有了特别的含义，既是与她的一种约定，也是自己出海航行的方向。one piece 是我的，我可是要成为海贼王的男人哈哈哈。 引言今天遇到了一个有意思的题，让你求一个范围内的约数的个数的最大值，求约数个，哈哈，这真是简单，1,2,3,4从头数不就行了吗，你看我说的对不对哈哈。 还有一种办法是通过约数个数定理，好，废话说得不少，那就进入正题~ 定理百度百科 对于一个大于1正整数n可以分解质因数 ： 约数个数定理——来自百度百科 内容对于一个大于1正整数n可以分解质因数： 则n的正约数的个数就是 。 其中a1、a2、a3…ak是p1、p2、p3，…pk的指数。 证明首先同上，n可以分解质因数：n=p1^a1×p2^a2×p3^a3…pk^ak, 由约数定义可知p1^a1的约数有:p1^0, p1^1, p1^2……p1^a1 ，共（a1+1）个;同理p2^a2的约数有（a2+1）个……pk^ak的约数有（ak+1）个。 故根据乘法原理：n的约数的个数就是(a1+1)(a2+1)(a3+1)…(ak+1)。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS_Practice]]></title>
    <url>%2FAngelNI.github.io%2FDFS-practive%2F</url>
    <content type="text"><![CDATA[DFS——exercise.I learned DFS last month,I almost forgot how to use it,so that I can’t solve a problem in a practice competition. So I require to review it,and review carefully! Question在这里你有一个 6*3 的一个数组，每行有1 ， 2 ， 3 三个数，并且每行按照六种顺序分别排列。当每一行都取一个数时，求出6个数之和最大的值。 这里有一个非常笨的方法，就是用六重For循环，是不是很惊讶。没错，当我的小伙伴告诉我时,我的内心是WTF的。 这不是重点，重点是想通过这个简单的题练习一下DFS的思想。 这仅仅是个简单的开始， Code12345678910111213141516171819202122232425#include&lt;iostream&gt;using namespace std;int a[10][5];int res;void dfs(int x,int sum = 0)&#123; if(x&gt;5) &#123; //printf("%d",res); res = max(res,sum); return; &#125; dfs(x+1,sum+a[x][0]); //dfs(x+1,sum+a[x][1]); //dfs(x+1,sum+a[x][2]);&#125;int main（）&#123; for(int i=0;i&lt;6;i++) for(int j =0;j&lt;3;j++) cin&gt;&gt;a[i][j]; dfs(0); cout&lt;&lt;res&lt;&lt;endl; return 0; &#125; FIRST第一次我控制只输入第一列，输出结果为六。 仔细想想，这个跟递归求n的阶乘有异曲同工之妙，不断的调用自己递归，直到满足条件回归。 SECOND这次我输入了6*2的数据，并将每次的相加求和的结果打印出来，算了算一共64种，也就是说一共有64种组合方法。 THIRD最后我将所有的数据输入得到了正确的结果18。 LAST仔细想想还是挺有趣的，想想那个yong FOR循环写的，一共729种可能，想想就可怕. TE,TE,TE,TE……. DFS模板介绍DFS问题的解决有一个dfs的套用模板，自我感觉挺有用的，如果你有更好的办法，留评论呦！！！ 123456789101112131415void dfs(step)`&#123; if(num==end) &#123; /*do something*/ return ;&#125; /*尝试每一种可能，和遍历数组差不多*/ for(int i =0;i&lt;end;i++) &#123; do something; dfs(step+1); undo something; &#125;rerun 0;`&#125; 回溯问题Q这里拿棋盘问题举个栗子。 POJ1321 请点击这里 在一个给定形状的棋盘（形状可能是不规则的）上面摆放棋子，棋子没有区别。要求摆放时任意的两个棋子不能放在棋盘中的同一行或者同一列，请编程求解对于给定形状和大小的棋盘，摆放k个棋子的所有可行的摆放方案C。 INPUT 输入含有多组测试数据。每组数据的第一行是两个正整数，n k，用一个空格隔开，表示了将在一个n*n的矩阵内描述棋盘，以及摆放棋子的数目。 n &lt;= 8 , k &lt;= n当为-1 -1时表示输入结束。随后的n行描述了棋盘的形状：每行有n个字符，其中 # 表示棋盘区域， . 表示空白区域（数据保证不出现多余的空白行或者空白列）。 OUTPUT 对于每一组数据，给出一行输出，输出摆放的方案数目C （数据保证C&lt;2^31）。 SOLVE1234567891011121314151617181920212223int DFS(int x,int y) &#123; if(y&gt;=k） &#123; ans++; return 0; &#125; for(int i=x;i&lt;n;i++) &#123; for(int j=0;j&lt;n;j++) &#123; if(!visit[j]&amp;&amp;mp[i][j]=='#')//回溯 &#123; visit[j]=1; DFS(i+1,y+1); visit[j]=0; &#125; &#125; &#125; return 0; &#125;在这里menset（visit，0，sizeof（visit））； DFS过程中，你要退一步，就必然需要保存你走过每个点的所有信息，而在退一步的过程中，你需要从当前状态回到之前的状态，那么这步操作就是回溯，回溯是递归的时候一定会产生的很自然的操作，只不过大部分情况下不需要回溯。]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fleury 算法]]></title>
    <url>%2FAngelNI.github.io%2FFleury-%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Fleury 算法Fleury算法是从离散书上看到的，书上详细的写了算法的操作。在这里用主要用C语言实现。在这里隆重感谢曹老板的鼎力支持。膜拜~ 伪代码输入 ：欧拉图 任取 v0∈V(G),令P0 = v0 ，i = 0. 设 Pi = v0e0v1e1……eivi, 1如果E（G） - &#123;e1,e2……ei&#125;中没有与vi关联的边则计算停止；否则按下述条件从E（G） -&#123;e1，e2，……ei&#125;中任取一条边ei+1： （a） ei+1与vi相关联； （b） 除非无别的边可提供，否则ei+1不应该为Gi = G-{e1，e2，……ei}中的桥。 设ei+1=（vi,vi+1）,把ei+1,vi+1加入pi得到pi+1. 令i=i+1，返回2. 实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;stdio.h&gt;void fleury ();int Bridge (int m, int k);int eulertu[10000][10000] = 0;int V,E;int main ()&#123;printf(“顶点数：”);scanf(“%d”,&amp;V);printf(“边数：”);scanf(“%d”,&amp;E); //输入几个点，几条边int i,j;int m,n;int count;int o=1;printf(“输入有边的俩个点:\n”);for (i = 0; i &lt; E; i++)&#123;scanf("%d %d",&amp;m,&amp;n); //输入有边的俩个点 eulertu[m][n] = eulertu[n][m] = 1; &#125;for (i = 0; i &lt; V; i++) //判断是否为欧拉图 &#123; count = 0; for (j = 0; j &lt; V; j++) &#123; if (eulertu[i][j]==1) count++; &#125; if (count%2!=0) &#123; printf("不是欧拉图"); o=0; break; &#125; if(o==0) break; &#125;if(o==1)&#123; fleury(); printf("end");&#125; return 0;&#125;void fleury ()&#123;int a[10000] =&#123;0&#125;;int i,j;int k = 0;int bridge = 1;int t;printf(“%d—&gt;”,a[0]);for (i = 0; i &lt; E; i++)&#123;for (j = 0; j &lt; V; j++)&#123;if(eulertu[a[k]][j]==1)&#123;eulertu[a[k]][j] = eulertu[j][a[k]] = 0;if(Bridge(a[k],j))&#123;t = j;eulertu[a[k]][j] = eulertu[j][a[k]] = 1;&#125;else&#123;k++;a[k] = j;printf(“%d—&gt;”,j);bridge = 0;break;&#125; &#125; &#125; if (bridge) &#123; eulertu[a[k]][t] = eulertu[t][a[k]] = 0; k++; a[k] = t; printf("%d---&gt;",t); &#125; bridge = 1;&#125;&#125;int Bridge (int m, int k)&#123;int a[10000];int i = 0;int t = 0;int n = 0;int p = 0;for(i=0;i&lt;10000;i++)a[i]=-1;a[t] = m;for (t = 0; a[t] != -1; t++ )&#123;for (i = 0; i &lt; V; i++)&#123;if (eulertu[a[t]][i] == 1 &amp;&amp; i == k)return 0;if (eulertu[a[t]][i] == 1)&#123; p=0; while(a[p]==-1) &#123; p++; n++; a[n] = i; &#125; &#125; &#125;&#125;return 1;&#125; ​]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fermat's Last Theorem]]></title>
    <url>%2FAngelNI.github.io%2FFermat-s-Last-Theorem%2F</url>
    <content type="text"><![CDATA[QuestionDescription 对于输入的n,判断这个一个三元方程xn+yn=znx^n+y^n=z^nx**n+y**n=z*n*是否有整数解 Input 单组输入 第一行一个整数TTT,代表输入的数据个数 接下来T行，每行一个正整数n。 1≤T≤100 1≤n≤100000 Output 输出T行，对于每个输入的n,如果有整数解输出”YES”,否则输出”NO”. Analyse费马大定理，又被称为“费马最后的定理”，由17世纪法国数学家皮耶·德·费玛提出。 他断言当整数n &gt;2时，关于x, y, z的方程 x^n + y^n = z^n 没有正整数解。 费马达定理的证明有一个非常巧妙的方法证明，自己去领悟精髓吧。 code12345678910111213141516#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6+100;typedef long long ll;int main()&#123;int n,t;cin&gt;&gt;t;for(int i=1;i&lt;=t;i++)&#123;cin&gt;&gt;n;if(n&lt;=2) cout&lt;&lt;"YES"&lt;&lt;endl;else cout&lt;&lt;"NO"&lt;&lt;endl;&#125;return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python_Operation on Excel]]></title>
    <url>%2FAngelNI.github.io%2FPython-Operation-on-Excel%2F</url>
    <content type="text"><![CDATA[====This my mood now==== I recently solve the problem of Excel ‘ data , it is hard to process Excel data because of huge amount of it.However, there is a better tool to process–Python.I simply write 34 lines to operation on Excel’s data to count th number of the key word. Just for recording. code12345678910111213141516171819202122232425262728293031323334import xlrdimport xlwtimport reimport numpy as npimport pandas as pd#import openpyxldata = xlrd.open_workbook('C:\\Users\\hp\\Desktop\\数据信息3.xlsx')table = data.sheets()[0]ncols = table.col_values(12)a = len(ncols)pattern = re.compile(r'\d+')d=[]for i in range(1,a): #print(pattern.findall(ncols[i])) # print("\n") b = len(pattern.findall(ncols[i])) c=[] for j in range(0,b): if eval(pattern.findall(ncols[i])[j] )&lt; 10 : c.append(pattern.findall(ncols[i])[j]) #print(c) d.append(len(c)) #print(d) f = xlwt.Workbook() #创建工作簿sheet1 = f.add_sheet(u'sheet1',cell_overwrite_ok=True) #创建sheetfor i in range(0,len(d)): sheet1.write(i+1,0,d[i])f.save("C:\\Users\\hp\\Desktop\\2.xls")print("结束")]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[A New Start]]></title>
    <url>%2FAngelNI.github.io%2FA-New-Start%2F</url>
    <content type="text"><![CDATA[This is a nice day!!! After half a day’s hard work, my blog is successfully included by baidu and google,and I add some new features to my blog for attracting more people to visit. As we all know,photo is a good way to look back our experience,so I specially add Photo to my blog.I change the background of my blog,making it not monotonous.The big change is that my blog language is changed to Engelish and I begin to write blog in English ,thanks to my classmate Uncle_drew’s idea,and thanks for his blog ,I learn a lot from it. Thank you @ https://cndrew.cn/ Lastly,I sincerely hope that I can insist writing blog .]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Poetry Appreciation]]></title>
    <url>%2FAngelNI.github.io%2FPoetry-Appreciation%2F</url>
    <content type="text"><![CDATA[I think poetry is a kind of life experience,a kind of inner sublimation.Cultivate sentiment and enrich oneself. 木兰花令——纳兰性德 人生若只如初见，何事秋风悲画扇?等闲变却故人心，却道故人心易变。 骊山语罢清宵半，泪雨零铃终不怨。何如薄幸锦衣郎，比翼连枝当日愿。 仓央嘉措《四》好多年了 你一直在我的伤口中幽居 我放下过天地 却从未放下过你 我生命中的千山万水 任你一一告别 世间事 除了生死 哪一件不是闲事 谁的隐私不被回光返照 殉葬的花朵开合有度 菩提的果实奏响了空山 告诉我 你藏在落叶下的那些脚印 暗示着多少祭日 专供我在法外逍遥 致橡树——舒婷 我如果爱你——绝不像攀援的凌霄花，借你的高枝炫耀自己； 我如果爱你——绝不学痴情的鸟儿，为绿荫重复单调的歌曲； 也不止像泉源，常年送来清凉的慰藉； 也不止像险峰，增加你的高度，衬托你的威仪。甚至日光，甚至春雨。 不，这些都还不够！ 我必须是你近旁的一株木棉，作为树的形象和你站在一起。 根，紧握在地下；叶，相触在云里。 每一阵风过，我们都互相致意，但没有人，听懂我们的言语。 你有你的铜枝铁干，像刀，像剑，也像戟；我有我红硕的花朵，像沉重的叹息，又像英勇的火炬。 我们分担寒潮、风雷、霹雳；我们共享雾霭、流岚、虹霓。 仿佛永远分离，却又终身相依。 这才是伟大的爱情，坚贞就在这里： 爱——不仅爱你伟岸的身躯，也爱你坚持的位置，足下的土地。 一棵开花的树——席慕蓉 如何让你遇见我 在我最美丽的时刻 为这 我已在佛前求了五百年 求佛让我们结一段尘缘 佛於是把我化做一棵树 长在你必经的路旁 阳光下 慎重地开满了花 朵朵都是我前世的盼望 当你走近 请你细听 那颤抖的叶 是我等待的热情 而当你终於无视地走过 在你身後落了一地的 朋友啊 那不是花瓣 那是我凋零的心 热爱生命——汪国真 我不去想是否能够成功 既然选择了远方 便只顾风雨兼程 我不去想能否赢得爱情 既然钟情于玫瑰 就勇敢地吐露真诚 我不去想身后会不会袭来寒风冷雨 既然目标是地平线 留给世界的只能是背影 我不去想未来是平坦还是泥泞 只要热爱生命 一切，都在意料之中]]></content>
      <categories>
        <category>literature</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML学习]]></title>
    <url>%2FAngelNI.github.io%2FHTML%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[HTNL——BeginHyper Text Markup Language ，short for HTML ,is a standard markup language for creating web pages.The web pages which we usually scan are written by it.I want to learn a fewer about it because of writing blog and modifying my blog’s framework. I need it. The simply example1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;title&gt;this is a title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;First level title&lt;/h1&gt; &lt;p&gt;paragraph&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; explanation 12345678&lt;!DOCTYPE html&gt; 声明HTML5文档&lt;html&gt; 元素是HTML页面的根元素&lt;head&gt; 元素包含了文档的元数据&lt;title&gt; 文档的标题&lt;body&gt; 可见的页面内容&lt;h1&gt; 一级标题&lt;p&gt; 段落&lt;meta charset = "utf-8"&gt; 声明编码utf-8 Others1.HTML link1&lt;a href="http://baidu.com"&gt;This is baidu link&lt;/a&gt; 2.picture1&lt;imag scr="(url)" width="258" height="39" /&gt; 3.lind feed1&lt;br/&gt; 4.level1&lt;hr&gt; 5.notes1&lt;!--notes--&gt; 6.bold1&lt;b&gt; bold &lt;/b&gt; I simply learned basics of HTML.Maybe it is very simply ,but it’s a new stduy.Come on !!!]]></content>
      <categories>
        <category>Learning</category>
      </categories>
      <tags>
        <tag>Learing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天生棋局(指针)]]></title>
    <url>%2FAngelNI.github.io%2F%E5%A4%A9%E7%94%9F%E6%A3%8B%E5%B1%80-%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[上次用数组写的天生棋局题，这里补上指针版的。 题目描述中国传统文化源远流长，博大精深，包含着华夏先哲的无穷智慧，也是历朝历代炎黄子孙生活的缩影。围棋作为中华民族流传已久的一种策略性棋牌游戏，蕴含着丰富的汉民族文化内涵，是中国文明与中华文化的体现。本案例要求创建一个棋盘，在棋盘生成的同时初始化棋盘，根据初始化后棋盘中棋子的位置来判断此时的棋局是否是一局好棋。具体要求如下：** 1）棋盘的大小根据用户的指令确定； 2）棋盘中棋子的数量也由用户设定； 3）棋子的位置由随机数函数随机确定，若生成的棋盘中有两颗棋子落在同一行或同一列，则判定为“好棋”，否则判定为“不是好棋”。 #注释天生棋局指针类型的和上次数组类型的大体思路是一样的，在这里主要不同的，在于用calloc（）函数申请一个动态的存储空间，因为calloc（）函数成功生成动态存储空间会返回储存空间的首地址，所以在这里用指针类型的变量来实现对动态存储空间的操作。 这里主要用二维指针，二维指针储存一维指针的地址，二维指针可以看做二维数组，而二维数组可以看做由一维数组组生成，这样理解起来比较简单些 附上关键自定义生成动态存储函数 123456789 int ** board(int n)&#123; int ** p = (int **)calloc(sizeof(int*), n);//calloc在内存中分配n*size大小的动态存储空间，返回一个起始地址的一个指针 for (int i = 0; i &lt; n; i++) &#123; p[i] = (int *)calloc(sizeof(int), n); &#125; return p;&#125; 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int ** board(int n); //申请动态存储空间 void inkey(int **p,int n,int m);//用随机数下棋 void printboard(int **p,int n);//打印棋格 int check(int **p,int n);//检查好/坏棋 void freespace(int **p,int n);//释放动态空间 int main()&#123; int n,m,con; printf("请输入棋盘大小:\n"); scanf("%d",&amp;n); printf("请输入棋子数量:\n"); scanf("%d",&amp;m); int **p=board(n); inkey( p ,n, m ); printboard(p,n); con=check(p,n); freespace(p,n); if(con) printf("好棋！"); else printf("不是好棋！"); return 0; &#125; int ** board(int n)&#123; int ** p = (int **)calloc(sizeof(int*), n);//calloc在内存中分配n*size大小的动态存储空间，返回一个起始地址的一个指针 for (int i = 0; i &lt; n; i++) &#123; p[i] = (int *)calloc(sizeof(int), n); &#125; return p;&#125;void inkey(int **p,int n,int m)&#123; srand((unsigned int)time(NULL)); //随机数种子 生成伪随机数，每次的随机数都不一样 while(m--) &#123; int a=rand()%n,b=rand()%n; p[a][b]=1; &#125;&#125;void printboard(int **p,int n)&#123; for(int i=0;i&lt;n;i++) // 生 成 棋 盘 &#123; for(int j =0;j&lt;n;j++) // ┏ ┓┗ ┛┠ ┷ ┨ ┯ ┼ ● &#123; if(p[i][j]==1) printf("●"); else &#123; if (i == 0 &amp;&amp; j == 0) printf("┏"); else if (i == 0 &amp;&amp; j == n - 1) printf("┓"); else if (i == n - 1 &amp;&amp; j == 0) printf("┗"); else if (i == n - 1 &amp;&amp; j == n - 1) printf("┛"); else if (j == 0) printf("┠"); else if (i == n - 1) printf("┷"); else if (j == n - 1) printf("┨"); else if (i == 0) printf("┯"); else printf("┼"); &#125; &#125; putchar('\n'); &#125; &#125;int check(int **p,int n)&#123; int flag = 0; // 默认不是好棋。 for(int i=0;i&lt;n;i++) // 判断 好棋 坏棋 &#123; for(int j=0;j&lt;n;j++) &#123; if (p[i][j] == 1) &#123; if (j&gt;0 &amp;&amp; p[i][j-1] == 1) //判断同一行有无相邻棋子 &#123; flag = 1; &#125; if (i &gt;0 &amp;&amp; p[i-1][j] == 1) //判断同一列有无相邻棋子 &#123; flag = 1; &#125; &#125; &#125; &#125; return flag;&#125;void freespace(int **p,int n)&#123; for (int i= 0; i &lt; n; i++) &#123; free(p[i]); //释放一级指针指向的空间 &#125; free(p); //释放二级指针指向的空间&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sort() function]]></title>
    <url>%2FAngelNI.github.io%2Fsort_function%2F</url>
    <content type="text"><![CDATA[C++中的sort（）函数我在之前的博客中提到，解决排序问题的一个好用的函数就是C++的sort（）函数啦。sort（）函数是C++内置的函数，只需要加入头文件，掌握正确的使用方法，你就可以在排序中驰骋疆场了（自吹自擂）。好啦，下面就请主角登场吧 sort()1.介绍c++语言中 STL 库中的sort函数可以用来对数组进行排序。对于c++语言来说由于其自带的sort()函数更容易被编译器编译，其排序速度比基于快速排序的qsort要快上不少，且用法简单。(百度知道) 2.准备sort（）函数的使用需要添加头文件 123#include&lt;algorithm&gt;或者万能头文件#include&lt;bits/stdc++.h&gt; 3.使用方法sort（star,end,cmp）* sort函数有三个参数： 1.第一个是要排序的数组的起始地址 2.第二个是结束地址（最后一位的地址的下一地址） 3.第三个参数是排序的方法。sort函数默认是按从小到大排序。可以修改cmp实现从大到小排序 123sort（begin，end，less&lt;data-type&gt;)——升序sort（begin，end，greater&lt;data-type&gt;)——降序 以上是比较简单常用的对数组的排序方法，sort（）类函数中还有其他的排序功能。 4.sort()类函数 函数名 功能描述 sort 对给定区间所有元素进行排序 stable_sort 对给定区间所有元素进行稳定排序 partial_sort 对给定区间所有元素进行稳定排序 partial_sort 对给定区间所有元素部分排序 partial_sort_copy 对给定区间复制并排序 nth_element 找出给定区间的某个位置对应的元素 is_sorted 判断一个区间是否已经排好序 partition 使得符合某个条件的元素放在前面 stable_partition 相对稳定的使得符合某个条件的元素放在前面 5.sort（）函数练习1.有序序列合并链接： https://ac.nowcoder.com/acm/contest/827/J 来源：牛客网 题目描述 输入两个升序排列的序列，将两个序列合并为一个有序序列并输出。 输入描述: 1234567输入包含三行，第一行包含两个正整数n, m（1 ≤ n,m ≤ 100），用空格分隔。n表示第二行第一个升序序列中数字的个数，m表示第三行第二个升序序列中数字的个数。第二行包含n个整数（范围1~5000），用空格分隔。第三行包含m个整数（范围1~5000），用空格分隔。 输出描述: 输出为一行，输出长度为n+m的升序序列，即长度为n的升序序列和长度为m的升序序列中的元素重新进行升序序列排列合并。 示例1 输入5 61 3 7 9 222 8 10 17 33 44输出1 2 3 7 8 9 10 17 22 33 44 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int n,m,t;int a[100],b[100],c[200];int main()&#123; cin&gt;&gt;n&gt;&gt;m; t=n; for(int i=0;i&lt;n;i++) &#123; cin&gt;&gt;a[i]; c[i]=a[i]; &#125; for(int i=0;i&lt;m;i++) &#123; cin&gt;&gt;b[i]; c[t++]=b[i]; &#125; sort(c,c+m+n); for(int i=0;i&lt;m+n;i++) &#123; cout&lt;&lt;c[i]; putchar(' '); &#125; return 0; &#125; 2.最高最低分差链接： https://ac.nowcoder.com/acm/contest/827/E 来源：牛客网 题目描述 输入n个成绩，换行输出n个成绩中最高分数和最低分数的差。 输入描述: 123两行，第一行为n，表示n个成绩，不会大于10000。第二行为n个成绩（整数表示，范围0~100），以空格隔开。 输出描述: 1一行，输出n个成绩中最高分数和最低分数的差。 示例1 输入 121098 100 99 97 95 99 98 97 96 100 输出 5 12345678910111213141516#include&lt;stdio.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;int main()&#123; int n,a[10000],sum=0; scanf("%d",&amp;n); for(int i=0;i&lt;n;i++) scanf("%d",&amp;a[i]); sort(a,a+n); sum=a[n-1]-a[0]; printf("%d",sum); return 0; &#125;]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DFS]]></title>
    <url>%2FAngelNI.github.io%2FDFS%2F</url>
    <content type="text"><![CDATA[DFS深度优先搜索算法（Depth-First-Search），是搜索算法的一种。是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。当节点v的所有边都己被探寻过，搜索将回溯到发现节点v的那条边的起始节点。这一过程一直进行到已发现从源节点可达的所有节点为止。如果还存在未被发现的节点，则选择其中一个作为源节点并重复以上过程，整个进程反复进行直到所有节点都被访问为止（属于盲目搜索）。 “一路走到头，不撞墙不回头” 深度优先搜索属于图算法的一种，是一个针对图和树的遍历算法，英文缩写为DFS即Depth First Search。深度优先搜索是图论中的经典算法，利用深度优先搜索算法可以产生目标图的相应拓扑排序表，利用拓扑排序表可以方便的解决很多相关的图论问题，如最大路径问题等等。一般用堆数据结构来辅助实现DFS算法。其过程简要来说是对每一个可能的分支路径深入到不能再深入为止，而且每个节点只能访问一次。 树状图图解例如，想要从1到9，每到一个岔路口你有两种选择，你可以选择左枝，或者右枝，共两种可能，但是当你走到死胡同时，你只能原路返回，走到这个死胡同的上一个路口，走另一条路，依次类推，直到走到终点，也就是九。你可能会问，这不明摆着呢吗，直接从1经过8到9不就行了。没错，这是最直接的办法，但计算机傻啊，没有你聪明啊，它只会，一次一次的尝试，直到最终结果。 下面是图解 例题给定整数a1、a2、…….an，判断是否可以从中选出若干数，使它们的和恰好为K。 输入 首先，n和k，n表示数的个数，k表示数的和。接着一行n个数。（1&lt;=n&lt;=20,保证不超int范围） 输出 如果和恰好可以为k，输出“YES”，否则“NO” 样例输入 1234 131 2 4 7 样例输出 1YES 思路每一个数有加与不加两种可能，从树的一枝不加到尾，然后，再从叶末返回上一层叶节点，走另一个分支，也就是加上最后一个，与所求的和比较，不符再重复上述操作。直到找到与所求和相等返回Yes 实现1234567891011121314151617181920212223242526#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;int n,k,a[50];int dfs(int i,int sum)&#123; if(i==n) return sum==k; if(dfs(i+1,sum)) return 1; if(dfs(i+1,sum+=a[i])) return 1; return 0; &#125;int main()&#123; cin&gt;&gt;n&gt;&gt;k; for(int i=0;i&lt;n;i++) cin&gt;&gt;a[i]; if(dfs(0,0)) cout&lt;&lt;"YES"&lt;&lt;endl; else cout&lt;&lt;"No!"&lt;&lt;endl; return 0; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[天生棋局]]></title>
    <url>%2FAngelNI.github.io%2F%E5%A4%A9%E7%94%9F%E6%A3%8B%E5%B1%80%2F</url>
    <content type="text"><![CDATA[天生棋局问题，是C语言老师留的一个课外练习题。要求有用指针来写，因为指针学的不扎实，也因为第一次看到这道题时，第一个想法就是要用数组来写，所以以下是用数组对天生棋局代码。(指针的会后续补上) 题目描述中国传统文化源远流长，博大精深，包含着华夏先哲的无穷智慧，也是历朝历代炎黄子孙生活的缩影。围棋作为中华民族流传已久的一种策略性棋牌游戏，蕴含着丰富的汉民族文化内涵，是中国文明与中华文化的体现。本案例要求创建一个棋盘，在棋盘生成的同时初始化棋盘，根据初始化后棋盘中棋子的位置来判断此时的棋局是否是一局好棋。具体要求如下：** 1）棋盘的大小根据用户的指令确定； 2）棋盘中棋子的数量也由用户设定； 3）棋子的位置由随机数函数随机确定，若生成的棋盘中有两颗棋子落在同一行或同一列，则判定为“好棋”，否则判定为“不是好棋”。 题前注释1.随机数头文件： 1#include&lt;stdlib.h&gt; And #include&lt;time.h&gt; 函数： 1.rand()函数生成伪随机数。 2.随机发生器的初始化函数`srand(unsigned seed) 目的： rand（）函数是按指定的顺序来产生整数，但可能两次的随机数相同并不是真正的随机，叫做伪随机数。而随机发生器的初始化函数`srand(unsigned seed)（也位于stdlib.h）进行伪随机数列初始化，通过用时间函数time（NULL）作为seed，使每一次产生的随机数都不一样。 2.棋盘，棋子这是一个下棋的游戏，如果把随机的产生的棋子赤果果地展现在棋盘上，效果会很明显，并且题目说要生成棋盘，所以首先要打印一个棋盘 打印棋盘，首先要有边框和棋子，这些是从word上copy来的,然后用双层循环就可以了。 3.判断好/坏棋根据题意即可 疑惑根据题意，他说若生成的棋盘中有两颗棋子落在同一行或同一列，则判定为“好棋”，否则判定为“不是好棋”。但与查的资料不同，说是两颗棋子相邻是好棋。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt; int main()&#123; srand((unsigned int)time(NULL)); // 生成伪随机数，每次的随机数都不一样 int n,m; unsigned long kb[700][700]; //默认最大棋盘大小 printf("请输入棋盘大小： "); scanf("%d",&amp;n); printf("请输入棋子数量： "); scanf("%d",&amp;m); while(m--) //生成 0 ~ n-1 的随机数 并赋值为 1 &#123; int a=rand()%n,b=rand()%n; kb[a][b]=1; &#125; for(int i=0;i&lt;n;i++) // 生 成 棋 盘 &#123; for(int j =0;j&lt;n;j++) // ┏┓┗┛┠┷┨┯┼● &#123; if(kb[i][j]==1) printf("●"); else &#123; if (i == 0 &amp;&amp; j == 0) printf("┏ "); else if (i == 0 &amp;&amp; j == n - 1) printf("┓ "); else if (i == n - 1 &amp;&amp; j == 0) printf("┗ "); else if (i == n - 1 &amp;&amp; j == n - 1) printf("┛ "); else if (j == 0) printf("┠ "); else if (i == n - 1) printf("┷ "); else if (j == n - 1) printf("┨ "); else if (i == 0) printf("┯ "); else printf("┼ "); &#125; &#125; putchar('\n'); &#125; int flag = 0; // 默认不是好棋。 for(int i=0;i&lt;n;i++) // 判断 好棋 坏棋 &#123; for(int j=0;j&lt;n;j++) &#123; if (kb[i][j] == 1) &#123; if (j&gt;0 &amp;&amp; kb[i][j-1] == 1) //判断同一行有无相邻棋子 &#123; printf("好棋！\n"); flag = 1; break; &#125; if (i &gt;0 &amp;&amp; kb[i-1][j] == 1) //判断同一列有无相邻棋子 &#123; printf("好棋！\n"); flag = 1; break; &#125; &#125; &#125; &#125; if(flag == 0) printf("不是好棋"); return 0; &#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++初学]]></title>
    <url>%2FAngelNI.github.io%2FC-%E5%88%9D%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[C++ 初学（一）在一次解决排序问题时，初步接触C++中的sort（）函数，在问题解决上非常好用，不用自己再写排序的代码，就像python中 import 函数库一样，因为懒嘛，所以更懒，嘿嘿！！所以想接触一下C++，简单学习一下子。 C++C++是C语言的继承，它既可以进行C语言的过程化程序设计，又可以进行以抽象数据类型为特点的基于对象的程序设计，还可以进行以继承和多态为特点的面向对象的程序设计。C++擅长面向对象程序设计的同时，还可以进行基于过程的程序设计，因而C++就适应的问题规模而论，大小由之。 C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。 C++ 被认为是一种中级语言，它综合了高级语言和低级语言的特点。 C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。 C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。 好了废话不多说，开始！ Hello world12345678910#include &lt;iostream&gt;using namespace std;// // main() 是程序开始执行的地方 int main()&#123; cout &lt;&lt; "Hello World"; // 输出 Hello World return 0;&#125; 接下来我们讲解一下上面这段程序： C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 。 下一行 using namespace std; 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。 下一行 // main() 是程序开始执行的地方 是一个单行注释。单行注释以 // 开头，在行末结束。 下一行 int main() 是主函数，程序从这里开始执行。 下一行 cout &lt;&lt; “Hello World”; 会在屏幕上显示消息 “Hello World”。 下一行 return 0; 终止 main( )函数，并向调用进程返回值 0。 输入、输出C++的输出和输入是用“流”(stream)的方式实现的｡有关流对象cin､cout和流运算符的定义等信息是存放在C++的输入输出流库中的,因此如果在程序中使用cin､cout和流运算符,就必须使用预处理命令把头文件stream包含到本文件中:#include &lt;iostream&gt;尽管cin和cout不是C++本身提供的语句,但是在不致混淆的情况下,为了叙述方便,常常把由cin和流提取运算符“&gt;&gt;”实现输入的语句称为输入语句或cin语句,把由cout和流插入运算符“&lt;&lt;”实现输出的语句称为输出语句或cout语句｡根据C++的语法,凡是能实现某种操作而且最后以分号结束的都是语句｡ 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;iostream&gt;#include &lt;iomanip&gt; //格式化输出的头文件，注意这里不要加.husing namespace std;int main()&#123; int a,b,c; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; cout&lt;&lt;a&lt;&lt;setw(2)&lt;&lt;b&lt;&lt;setw(2)&lt;&lt;c&lt;&lt;endl; float num1 = 123.456f,num2 = 563.1f,num3 = 1.30f; float num4 = 123456.4444f; cout &lt;&lt; setprecision(4); cout &lt;&lt; "第一个数：" &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; "第二个数：" &lt;&lt; num2 &lt;&lt; endl; cout &lt;&lt; "第三个数：" &lt;&lt; num3 &lt;&lt; endl; cout &lt;&lt; "第四个数：" &lt;&lt; num4 &lt;&lt; endl;//endl 英语意思是end of line,即一行输出结束，然后输出下一行。 return 0; &#125; 头文件#include&lt;iomanip&gt;是格式化输出的头文件，注意后面不加 .h， 使用setw()来控制占位宽度。注意事项 setw() 虽然带有括号，但是其实是一个操作符，并不是函数。 setw() 主要引用头文件 iomanip 才能使用。 如果setw() 所约束的输出超过了限制，不会被截断。是多少位就输出多少位。 如果输出是浮点数，小数点也会占一个位。 如果输出是字符串，空格有段有效字符，占一个位。从上面的输出结果也可以看出来。 setw() 只能约束住跟自己相邻的一个输出。也就是说 使用setprecision()控制浮点数有效位注意事项： setprecision() 同样是一个操作符，需要包含头文件 iomanip。 如果输出浮点数不足位，不会在其后面补0。 如果末尾有0，默认是不输出的。后面我们有其他方法可以输出末尾的0。 setprecision() 不同于setw()，setprecision() 设置之后，在下次设置之前都是有效的。从程序结果中可以看出来。 如果要输出的位数过多，则用科学计数法表示，10为基数。 setfioflags() 控制定点输出12345678910111213141516#include &lt;iostream&gt;#include &lt;iomanip&gt; using namespace std; int main()&#123; float num1 = 13.000f,num2 = 14.568f,num3 = 1.2f; cout &lt;&lt; setiosflags(ios::fixed|ios::showpoint); cout &lt;&lt; setprecision(4); cout &lt;&lt; "第一个数：" &lt;&lt; num1 &lt;&lt; endl; cout &lt;&lt; "第三个数：" &lt;&lt; num2 &lt;&lt; endl; cout &lt;&lt; "第二个数：" &lt;&lt; num3 &lt;&lt; endl; return 0; &#125; setiosflags() 是通过状态标志来实现对输出的控制的。状态标志功能如下表 状态标志 功能 ios::left 左对齐，右边填空格 ios::dec 所有整数以十进制输出 ios::right 右对齐，左边填空格 ios::scientific 以科学计数法形式输出浮点数 ios::hex 所有整数以十六进制输出 ios::fixed 以定点形式输出浮点数 ios::oct 所有整数以八进制输出 ios::showpoint 显示小数点和尾部的零 ios::showpos 在正数前面输出+ ios::uppercase 对于十六进制输出，使用大写字母表示 setiosflags() 需要与 setprecision() 一起使用。如果状态标志设为 ios::fixed，那么setprecision()设置的数字，就表示小数位的个数，不足补零。]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Appreciation of Novels(1)]]></title>
    <url>%2FAngelNI.github.io%2FAppreciation%20of%20Novels%2F</url>
    <content type="text"><![CDATA[1.我因车祸而失明，所以我从不知女友长什么样。那年，她得了胃癌，临终前她将眼角膜移植给了我。我恢复光明后的第一件事就是找她的照片，然而我只找到她留给我的一封信，信里有一张空白照片，照片上写有一句话：“别再想我长什么样，下一个你爱上的人，就是我的模样。” 2.外婆离开人世的那个黄昏，外公在病房里陪伴着她走完了她生命的最后一段旅程。外婆临去前对外公说‘放学了’。一直假装平静的外公听完这句话后像个孩子似的大哭起来。葬礼结束后我问起外公这三个字的含义，外公告诉我说这是从前他和外婆还在上小学时外婆常说的一句话：放学了，我们一起回家吧。 3.她车祸去世后，他思念万分，利用时光机回到过去，阻止惨剧发生。机器出了差错，比预定时间早了几分钟。他拿出钥匙开门，听见卧室传出她的娇喘和男人的声音。她手机响了，他记得这是他打来的。“我得走了，我男人催我呢。”。他听着，惹羞成怒，出门偷了一辆车，看着急匆匆的她，一脚踩下油门。 4.妈妈你看！”小女孩开心地递过来一张写满字的纸。“我听见一个哥哥问姐姐怎么才会爱他，姐姐说只要每天在纸上写1000遍她的名字…”“傻孩子！”女人抱住小女孩：那宝贝是怎么知道爸爸名字的？“这里！”小女孩打开抽屉：上次爸爸把名字签在上面了！女人顺眼望去，里面躺着一张离婚协议书 5.他看着桌子上忙碌的蚂蚁，伸出手指，一下捏死一只。蚂蚁们大惊，四下乱窜。稍停，又排成一字继续工作。他又伸出手，再捏死一只。蚂蚁大乱，稍顷还是排一字。等到第10次时，蚂蚁们已经熟视无睹。当他向第11只下手时，轰隆一声，巨大的天花板砸了下来。他最后一眼，只看到推倒他房子的那只怪手。 6.他和她青梅竹马，相约为百姓杀贪官，仗剑天涯。一次刺杀失败被俘，他竟被招安，无数同仁被杀。她含泪发誓要刃叛徒，遂色诱贪官纳她为妾。十年后，他成平反大将。酒宴上，她起身献舞，刺中他手臂。他深情说，你之后，我再无爱过。她心软刃落，他抽刀刺死她，心想，真好骗。 7.他大她快二十岁，他对她很好，百般呵护，他们认识不到一年，他就执意要娶她。朋友都很羡慕她，她却犹豫不决，因为小时候一场手术意外造成她不孕，他是独子，庞大的家族事业等他继承，她不想耽误他。终於她鼓起勇气向他坦诚不孕的事实，他说我知道，当年那刀是我开的，这些年来我一直在找你！ 8.5岁“妈妈，烧红烧肉吧”“行，烧”15岁“妈妈，别烧红烧肉了，换换味道” “行，买别的菜” 35岁“儿子，啥时候回家吃一顿啊？妈给做红烧肉” “不行，最近忙” 50岁“妈妈今天路过你家，给你带红烧肉” “不行，今不在家” 70岁“妈，我想吃红烧肉” 那边，已经没有了妈妈的声音 9.就要做心脏移植手术了，他深情地望着躺在床上的妻子，拿签字表的手有点抖。“快签吧，你个窝囊废、穷鬼！”妻骂。手术很成功，她没有一点排异反应。“我那没心肝的丈夫哪？”她问护士。护士递过一张纸，上面画一颗鲜红的心和一行小字：“这是我最后能给你的了，我爱你。” 10.他与爸爸相依至大。他常问：为什么不给他找个后妈？爸爸总是笑说：此生只爱妈妈一个！后来他长大成家，爸爸说要结婚，他愤怒地打了那女人一耳光，骂爸爸是个骗子。从此，爸爸再未提及此事。多年后爸爸去世，他整理遗物时发现了一张自己婴儿时的照片，背面是沧桑的字迹：战友之子，当如吾儿！]]></content>
      <categories>
        <category>literature</category>
      </categories>
      <tags>
        <tag>literature</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法查找]]></title>
    <url>%2FAngelNI.github.io%2Fbinary_search%2F</url>
    <content type="text"><![CDATA[二分法查找二分法查找，二分搜所，也称折半搜索，每次查找区间减半，适用于数据量较大，对一个有序的数组中查找某一元素。 例如：给一有序的数组a[9]={1,2,3,4,5,6,7,8,9,}，想要确定 3 的位置。 实现：123(a[0]+a[8])/2=5 大于 3 则只需要查找a[0]~a[4]就可以(a[0]+a[4])/2=3 此时刚好等于3，则此时3的位置就是（0+4）/2=2则可知 a[2]=3 至此查找结束 下面通过一个例子来具体体验下二分法的妙处 Trailing Zeroesn的阶乘尾部有q个连续的0，现在给你q，请你算出满足条件的n，如果有多个n满足条件，输出最小的那个即可。 Input123输入一个T(T &lt;= 10000),表示样例数量。每个样例输入一个q。(1 &lt;= q &lt;= 100,000,000) output对于每个样例，输出满足条件的最小的n，如果没有满足条件的则输出”impossible”。. Sample Input12345673125 Sample Output12345Case 1: 5Case 2: 10Case 3: impossible 思路这是一个判断阶乘后面有多少个零，输出满足条件下的最小解。 首先判断0的个数，我们可以通过判断5的个数来判断0`的个数（10可以分成2*5） 1例如：5！=1*2*3*4*5=120 代码实现12345678910long long fn(long long n) //求n阶乘的末尾0个数 &#123; long long a = 0; while(n) &#123; a += n/5; n = n/5; &#125; return a;&#125; 例如：判断25！末尾有几个0 a=25/5 –&gt; a=5 a+=5/5 –&gt; a=6 由此可以判断25的阶乘末尾有6个零（拿计算器验证） 整个题解（这是大佬写的，我偷偷拿来哈~） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950##### #include&lt;iostream&gt; //cin，cout数据流输入输出的头文件#include&lt;cstdio&gt;using namespace std;typedef long long ll; //声明定义long long 的别名 llconst ll maxn = 1e17; //题目中0的个数 1~1e9ll fn(ll n)//求n阶乘的末尾0个数 &#123; ll a = 0; while(n) &#123; a += n/5; n = n/5; &#125; return a;&#125;int main()&#123; int n, q; ll ans;//定义所要求的答案 int Case = 0; cin&gt;&gt;n; //输入测试组数 while(n--) &#123; Case++;//判断测试第几个 cin&gt;&gt;q;//输入0的个数 int l, r;//定义左值，和右值 l =1; r = maxn; ans = 0; while(r&gt;=l) &#123; ll mid = (l+r)&gt;&gt;1; //直接平均可能溢出，所以用这个 注： &gt;&gt; 值的二进制形式右移一位，相当于十进制除2 if(fn(mid)==q) &#123; ans = mid;//如果中间的那个数零的个数恰好等于q，则为答案 r = mid-1; &#125; else if(fn(mid)&lt;q) l = mid+1;//如果中间的值0的个数小于q，则左值++ else r = mid-1;// 否则 右值—— &#125; if(ans) printf("Case %d: %lld", Case, ans);//如果结果不为零，按输出格式打印 else printf("Case %d: impossible", Case);//否则，则输出impossile cout&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Makedown]]></title>
    <url>%2FAngelNI.github.io%2FMakedown%2F</url>
    <content type="text"><![CDATA[最近经过几天的奋斗，自己的博客基本框架终于搭建成功，接下来就是开始写文章了，不过上来就碰上个头疼的问题，就是怎么写的问题，我就想度娘请教（度娘，真帅），说是用Markdown语法写，最近在Notebook上写Python的学习笔记，老师说过要自学Markdown语法，说是非常简单（没错，就是很简单），下面就是Markdown的语法介绍啦，要好好学哟。 在编写 Markdown 时，强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora 按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览 这里附上 Typora 的下载地址：点击这里 , 有兴趣的朋友可以下载来试试 好，下面开始进入正题，介绍一些常用的 Markdown 语法 (1) 标题Markdown语法：1234567891011#一级标题``##二级标题``###三级标题``####四级标题``#####五级标题``######六级标题 Typora快捷键：1234567891011Ctrl + 1：一级标题Ctrl + 2：二级标题Ctrl + 3：三级标题Ctrl + 4：四级标题Ctrl + 5：五级标题Ctrl + 6：六级标题 (2)粗体、斜体、删除线Markdown语法：1234567*斜体*``**粗体**``***加粗斜线***``~~删除线~~ Typora快捷键：1234567Ctrl+l ：斜体Ctrl+B：粗体Ctrl+U：下划线Alt + Shift + 5 ：删除线 (3) 引用块Markdown语法：1&gt; 文字引用 Typora快捷键：1Ctrl + Shift + Q (4)代码块Markdown语法：12&apos; 行内代码&apos;&apos;&apos;&apos; 多行代码&apos;&apos;&apos; Typora快捷键：123行内代码： Ctrl + Shift + `多行代码：Ctrl + Shift +K (5)公式块Markdown语法：1$$数学公式$$ Typora快捷键：1Ctrl + Shift + M (6)分割线Markdown 语法：12345方法1：---``方法2：+++``方法3：*** (7)列表Markdown语法：12341.有序列表项2. * 无序列表项3. + 无序列表项4. - 无序列表项 Typora快捷键：有序列表项：Ctrl+Shift+[ 有序列表项：Ctrl+Shift+] (8) 表格Markdown语法：12341. 表头1|表头2-|-|-内容11|内容12内容21|内容22 Typora 快捷键：Ctrl+T (9)超链接Markdown语法：1234方法一：[链接文字](链接地址 &quot;链接描述&quot;)例如：[示例链接](https://www.example.com/ &quot;示例链接&quot;)方法二：&lt;链接地址&gt;例如：&lt;https://www.example.com/&gt; Typora快捷键：Ctrl+K (10)图片Markdown语法：12![图片文字](图片地址 &quot;图片描述&quot;)例如：![示例图片](https://www.example.com/example.PNG &quot;示例图片&quot;) Typora快捷键：Ctrl+Shift+I]]></content>
      <categories>
        <category>Makedown</category>
      </categories>
      <tags>
        <tag>Makedown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github]]></title>
    <url>%2FAngelNI.github.io%2Fhexo-github%2F</url>
    <content type="text"><![CDATA[博客搭建(自己总结)之前自己搭建博客，可以说废了很大的劲，这里总结了一下各位大佬们搭建博客的方法，供大家借鉴。 1.安装所需软件1.git安装Windows系统下安装git 可以直接到官网下载安装点击这里 由于访问的是外网，下载速度可能会慢（也可能非常慢） 下面提供百度云的下载地址 64-bit Git for Windows Setup : https://npm.taobao.org/mirrors/git-for-windows/v2.21.0.windows.1/Git-2.21.0-64-bit.exe 2.Node.js安装可以直接到官网下载安装点击这里 百度网盘资源： https://pan.baidu.com/s/1hKVcYfPorRX89hl7D4R1eA 提取码：wsti 下载完成后，安装时一定要点击 Add to PATH 安装完成后，打开cmd，输入 node -v 测试安装是否成功 下面来解决npm卡顿问题 1.打开cmd，换成阿里源 11.npm config set registry https://registry.npm.taobao.org 2.验证命令 12.npm config get registry //返回https://registry.npm.taobao.org，说明镜像配置成功 3.安装cnpm 13.npm install -g cnpm --registry=https://registry.npm.taobao.org 3.hexo安装打开git目录下的git-bash.exe，输入下面代码 npm install -g hexo-cli 安装hexo完成后执行下列命令 123hexo init &lt;文件夹名&gt; cd &lt;文件夹名&gt;npm install hexo 理论上安装在git文件夹下 4.在github上注册账号并同时建立仓库gitHub是一个面向开源及私有软件项目的托管平台，因为只支持git 作为唯一的版本库格式进行托管，故名gitHub。（来源百度百科） github官网点击这里 这个是github基础设置和使用详解点击这里 5.ssh授权获取私钥先配置SSH,在git-bash下输入 12git config --global user.name &quot;github注册名&quot;git config --global user.email &quot;github注册邮箱&quot; 打开git bash，输入ssh-kengen -t rsa，停顿时，敲击回车 最后会在C盘目录下生成id_ras和id_rsa.pub两个文件夹，用记事本打开id_rsa.pub，复制打开的文件内容到 github-&gt;setting-&gt;SSH and GPG key 下 添加后，在git-bash进行测试，输入 ssh -T git@github.com 如果返回Hi username ！You’ve successfully ……，说明配置成功 6.配置_config.yml打开你的hexo目录下的_config.yml文档（我用的是notepad++打开的） 修改最下面的deploy下的内容 12345type: gitrepository : //这里是你的仓库下，点击Clone ordownload（绿色的）点击Use SSH复制框框内的内容到这里。branch：//这里是你的bransh名称，默认为master 下面来修改 url和 root 123url ：// 是你的github 分配的地址root：// 是你的仓库的名字 一定要注意每一项冒号后有一个英文空格 7.本地测试打开git bash进入博客的根目录（cd + 文件夹名） 输入 12345hexo cleanhexo ghexo s hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容。 显示的主题是 hexo 默认的 hexo 操作指令点击这里 8.上传到github仓库首先先安装hexo拓展库，打开git bash输入 12npm install hexo-deployer-git --savenpm install 然后输入 1234hexo clean//清除缓存hexo g//生成静态文件hexo d/上传打开github分配的网站，就可以看到你的blog了 后记自己搭建博客可能不是一帆风顺的，可能遇到各种不同的错误，一定要耐得住性子，一步一步来搭建。 记得，一定要善用搜索，遇到不懂得问题去百度上搜索。 最后，度娘，可真帅哪！！！]]></content>
      <categories>
        <category>hexo+github</category>
      </categories>
      <tags>
        <tag>hexo+github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello world]]></title>
    <url>%2FAngelNI.github.io%2FHello-world-0%2F</url>
    <content type="text"><![CDATA[记一次过程经历 最近，自己在搭一个博客，用 hexo+github，一开始按照网上的教程下载相应的软件，cmd安装，git bash 安装hexo，最开始可是在自己的本地可以预览，效果不错，直接就上传到github上的我的repo，结果cmd出错，由于对hexo 文件的位置不清，和出现的错误，我直接就删除了hexo，但是不是直接的卸载，有些文件还在（找不到啊 呜呜~），我用重新npm安装，发现还是不行，当时头大到想要格式化电脑了（还好没有，要不然就要重新慢慢下载了），然后我去找baidu，简书，发现自己的许多错误操作。好吧，我又从新开始。还是有error，我就按个所错误，发现自己有许多的本地配置没有设置，我就一条一条的修改（可气人了，一步踩一个坑，一步填一个坑），花了两天才把本地配置好（上课没时间啊）。 又因为，默认的主题很low（只是个人而言），不怎么喜欢，想换个主题，hexo上面有好多的主题，一个一个翻看，也没有喜欢的，现在比较流行的是NEXT主题（没错我找了度娘），就在网上下载NEXT主题包，一开始的主题内容，没设计的，所以我又找了度娘，还在CSDN上搜搜，发现许多大佬掉了许多的坑，也有填坑的方法(坑和经验，傻傻分不清），就开始一步一步自己搭，终于，经过一天多的自己的骚操作，在清明节的下午本地可以看到比较好的主题设置（还有点不满意，后续会修改）。 感受 （真是不作死不会死，谁TM知道我为什么突然想到建博客呢！） 经过三天多自己的摸索，我这个小小白终于把自己的blog建成了（~~热烈欢迎大家访问）。在建博客的过程中，真是有点头大了，因为自己对命令行操作一点不了解，完全是两眼一模黑，在黑暗中摸索（哈哈，有点夸张），出现错误也不知道哪里的问题，真的很感谢度娘的帮助（说白了，多谢大佬们的坑啊）。 这篇文章的标题是printf(“Hello,world”),学C语言的都知道这是入门的基础程序，我想用这个标题想说，当你去接触一个陌生不懂的东西时，不是一帆风顺的，总会有大波小浪，不过，经过自己的一步一步的摸索总会找到自己的___（你懂的哈），不管如何都不要放弃，既然已经迈开了重要的第一步，就要坚持走到终点。 对了，还有还有，“生命在于运动，电脑在于折腾啊”，不管会不会，先折腾折腾吧（坏了我可不管~~) . . . . . . . . 度娘，真帅！！！]]></content>
      <categories>
        <category>Life essay</category>
      </categories>
      <tags>
        <tag>Life essay</tag>
      </tags>
  </entry>
</search>
